<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>interface类型 | 谟涅摩绪涅📖</title>
<meta name="keywords" content="golang" />
<meta name="description" content="golang interface类型">
<meta name="author" content="dingansichKum0">
<link rel="canonical" href="https://dingansichKum0.github.io/posts/interface%E7%B1%BB%E5%9E%8B/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.d9015f4cb657fd3539b79b29ffbd11de4175ccd105ad7591beffaadfafb48488.css" integrity="sha256-2QFfTLZX/TU5t5sp/70R3kF1zNEFrXWRvv&#43;q36&#43;0hIg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.27cd435cc9ed6abb4b496581b151804f79f366c412620272bb94e2f5f598ebcc.js" integrity="sha256-J81DXMntartLSWWBsVGAT3nzZsQSYgJyu5Ti9fWY68w="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://dingansichKum0.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://dingansichKum0.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://dingansichKum0.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://dingansichKum0.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://dingansichKum0.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.80.0" />
<meta property="og:title" content="interface类型" />
<meta property="og:description" content="golang interface类型" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://dingansichKum0.github.io/posts/interface%E7%B1%BB%E5%9E%8B/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-09T00:00:00&#43;08:00" />
<meta property="article:modified_time" content="2021-07-29T18:06:00&#43;08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="interface类型"/>
<meta name="twitter:description" content="golang interface类型"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://dingansichKum0.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "interface类型",
      "item": "https://dingansichKum0.github.io/posts/interface%E7%B1%BB%E5%9E%8B/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "interface类型",
  "name": "interface类型",
  "description": "golang interface类型",
  "keywords": [
    "golang"
  ],
  "articleBody": "Go 语言与鸭子类型的关系  If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.\n如果某个东西长得像鸭子, 像鸭子一样游泳, 像鸭子一样嘎嘎叫, 那它就可以被看成是一只鸭子.\n在 Go 语言中, 如果类型的方法集完全包含接口的方法集，则可认为该类型实现了该接口.\n 鸭子类型是一种动态语言的风格, 在这种风格中, 一个对象有效的语义, 不是由继承自特定的类或实现特定的接口, 而是由它\"当前方法和属性的集合\"决定. Go 作为一种静态语言, 通过接口实现了 鸭子类型, 实际上是 Go 的编译器在其中作了隐匿的转换工作.\n值接收者和指针接收者的区别 package main import \"fmt\" type Person struct { age int } func (p Person) howOld() int { return p.age } func (p *Person) growUp() { p.age += 1 } func main() { // qcrao 是值类型  qcrao := Person{age: 18} // 值类型 调用接收者也是值类型的方法  fmt.Println(qcrao.howOld()) // 值类型 调用接收者是指针类型的方法  qcrao.growUp() fmt.Println(qcrao.howOld()) // ----------------------  // stefno 是指针类型  stefno := \u0026Person{age: 100} // 指针类型 调用接收者是值类型的方法  fmt.Println(stefno.howOld()) // 指针类型 调用接收者也是指针类型的方法  stefno.growUp() fmt.Println(stefno.howOld()) }    - 值接收者 指针接收者     值类型调用者 方法会使用调用者的一个副本，类似于\"传值\" 使用值的引用来调用方法, 上例中 qcrao.growUp() 实际上是 (\u0026qcrao).growUp()   指针类型调用者 指针被解引用为值, 上例中, stefno.howOld() 实际上是 (*stefno).howOld() 实际上也是\"传值\", 方法里的操作会影响到调用者, 类似于指针传参, 拷贝了一份指针    区别 如果方法的接收者是值类型, 无论调用者是对象还是对象指针, 修改的都是对象的副本, 不影响调用者; 如果方法的接收者是指针类型, 则调用者修改的是指针指向的对象本身.\n使用值接收者还是指针接收者, 不是由该方法是否修改了调用者 (也就是接收者) 来决定, 而是应该基于该类型的本质.\n 如果类型具备\"原始的本质\", 也就是说它的成员都是由 Go 语言里内置的原始类型, 如字符串, 整型值等, 那就定义值接收者类型的方法. 像内置的引用类型, 如 slice, map, interface, channel, 这些类型比较特殊, 声明他们的时候, 实际上是创建了一个 header, 对于他们也是直接定义值接收者类型的方法. 这样, 调用函数时, 是直接 copy 了这些类型的 header, 而 header 本身就是为复制设计的. 如果类型具备非原始的本质, 不能被安全地复制, 这种类型总是应该被共享, 那就定义指针接收者的方法. 比如 go 源码里的文件结构体 (struct File) 就不应该被复制, 应该只有一份实体.  iface 和 eface 的区别 iface 和 eface 都是 Go 中描述接口的底层结构体, 区别在于 iface 描述的接口包含方法, 而 eface 则是不包含任何方法的空接口: interface{}.\niface import \"unsafe\" type iface struct { tab *itab // 接口类型以及实际类型  data unsafe.Pointer // 接口具体的值, 一般而言是一个指向堆内存的指针 } type itab struct { inter *interfacetype _type *_type hash uint32 // copy of _type.hash. Used for type switches.  _ [4]byte fun [1]uintptr // variable sized. 存储的是第一个方法的函数指针，如果有更多的方法，在它之后的内存空间里继续存储. } type interfacetype struct { typ _type pkgpath name mhdr []imethod } type _type struct { // 类型大小  size uintptr ptrdata uintptr // 类型的 hash 值  hash uint32 // 类型的 flag，和反射相关  tflag tflag // 内存对齐相关  align uint8 fieldalign uint8 // 类型的编号，有bool, slice, struct 等等等等  kind uint8 equal func(unsafe.Pointer, unsafe.Pointer) bool // gc 相关  gcdata *byte str nameOff ptrToThis typeOff }   eface type eface struct { _type *_type data unsafe.Pointer } _type _type 是描述 Go 语言中各种数据类型的结构体\ntype _type struct { // 类型大小  size uintptr ptrdata uintptr // 类型的 hash 值  hash uint32 // 类型的 flag，和反射相关  tflag tflag // 内存对齐相关  align uint8 fieldalign uint8 // 类型的编号，有bool, slice, struct 等等等等  kind uint8 equal func(unsafe.Pointer, unsafe.Pointer) bool // gc 相关  gcdata *byte str nameOff ptrToThis typeOff } Go 语言各种数据类型都是在 _type 字段的基础上, 增加一些额外的字段来进行管理的:\ntype arraytype struct { typ _type elem *_type slice *_type len uintptr } type chantype struct { typ _type elem *_type dir uintptr } type slicetype struct { typ _type elem *_type } type functype struct { typ _type inCount uint16 outCount uint16 } type ptrtype struct { typ _type elem *_type } type structfield struct { name name typ *_type offsetAnon uintptr } 这些数据类型的结构体定义, 是反射实现的基础.\n接口的动态类型和动态值 import \"unsafe\" type iface struct { tab *itab // 接口类型以及实际类型  data unsafe.Pointer // 接口具体的值, 一般而言是一个指向堆内存的指针 } iface 类型包含两个字段:\n tab: 是接口表指针，指向类型信息 data: 是数据指针，则指向具体的数据  接口类型和 nil 作比较 接口值的零值是指动态类型和动态值都为 nil, 这个接口才能被认为 接口值 == nil.\n  package main import \"fmt\" func main() { var a interface{} fmt.Println(c == nil) // true  var b *string fmt.Println(b == nil) // true  a = b fmt.Println(a == nil) // false } b 赋值给 a 后, a 的动态类型为 *string , 动态值为 nil , 所以 a == nil 为 false .\n  package main import \"fmt\" type MyError string func (i MyError) Error() string { return i } func main() { err := HandleError() fmt.Println(err == nil) // false } func HandleError() error { var err *MyError = nil return err } 调用 HandleError 返回 error 接口类型, 动态类型为 *MyError , 动态值为 nil .\n  打印接口的动态值和类型 package main import ( \"unsafe\" \"fmt\" ) type iface struct { itab, data uintptr } func main() { var a interface{} = nil var b interface{} = (*int)(nil) x := 5 var c interface{} = (*int)(\u0026x) ia := *(*iface)(unsafe.Pointer(\u0026a)) ib := *(*iface)(unsafe.Pointer(\u0026b)) ic := *(*iface)(unsafe.Pointer(\u0026c)) fmt.Println(ia) // {0 0}  fmt.Println(ib) // {17426912 0}  fmt.Println(ic) // {17426912 842350714568}  fmt.Println(*(*int)(unsafe.Pointer(ic.data))) // 5 }  a 的动态类型和动态值的地址均为 0, 也就是 nil; b 的动态类型和 c 的动态类型一致, 都是 *int; c 的动态值为 5.  编译器自动检测类型是否实现接口 var _ io.Writer = (*myWriter)(nil) 编译器会由此检查 *myWriter 类型是否实现了 io.Writer 接口.\npackage main import \"io\" type myWriter string func (w *myWriter) Write(p []byte) (n int, err error) { return } func main() { // 检查 *myWriter 类型是否实现了 io.Writer 接口  var _ io.Writer = (*myWriter)(nil) // 检查 myWriter 类型是否实现了 io.Writer 接口  var _ io.Writer = myWriter{} } src/main.go:15:6: cannot use myWriter literal (type myWriter) as type io.Writer in assignment: myWriter does not implement io.Writer (missing Write method) myWriter 没用实现 io.Writer\n接口类型的赋值 (构造) 和断言 赋值 针对不同类型有以下函数:\n convT2E16, convT2I16 convT2E32, convT2I32 convT2E64, convT2I64 convT2Estring, convT2Istring convT2Eslice, convT2Islice convT2Enoptr, convT2Inoptr\n func convT2I(tab *itab, elem unsafe.Pointer) (i iface) { t := tab._type if raceenabled { raceReadObjectPC(t, elem, getcallerpc(), funcPC(convT2I)) } if msanenabled { msanread(elem, t.size) } x := mallocgc(t.size, t, true) typedmemmove(t, x, elem) i.tab = tab i.data = x return } 把 tab 赋给了 iface 的 tab 字段; data 部分则是在堆上申请了一块内存, 然后将 elem 指向的数据拷贝过去.\n断言 func assertI2I(inter *interfacetype, i iface) (r iface) { tab := i.tab if tab == nil { // explicit conversions require non-nil interface value.  panic(\u0026TypeAssertionError{nil, nil, \u0026inter.typ, \"\"}) } if tab.inter == inter { r.tab = tab r.data = i.data return } r.tab = getitab(inter, tab._type, false) r.data = i.data return } func assertI2I2(inter *interfacetype, i iface) (r iface, b bool) { tab := i.tab if tab == nil { return } if tab.inter != inter { tab = getitab(inter, tab._type, true) if tab == nil { return } } r.tab = tab r.data = i.data b = true return } func assertE2I(inter *interfacetype, e eface) (r iface) { t := e._type if t == nil { // explicit conversions require non-nil interface value.  panic(\u0026TypeAssertionError{nil, nil, \u0026inter.typ, \"\"}) } r.tab = getitab(inter, t, false) r.data = e.data return } func assertE2I2(inter *interfacetype, e eface) (r iface, b bool) { t := e._type if t == nil { return } tab := getitab(inter, t, true) if tab == nil { return } r.tab = tab r.data = e.data b = true return } 判断需断言的变量 (iface) 是否满足接口类型 (interfacetype).\nassertI2I 对应 接口断言返回一个参数:\npackage main import ( \"errors\" \"fmt\" ) func main(args) { var a interface{} = errors.New(\"error\") err := a.(error) fmt.Println(err.Error()) } assertI2I2 则对应返回两个参数的情况:\npackage main import ( \"errors\" \"fmt\" ) func main(args) { var a interface{} = errors.New(\"error\") if err, ok := a.(error); ok { fmt.Println(err.Error()) } } 都在编译阶段编译器判断.\n打印接口类型的hash值 package main import ( \"fmt\" \"unsafe\" ) type iface struct { tab *itab data unsafe.Pointer } type itab struct { inter uintptr _type uintptr hash uint32 _ [4]byte fun [1]uintptr } func main() { p := Person(Student{age: 18}) iface := (*iface)(unsafe.Pointer(\u0026p)) fmt.Printf(\"iface.tab.hash = %#x\\n\", iface.tab.hash) // iface.tab.hash = 0xd4209fda } 类型转换和断言的区别 类型转换 Go 语言中不允许隐式类型转换, 也就是说 = 两边, 不允许出现类型不相同的变量. 类型转换前后的两个类型必须相互兼容.\n  :=  (  )\n package main import \"fmt\" func main() { var i int = 9 var f float64 f = float64(i) fmt.Printf(\"%T, %v\\n\", f, f) f = 10.8 a := int(f) fmt.Printf(\"%T, %v\\n\", a, a) // s := []int(i) } 断言 空接口 interface{} 没有定义任何函数, 因此 Go 中所有类型都实现了空接口. 当一个函数的形参是 interface{}, 那么在函数中, 需要对形参进行断言, 从而得到它的真实类型.\n ， := .( 目标类型 ) // 安全类型断言  := .( 目标类型 )　//非安全类型断言\n package main import \"fmt\" type Student struct { Name string Age int } func main() { var i interface{} = new(Student) s := i.(*Student) fmt.Println(s) } switch 形式断言\npackage main import \"fmt\" type Student struct { Name string Age int } func main() { var i interface{} judge(i) } func judge(v interface{}) { fmt.Printf(\"%p %v\\n\", \u0026v, v) switch v := v.(type) { case nil: fmt.Printf(\"%p %v\\n\", \u0026v, v) fmt.Printf(\"nil type[%T] %v\\n\", v, v) case Student: fmt.Printf(\"%p %v\\n\", \u0026v, v) fmt.Printf(\"Student type[%T] %v\\n\", v, v) case *Student: fmt.Printf(\"%p %v\\n\", \u0026v, v) fmt.Printf(\"*Student type[%T] %v\\n\", v, v) default: fmt.Printf(\"%p %v\\n\", \u0026v, v) fmt.Printf(\"unknow\\n\") } } fmt.Println 函数 fmt.Println 函数的参数是 interface{}. 对于内置类型, 函数内部会用穷举法, 得出它的真实类型, 然后转换为字符串打印. 而对于自定义类型, 首先确定该类型是否实现了 String() 方法. 如果实现了, 则直接打印输出 String() 方法的结果; 否则, 会通过反射来遍历对象的成员进行打印.\n因为 Student 结构体没有实现 String() 方法, 所以 fmt.Println 会利用反射挨个打印成员变量:\npackage main import \"fmt\" type Student struct { Name string Age int } func main() { s := Student{ Name: \"zzz\", Age: 18, } fmt.Println(s) // {zzz 18} } 增加一个 String() 方法的实现:\nimport \"fmt\" func (s Student) String() string { return fmt.Sprintf(\"[Name: %s], [Age: %d]\", s.Name, s.Age) // [Name: zzz], [Age: 18] } 修改 String() 方法:\nimport \"fmt\" func (s *Student) String() string { return fmt.Sprintf(\"[Name: %s], [Age: %d]\", s.Name, s.Age) // {zzz 18} } 打印结果并没用调用 String() ,因为:\n 类型 T 只有接受者是 T 的方法; 而类型 *T 拥有接受者是 T 和 *T 的方法. 语法上 T 能直接调 *T 的方法仅仅是 Go 的语法糖.\n 要调用 String() 需要:\nfmt.Println(\u0026s) 接口转换的原理 类型有 m 个方法, 某接口有 n 个方法, 则很容易知道这种判定的时间复杂度为 O(mn); Go 会对方法集的函数按照函数名的字典序进行排序, 所以实际的时间复杂度为 O(m+n).\npackage main import \"fmt\" type coder interface { code() run() } type runner interface { run() } type Gopher struct { language string } func (g Gopher) code() { return } func (g Gopher) run() { return } func main() { var c coder = Gopher{} var r runner r = c fmt.Println(c, r) } Gopher 类型同时满足 coder 接口和 runner 接口.\nconvI2I 函数将一个 interface 转换成 另一个 interface .\nfunc convI2I(inter *interfacetype, i iface) (r iface) { tab := i.tab if tab == nil { return } if tab.inter == inter { r.tab = tab r.data = i.data return } r.tab = getitab(inter, tab._type, false) r.data = i.data return } inter 表示要转成的接口类型, i 表示一个实体类型. 如果要转换的接口类型和实体类型的接口类型相同就直接返回; 否则就用调用 getitab 函数去匹配满转方法集的接口.\nimport \"unsafe\" func getitab(inter *interfacetype, typ *_type, canfail bool) *itab { if len(inter.mhdr) == 0 { throw(\"internal error - misuse of itab\") } // easy case  if typ.tflag\u0026tflagUncommon == 0 { if canfail { return nil } name := inter.typ.nameOff(inter.mhdr[0].name) panic(\u0026TypeAssertionError{nil, typ, \u0026inter.typ, name.name()}) } var m *itab // First, look in the existing table to see if we can find the itab we need.  // This is by far the most common case, so do it without locks.  // Use atomic to ensure we see any previous writes done by the thread  // that updates the itabTable field (with atomic.Storep in itabAdd).  t := (*itabTableType)(atomic.Loadp(unsafe.Pointer(\u0026itabTable))) if m = t.find(inter, typ); m != nil { goto finish } // Not found. Grab the lock and try again.  lock(\u0026itabLock) if m = itabTable.find(inter, typ); m != nil { unlock(\u0026itabLock) goto finish } // Entry doesn't exist yet. Make a new entry \u0026 add it.  m = (*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*sys.PtrSize, 0, \u0026memstats.other_sys)) m.inter = inter m._type = typ // The hash is used in type switches. However, compiler statically generates itab's  // for all interface/type pairs used in switches (which are added to itabTable  // in itabsinit). The dynamically-generated itab's never participate in type switches,  // and thus the hash is irrelevant.  // Note: m.hash is _not_ the hash used for the runtime itabTable hash table.  m.hash = 0 m.init() itabAdd(m) unlock(\u0026itabLock) finish: if m.fun[0] != 0 { return m } if canfail { return nil } // this can only happen if the conversion  // was already done once using the , ok form  // and we have a cached negative result.  // The cached result doesn't record which  // interface function was missing, so initialize  // the itab again to get the missing function name.  panic(\u0026TypeAssertionError{concrete: typ, asserted: \u0026inter.typ, missingMethod: m.init()}) } getitab 函数会根据 interfacetype 和 _type 去全局的 itab 哈希表中查找, 如果能找到, 则直接返回; 否则, 会根据给定的 interfacetype 和 _type 新生成一个 itab, 并插入到 itab 哈希表, 这样下一次就可以直接拿到 itab.\n这里查找了两次, 并且第二次上锁了, 这是因为如果第一次没找到, 在第二次仍然没有找到相应的 itab 的情况下, 需要新生成一个, 并且写入哈希表, 因此需要加锁. 这样, 其他协程在查找相同的 itab 并且也没有找到时, 第二次查找时, 会被挂住, 之后, 就会查到第一个协程写入哈希表的 itab.\nitabAdd 函数会把 itab 写入到全局itabTable\nimport \"unsafe\" func itabAdd(m *itab) { // Bugs can lead to calling this while mallocing is set,  // typically because this is called while panicing.  // Crash reliably, rather than only when we need to grow  // the hash table.  if getg().m.mallocing != 0 { throw(\"malloc deadlock\") } t := itabTable if t.count = 3*(t.size/4) { // 75% load factor  // Grow hash table.  // t2 = new(itabTableType) + some additional entries  // We lie and tell malloc we want pointer-free memory because  // all the pointed-to values are not in the heap.  t2 := (*itabTableType)(mallocgc((2+2*t.size)*sys.PtrSize, nil, true)) t2.size = t.size * 2 // Copy over entries.  // Note: while copying, other threads may look for an itab and  // fail to find it. That's ok, they will then try to get the itab lock  // and as a consequence wait until this copying is complete.  iterate_itabs(t2.add) if t2.count != t.count { throw(\"mismatched count during itab table copy\") } // Publish new hash table. Use an atomic write: see comment in getitab.  atomicstorep(unsafe.Pointer(\u0026itabTable), unsafe.Pointer(t2)) // Adopt the new table as our own.  t = itabTable // Note: the old table can be GC'ed here.  } t.add(m) } func iterate_itabs(fn func(*itab)) { // Note: only runs during stop the world or with itabLock held,  // so no other locks/atomics needed.  t := itabTable for i := uintptr(0); i t.size; i++ { m := *(**itab)(add(unsafe.Pointer(\u0026t.entries), i*sys.PtrSize)) if m != nil { fn(m) } } } 如何用 interface 实现多态 多态是一种运行期的行为, 它有以下几个特点:\n 一种类型具有多种类型的能力 允许不同的对象对同一消息做出灵活的反应 以一种通用的方式对待个使用的对象 非动态语言必须通过继承和接口的方式来实现   package main import \"fmt\" func main() { s := Student{age: 18} whatJob(\u0026s) growUp(\u0026s) fmt.Println(s) p := Programmer{age: 100} whatJob(p) growUp(p) fmt.Println(p) } func whatJob(p Person) { p.job() } func growUp(p Person) { p.growUp() } type Person interface { job() growUp() } type Student struct { age int } func (p Student) job() { fmt.Println(\"I am a student.\") return } func (p *Student) growUp() { p.age += 1 return } type Programmer struct { age int } func (p Programmer) job() { fmt.Println(\"I am a programmer.\") return } func (p Programmer) growUp() { p.age += 10 return } Go 接口与 C++ 接口有何异同 接口定义了一种规范, 描述了类的行为和功能, 而不做具体实现.\nC++ 的接口是使用抽象类来实现的, 如果类中至少有一个函数被声明为纯虚函数, 则这个类就是抽象类. 纯虚函数是通过在声明中使用 “= 0” 来指定的. 例如:\nclass Shape { public: // 纯虚函数  virtual double getArea() = 0; private: string name; // 名称 };  设计抽象类的目的, 是为了给其他类提供一个可以继承的适当的基类. 抽象类不能被用于实例化对象, 它只能作为接口使用. 派生类需要明确地声明它继承自基类, 并且需要实现基类中所有的纯虚函数.\nC++ 定义接口的方式称为“侵入式”, 而 Go 采用的是 “非侵入式”, 不需要显式声明, 只需要实现接口定义的函数, 编译器自动会识别.\nC++ 和 Go 在定义接口方式上的不同, 也导致了底层实现上的不同. C++ 通过虚函数表来实现基类调用派生类的函数; 而 Go 通过 itab 中的 fun 字段来实现接口变量调用实体类型的函数. C++ 中的虚函数表是在编译期生成的; 而 Go 的 itab 中的 fun 字段是在运行期间动态生成的. 原因在于, Go 中实体类型可能会无意中实现 N 多接口, 很多接口并不是本来需要的, 所以不能为类型实现的所有接口都生成一个 itab, 这也是“非侵入式”带来的影响; 这在 C++ 中是不存在的, 因为派生需要显示声明它继承自哪个基类.\n ",
  "wordCount" : "2297",
  "inLanguage": "en",
  "datePublished": "2020-03-09T00:00:00+08:00",
  "dateModified": "2021-07-29T18:06:00+08:00",
  "author":[{
    "@type": "Person",
    "name": "dingansichKum0"
  }],
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://dingansichKum0.github.io/posts/interface%E7%B1%BB%E5%9E%8B/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "谟涅摩绪涅📖",
    "logo": {
      "@type": "ImageObject",
      "url": "https://dingansichKum0.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://dingansichKum0.github.io/" accesskey="h" title="谟涅摩绪涅📖 (Alt + H)">谟涅摩绪涅📖</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://dingansichKum0.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://dingansichKum0.github.io/categories" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://dingansichKum0.github.io/search" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://dingansichKum0.github.io/tags" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://dingansichKum0.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://dingansichKum0.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      interface类型
    </h1>
    <div class="post-description">
      golang interface类型
    </div>
    <div class="post-meta">March 9, 2020&nbsp;·&nbsp;11 min&nbsp;·&nbsp;dingansichKum0
</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <div class="details">Table of Contents</div>
        </summary>
        <div class="inner"><ul>
                <li>
                    <a href="#go-%e8%af%ad%e8%a8%80%e4%b8%8e%e9%b8%ad%e5%ad%90%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%85%b3%e7%b3%bb" aria-label="Go 语言与鸭子类型的关系">Go 语言与鸭子类型的关系</a></li>
                <li>
                    <a href="#%e5%80%bc%e6%8e%a5%e6%94%b6%e8%80%85%e5%92%8c%e6%8c%87%e9%92%88%e6%8e%a5%e6%94%b6%e8%80%85%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="值接收者和指针接收者的区别">值接收者和指针接收者的区别</a><ul>
                        
                <li>
                    <a href="#%e5%8c%ba%e5%88%ab" aria-label="区别">区别</a></li></ul>
                </li>
                <li>
                    <a href="#iface-%e5%92%8c-eface-%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="iface 和 eface 的区别">iface 和 eface 的区别</a><ul>
                        
                <li>
                    <a href="#iface" aria-label="iface">iface</a></li>
                <li>
                    <a href="#eface" aria-label="eface">eface</a></li>
                <li>
                    <a href="#type" aria-label="_type">_type</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%8e%a5%e5%8f%a3%e7%9a%84%e5%8a%a8%e6%80%81%e7%b1%bb%e5%9e%8b%e5%92%8c%e5%8a%a8%e6%80%81%e5%80%bc" aria-label="接口的动态类型和动态值">接口的动态类型和动态值</a><ul>
                        
                <li>
                    <a href="#%e6%8e%a5%e5%8f%a3%e7%b1%bb%e5%9e%8b%e5%92%8c-nil-%e4%bd%9c%e6%af%94%e8%be%83" aria-label="接口类型和 nil 作比较">接口类型和 nil 作比较</a><ul>
                        
                <li>
                    <a href="#%e6%89%93%e5%8d%b0%e6%8e%a5%e5%8f%a3%e7%9a%84%e5%8a%a8%e6%80%81%e5%80%bc%e5%92%8c%e7%b1%bb%e5%9e%8b" aria-label="打印接口的动态值和类型">打印接口的动态值和类型</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%bc%96%e8%af%91%e5%99%a8%e8%87%aa%e5%8a%a8%e6%a3%80%e6%b5%8b%e7%b1%bb%e5%9e%8b%e6%98%af%e5%90%a6%e5%ae%9e%e7%8e%b0%e6%8e%a5%e5%8f%a3" aria-label="编译器自动检测类型是否实现接口">编译器自动检测类型是否实现接口</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%8e%a5%e5%8f%a3%e7%b1%bb%e5%9e%8b%e7%9a%84%e8%b5%8b%e5%80%bc--%e6%9e%84%e9%80%a0--%e5%92%8c%e6%96%ad%e8%a8%80" aria-label="接口类型的赋值 (构造) 和断言">接口类型的赋值 (构造) 和断言</a><ul>
                        
                <li>
                    <a href="#%e8%b5%8b%e5%80%bc" aria-label="赋值">赋值</a></li>
                <li>
                    <a href="#%e6%96%ad%e8%a8%80" aria-label="断言">断言</a></li>
                <li>
                    <a href="#%e6%89%93%e5%8d%b0%e6%8e%a5%e5%8f%a3%e7%b1%bb%e5%9e%8b%e7%9a%84hash%e5%80%bc" aria-label="打印接口类型的hash值">打印接口类型的hash值</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2%e5%92%8c%e6%96%ad%e8%a8%80%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="类型转换和断言的区别">类型转换和断言的区别</a><ul>
                        
                <li>
                    <a href="#%e7%b1%bb%e5%9e%8b%e8%bd%ac%e6%8d%a2" aria-label="类型转换">类型转换</a></li>
                <li>
                    <a href="#%e6%96%ad%e8%a8%80" aria-label="断言">断言</a></li>
                <li>
                    <a href="#fmt-dot-println-%e5%87%bd%e6%95%b0" aria-label="fmt.Println 函数">fmt.Println 函数</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%8e%a5%e5%8f%a3%e8%bd%ac%e6%8d%a2%e7%9a%84%e5%8e%9f%e7%90%86" aria-label="接口转换的原理">接口转换的原理</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e7%94%a8-interface-%e5%ae%9e%e7%8e%b0%e5%a4%9a%e6%80%81" aria-label="如何用 interface 实现多态">如何用 interface 实现多态</a></li>
                <li>
                    <a href="#go-%e6%8e%a5%e5%8f%a3%e4%b8%8e-c-plus-plus-%e6%8e%a5%e5%8f%a3%e6%9c%89%e4%bd%95%e5%bc%82%e5%90%8c" aria-label="Go 接口与 C&#43;&#43; 接口有何异同">Go 接口与 C++ 接口有何异同</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="go-语言与鸭子类型的关系">Go 语言与鸭子类型的关系<a hidden class="anchor" aria-hidden="true" href="#go-语言与鸭子类型的关系">#</a></h2>
<blockquote>
<p>If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.</p>
<p>如果某个东西长得像鸭子, 像鸭子一样游泳, 像鸭子一样嘎嘎叫, 那它就可以被看成是一只鸭子.</p>
<p>在 Go 语言中, 如果类型的方法集完全包含接口的方法集，则可认为该类型实现了该接口.</p>
</blockquote>
<p>鸭子类型是一种动态语言的风格, 在这种风格中, 一个对象有效的语义, 不是由继承自特定的类或实现特定的接口, 而是由它&quot;当前方法和属性的集合&quot;决定.
Go 作为一种静态语言, 通过接口实现了 鸭子类型, 实际上是 Go 的编译器在其中作了隐匿的转换工作.</p>
<h2 id="值接收者和指针接收者的区别">值接收者和指针接收者的区别<a hidden class="anchor" aria-hidden="true" href="#值接收者和指针接收者的区别">#</a></h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Person</span> <span style="color:#66d9ef">struct</span> {
  <span style="color:#a6e22e">age</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#a6e22e">Person</span>) <span style="color:#a6e22e">howOld</span>() <span style="color:#66d9ef">int</span> {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">age</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Person</span>) <span style="color:#a6e22e">growUp</span>() {
  <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">age</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#75715e">// qcrao 是值类型
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">qcrao</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Person</span>{<span style="color:#a6e22e">age</span>: <span style="color:#ae81ff">18</span>}

  <span style="color:#75715e">// 值类型 调用接收者也是值类型的方法
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">qcrao</span>.<span style="color:#a6e22e">howOld</span>())

  <span style="color:#75715e">// 值类型 调用接收者是指针类型的方法
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">qcrao</span>.<span style="color:#a6e22e">growUp</span>()
  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">qcrao</span>.<span style="color:#a6e22e">howOld</span>())

  <span style="color:#75715e">// ----------------------
</span><span style="color:#75715e"></span>
  <span style="color:#75715e">// stefno 是指针类型
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">stefno</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">Person</span>{<span style="color:#a6e22e">age</span>: <span style="color:#ae81ff">100</span>}

  <span style="color:#75715e">// 指针类型 调用接收者是值类型的方法
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">stefno</span>.<span style="color:#a6e22e">howOld</span>())

  <span style="color:#75715e">// 指针类型 调用接收者也是指针类型的方法
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">stefno</span>.<span style="color:#a6e22e">growUp</span>()
  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">stefno</span>.<span style="color:#a6e22e">howOld</span>())
}
</code></pre></div><table>
<thead>
<tr>
<th>-</th>
<th>值接收者</th>
<th>指针接收者</th>
</tr>
</thead>
<tbody>
<tr>
<td>值类型调用者</td>
<td>方法会使用调用者的一个副本，类似于&quot;传值&quot;</td>
<td>使用值的引用来调用方法, 上例中 qcrao.growUp() 实际上是 (&amp;qcrao).growUp()</td>
</tr>
<tr>
<td>指针类型调用者</td>
<td>指针被解引用为值, 上例中, stefno.howOld() 实际上是 (*stefno).howOld()</td>
<td>实际上也是&quot;传值&quot;, 方法里的操作会影响到调用者, 类似于指针传参, 拷贝了一份指针</td>
</tr>
</tbody>
</table>
<h3 id="区别">区别<a hidden class="anchor" aria-hidden="true" href="#区别">#</a></h3>
<p>如果方法的接收者是值类型, 无论调用者是对象还是对象指针, 修改的都是对象的副本, 不影响调用者; 如果方法的接收者是指针类型, 则调用者修改的是指针指向的对象本身.</p>
<p>使用值接收者还是指针接收者, 不是由该方法是否修改了调用者 (也就是接收者) 来决定, 而是应该基于该类型的本质.</p>
<ul>
<li>如果类型具备&quot;原始的本质&quot;, 也就是说它的成员都是由 Go 语言里内置的原始类型, 如字符串, 整型值等, 那就定义值接收者类型的方法.
像内置的引用类型, 如 slice, map, interface, channel, 这些类型比较特殊, 声明他们的时候, 实际上是创建了一个 header, 对于他们也是直接定义值接收者类型的方法.
这样, 调用函数时, 是直接 copy 了这些类型的 header, 而 header 本身就是为复制设计的.</li>
<li>如果类型具备非原始的本质, 不能被安全地复制, 这种类型总是应该被共享, 那就定义指针接收者的方法.
比如 go 源码里的文件结构体 (struct File) 就不应该被复制, 应该只有一份实体.</li>
</ul>
<h2 id="iface-和-eface-的区别">iface 和 eface 的区别<a hidden class="anchor" aria-hidden="true" href="#iface-和-eface-的区别">#</a></h2>
<p>iface 和 eface 都是 Go 中描述接口的底层结构体, 区别在于 iface 描述的接口包含方法, 而 eface 则是不包含任何方法的空接口: interface{}.</p>
<h3 id="iface">iface<a hidden class="anchor" aria-hidden="true" href="#iface">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;unsafe&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">iface</span> <span style="color:#66d9ef">struct</span> {
  <span style="color:#a6e22e">tab</span>  <span style="color:#f92672">*</span><span style="color:#a6e22e">itab</span>          <span style="color:#75715e">// 接口类型以及实际类型
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">data</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span> <span style="color:#75715e">// 接口具体的值, 一般而言是一个指向堆内存的指针
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">itab</span> <span style="color:#66d9ef">struct</span> {
  <span style="color:#a6e22e">inter</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">interfacetype</span>
  <span style="color:#a6e22e">_type</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">_type</span>
  <span style="color:#a6e22e">hash</span>  <span style="color:#66d9ef">uint32</span> <span style="color:#75715e">// copy of _type.hash. Used for type switches.
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">_</span>     [<span style="color:#ae81ff">4</span>]<span style="color:#66d9ef">byte</span>
  <span style="color:#a6e22e">fun</span>   [<span style="color:#ae81ff">1</span>]<span style="color:#66d9ef">uintptr</span> <span style="color:#75715e">// variable sized. 存储的是第一个方法的函数指针，如果有更多的方法，在它之后的内存空间里继续存储.
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">interfacetype</span> <span style="color:#66d9ef">struct</span> {
  <span style="color:#a6e22e">typ</span>     <span style="color:#a6e22e">_type</span>
  <span style="color:#a6e22e">pkgpath</span> <span style="color:#a6e22e">name</span>
  <span style="color:#a6e22e">mhdr</span>    []<span style="color:#a6e22e">imethod</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">_type</span> <span style="color:#66d9ef">struct</span> {
  <span style="color:#75715e">// 类型大小
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">size</span>    <span style="color:#66d9ef">uintptr</span>
  <span style="color:#a6e22e">ptrdata</span> <span style="color:#66d9ef">uintptr</span>
  <span style="color:#75715e">// 类型的 hash 值
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">hash</span> <span style="color:#66d9ef">uint32</span>
  <span style="color:#75715e">// 类型的 flag，和反射相关
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">tflag</span> <span style="color:#a6e22e">tflag</span>
  <span style="color:#75715e">// 内存对齐相关
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">align</span>      <span style="color:#66d9ef">uint8</span>
  <span style="color:#a6e22e">fieldalign</span> <span style="color:#66d9ef">uint8</span>
  <span style="color:#75715e">// 类型的编号，有bool, slice, struct 等等等等
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">kind</span>  <span style="color:#66d9ef">uint8</span>
  <span style="color:#a6e22e">equal</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>, <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>) <span style="color:#66d9ef">bool</span>
  <span style="color:#75715e">// gc 相关
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">gcdata</span>    <span style="color:#f92672">*</span><span style="color:#66d9ef">byte</span>
  <span style="color:#a6e22e">str</span>       <span style="color:#a6e22e">nameOff</span>
  <span style="color:#a6e22e">ptrToThis</span> <span style="color:#a6e22e">typeOff</span>
}
</code></pre></div><figure>
    <img loading="lazy" src="/ox-hugo/2020-07-09_11-05-26_56564826-82527600-65e1-11e9-956d-d98a212bc863.png" width="400px"/> 
</figure>

<h3 id="eface">eface<a hidden class="anchor" aria-hidden="true" href="#eface">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">eface</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">_type</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">_type</span>
    <span style="color:#a6e22e">data</span>  <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>
}
</code></pre></div><h3 id="type">_type<a hidden class="anchor" aria-hidden="true" href="#type">#</a></h3>
<p>_type 是描述 Go 语言中各种数据类型的结构体</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">_type</span> <span style="color:#66d9ef">struct</span> {
  <span style="color:#75715e">// 类型大小
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">size</span>    <span style="color:#66d9ef">uintptr</span>
  <span style="color:#a6e22e">ptrdata</span> <span style="color:#66d9ef">uintptr</span>
  <span style="color:#75715e">// 类型的 hash 值
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">hash</span> <span style="color:#66d9ef">uint32</span>
  <span style="color:#75715e">// 类型的 flag，和反射相关
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">tflag</span> <span style="color:#a6e22e">tflag</span>
  <span style="color:#75715e">// 内存对齐相关
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">align</span>      <span style="color:#66d9ef">uint8</span>
  <span style="color:#a6e22e">fieldalign</span> <span style="color:#66d9ef">uint8</span>
  <span style="color:#75715e">// 类型的编号，有bool, slice, struct 等等等等
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">kind</span>  <span style="color:#66d9ef">uint8</span>
  <span style="color:#a6e22e">equal</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>, <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>) <span style="color:#66d9ef">bool</span>
  <span style="color:#75715e">// gc 相关
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">gcdata</span>    <span style="color:#f92672">*</span><span style="color:#66d9ef">byte</span>
  <span style="color:#a6e22e">str</span>       <span style="color:#a6e22e">nameOff</span>
  <span style="color:#a6e22e">ptrToThis</span> <span style="color:#a6e22e">typeOff</span>
}
</code></pre></div><p>Go 语言各种数据类型都是在 _type 字段的基础上, 增加一些额外的字段来进行管理的:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">arraytype</span> <span style="color:#66d9ef">struct</span> {
  <span style="color:#a6e22e">typ</span>   <span style="color:#a6e22e">_type</span>
  <span style="color:#a6e22e">elem</span>  <span style="color:#f92672">*</span><span style="color:#a6e22e">_type</span>
  <span style="color:#a6e22e">slice</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">_type</span>
  <span style="color:#a6e22e">len</span>   <span style="color:#66d9ef">uintptr</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">chantype</span> <span style="color:#66d9ef">struct</span> {
  <span style="color:#a6e22e">typ</span>  <span style="color:#a6e22e">_type</span>
  <span style="color:#a6e22e">elem</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">_type</span>
  <span style="color:#a6e22e">dir</span>  <span style="color:#66d9ef">uintptr</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">slicetype</span> <span style="color:#66d9ef">struct</span> {
  <span style="color:#a6e22e">typ</span>  <span style="color:#a6e22e">_type</span>
  <span style="color:#a6e22e">elem</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">_type</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">functype</span> <span style="color:#66d9ef">struct</span> {
  <span style="color:#a6e22e">typ</span>      <span style="color:#a6e22e">_type</span>
  <span style="color:#a6e22e">inCount</span>  <span style="color:#66d9ef">uint16</span>
  <span style="color:#a6e22e">outCount</span> <span style="color:#66d9ef">uint16</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ptrtype</span> <span style="color:#66d9ef">struct</span> {
  <span style="color:#a6e22e">typ</span>  <span style="color:#a6e22e">_type</span>
  <span style="color:#a6e22e">elem</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">_type</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">structfield</span> <span style="color:#66d9ef">struct</span> {
  <span style="color:#a6e22e">name</span>       <span style="color:#a6e22e">name</span>
  <span style="color:#a6e22e">typ</span>        <span style="color:#f92672">*</span><span style="color:#a6e22e">_type</span>
  <span style="color:#a6e22e">offsetAnon</span> <span style="color:#66d9ef">uintptr</span>
}
</code></pre></div><p>这些数据类型的结构体定义, 是反射实现的基础.</p>
<h2 id="接口的动态类型和动态值">接口的动态类型和动态值<a hidden class="anchor" aria-hidden="true" href="#接口的动态类型和动态值">#</a></h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;unsafe&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">iface</span> <span style="color:#66d9ef">struct</span> {
  <span style="color:#a6e22e">tab</span>  <span style="color:#f92672">*</span><span style="color:#a6e22e">itab</span>          <span style="color:#75715e">// 接口类型以及实际类型
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">data</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span> <span style="color:#75715e">// 接口具体的值, 一般而言是一个指向堆内存的指针
</span><span style="color:#75715e"></span>}
</code></pre></div><p>iface 类型包含两个字段:</p>
<ul>
<li>tab: 是接口表指针，指向类型信息</li>
<li>data: 是数据指针，则指向具体的数据</li>
</ul>
<h3 id="接口类型和-nil-作比较">接口类型和 nil 作比较<a hidden class="anchor" aria-hidden="true" href="#接口类型和-nil-作比较">#</a></h3>
<p>接口值的零值是指动态类型和动态值都为 nil, 这个接口才能被认为 <strong>接口值 == nil</strong>.</p>
<ol>
<li>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">interface</span>{}
  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>) <span style="color:#75715e">// true
</span><span style="color:#75715e"></span>
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">b</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">string</span>
  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">b</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>) <span style="color:#75715e">// true
</span><span style="color:#75715e"></span>
  <span style="color:#a6e22e">a</span> = <span style="color:#a6e22e">b</span>
  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>) <span style="color:#75715e">// false
</span><span style="color:#75715e"></span>}
</code></pre></div><p>b 赋值给 a 后, a 的动态类型为 *string , 动态值为 nil , 所以 a == nil 为 false .</p>
</li>
<li>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MyError</span> <span style="color:#66d9ef">string</span>

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">i</span> <span style="color:#a6e22e">MyError</span>) <span style="color:#a6e22e">Error</span>() <span style="color:#66d9ef">string</span> {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">i</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">HandleError</span>()

  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">err</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span>) <span style="color:#75715e">// false
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">HandleError</span>() <span style="color:#66d9ef">error</span> {
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">MyError</span> = <span style="color:#66d9ef">nil</span>
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span>
}
</code></pre></div><p>调用 HandleError 返回 error 接口类型, 动态类型为 *MyError , 动态值为 nil .</p>
</li>
</ol>
<h4 id="打印接口的动态值和类型">打印接口的动态值和类型<a hidden class="anchor" aria-hidden="true" href="#打印接口的动态值和类型">#</a></h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;unsafe&#34;</span>
    <span style="color:#e6db74">&#34;fmt&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">iface</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">itab</span>, <span style="color:#a6e22e">data</span> <span style="color:#66d9ef">uintptr</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">interface</span>{} = <span style="color:#66d9ef">nil</span>

    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">interface</span>{} = (<span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>)(<span style="color:#66d9ef">nil</span>)

    <span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">5</span>
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">c</span> <span style="color:#66d9ef">interface</span>{} = (<span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>)(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">x</span>)

    <span style="color:#a6e22e">ia</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">iface</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">a</span>))
    <span style="color:#a6e22e">ib</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">iface</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">b</span>))
    <span style="color:#a6e22e">ic</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">iface</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">c</span>))

  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">ia</span>) <span style="color:#75715e">// {0 0}
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">ib</span>) <span style="color:#75715e">// {17426912 0}
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">ic</span>) <span style="color:#75715e">// {17426912 842350714568}
</span><span style="color:#75715e"></span>
  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">*</span>(<span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">ic</span>.<span style="color:#a6e22e">data</span>))) <span style="color:#75715e">// 5
</span><span style="color:#75715e"></span>}
</code></pre></div><ul>
<li>a 的动态类型和动态值的地址均为 0, 也就是 nil;</li>
<li>b 的动态类型和 c 的动态类型一致, 都是 *int;</li>
<li>c 的动态值为 5.</li>
</ul>
<h3 id="编译器自动检测类型是否实现接口">编译器自动检测类型是否实现接口<a hidden class="anchor" aria-hidden="true" href="#编译器自动检测类型是否实现接口">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">_</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Writer</span> = (<span style="color:#f92672">*</span><span style="color:#a6e22e">myWriter</span>)(<span style="color:#66d9ef">nil</span>)
</code></pre></div><p>编译器会由此检查 *myWriter 类型是否实现了 io.Writer 接口.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;io&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">myWriter</span> <span style="color:#66d9ef">string</span>

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">w</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">myWriter</span>) <span style="color:#a6e22e">Write</span>(<span style="color:#a6e22e">p</span> []<span style="color:#66d9ef">byte</span>) (<span style="color:#a6e22e">n</span> <span style="color:#66d9ef">int</span>, <span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>) {
  <span style="color:#66d9ef">return</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#75715e">// 检查 *myWriter 类型是否实现了 io.Writer 接口
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">_</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Writer</span> = (<span style="color:#f92672">*</span><span style="color:#a6e22e">myWriter</span>)(<span style="color:#66d9ef">nil</span>)

  <span style="color:#75715e">// 检查 myWriter 类型是否实现了 io.Writer 接口
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">_</span> <span style="color:#a6e22e">io</span>.<span style="color:#a6e22e">Writer</span> = <span style="color:#a6e22e">myWriter</span>{}
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">src/main.go:15:6: cannot use myWriter literal <span style="color:#f92672">(</span>type myWriter<span style="color:#f92672">)</span> as type io.Writer in assignment:
    myWriter does not implement io.Writer <span style="color:#f92672">(</span>missing Write method<span style="color:#f92672">)</span>
</code></pre></div><p>myWriter 没用实现 io.Writer</p>
<h2 id="接口类型的赋值--构造--和断言">接口类型的赋值 (构造) 和断言<a hidden class="anchor" aria-hidden="true" href="#接口类型的赋值--构造--和断言">#</a></h2>
<h3 id="赋值">赋值<a hidden class="anchor" aria-hidden="true" href="#赋值">#</a></h3>
<p>针对不同类型有以下函数:</p>
<blockquote>
<p>convT2E16, convT2I16
convT2E32, convT2I32
convT2E64, convT2I64
convT2Estring, convT2Istring
convT2Eslice, convT2Islice
convT2Enoptr, convT2Inoptr</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">convT2I</span>(<span style="color:#a6e22e">tab</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">itab</span>, <span style="color:#a6e22e">elem</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>) (<span style="color:#a6e22e">i</span> <span style="color:#a6e22e">iface</span>) {
  <span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">tab</span>.<span style="color:#a6e22e">_type</span>
  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">raceenabled</span> {
    <span style="color:#a6e22e">raceReadObjectPC</span>(<span style="color:#a6e22e">t</span>, <span style="color:#a6e22e">elem</span>, <span style="color:#a6e22e">getcallerpc</span>(), <span style="color:#a6e22e">funcPC</span>(<span style="color:#a6e22e">convT2I</span>))
  }
  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">msanenabled</span> {
    <span style="color:#a6e22e">msanread</span>(<span style="color:#a6e22e">elem</span>, <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">size</span>)
  }
  <span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">mallocgc</span>(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">size</span>, <span style="color:#a6e22e">t</span>, <span style="color:#66d9ef">true</span>)
  <span style="color:#a6e22e">typedmemmove</span>(<span style="color:#a6e22e">t</span>, <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">elem</span>)
  <span style="color:#a6e22e">i</span>.<span style="color:#a6e22e">tab</span> = <span style="color:#a6e22e">tab</span>
  <span style="color:#a6e22e">i</span>.<span style="color:#a6e22e">data</span> = <span style="color:#a6e22e">x</span>
  <span style="color:#66d9ef">return</span>
}
</code></pre></div><p>把 tab 赋给了 iface 的 tab 字段; data 部分则是在堆上申请了一块内存, 然后将 elem 指向的数据拷贝过去.</p>
<h3 id="断言">断言<a hidden class="anchor" aria-hidden="true" href="#断言">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">assertI2I</span>(<span style="color:#a6e22e">inter</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">interfacetype</span>, <span style="color:#a6e22e">i</span> <span style="color:#a6e22e">iface</span>) (<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">iface</span>) {
  <span style="color:#a6e22e">tab</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span>.<span style="color:#a6e22e">tab</span>
  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">tab</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
    <span style="color:#75715e">// explicit conversions require non-nil interface value.
</span><span style="color:#75715e"></span>    panic(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">TypeAssertionError</span>{<span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">nil</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">inter</span>.<span style="color:#a6e22e">typ</span>, <span style="color:#e6db74">&#34;&#34;</span>})
  }
  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">tab</span>.<span style="color:#a6e22e">inter</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">inter</span> {
    <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">tab</span> = <span style="color:#a6e22e">tab</span>
    <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">data</span> = <span style="color:#a6e22e">i</span>.<span style="color:#a6e22e">data</span>
    <span style="color:#66d9ef">return</span>
  }
  <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">tab</span> = <span style="color:#a6e22e">getitab</span>(<span style="color:#a6e22e">inter</span>, <span style="color:#a6e22e">tab</span>.<span style="color:#a6e22e">_type</span>, <span style="color:#66d9ef">false</span>)
  <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">data</span> = <span style="color:#a6e22e">i</span>.<span style="color:#a6e22e">data</span>
  <span style="color:#66d9ef">return</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">assertI2I2</span>(<span style="color:#a6e22e">inter</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">interfacetype</span>, <span style="color:#a6e22e">i</span> <span style="color:#a6e22e">iface</span>) (<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">iface</span>, <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">bool</span>) {
  <span style="color:#a6e22e">tab</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span>.<span style="color:#a6e22e">tab</span>
  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">tab</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
    <span style="color:#66d9ef">return</span>
  }
  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">tab</span>.<span style="color:#a6e22e">inter</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">inter</span> {
    <span style="color:#a6e22e">tab</span> = <span style="color:#a6e22e">getitab</span>(<span style="color:#a6e22e">inter</span>, <span style="color:#a6e22e">tab</span>.<span style="color:#a6e22e">_type</span>, <span style="color:#66d9ef">true</span>)
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">tab</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
      <span style="color:#66d9ef">return</span>
    }
  }
  <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">tab</span> = <span style="color:#a6e22e">tab</span>
  <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">data</span> = <span style="color:#a6e22e">i</span>.<span style="color:#a6e22e">data</span>
  <span style="color:#a6e22e">b</span> = <span style="color:#66d9ef">true</span>
  <span style="color:#66d9ef">return</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">assertE2I</span>(<span style="color:#a6e22e">inter</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">interfacetype</span>, <span style="color:#a6e22e">e</span> <span style="color:#a6e22e">eface</span>) (<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">iface</span>) {
  <span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">_type</span>
  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">t</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
    <span style="color:#75715e">// explicit conversions require non-nil interface value.
</span><span style="color:#75715e"></span>    panic(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">TypeAssertionError</span>{<span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">nil</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">inter</span>.<span style="color:#a6e22e">typ</span>, <span style="color:#e6db74">&#34;&#34;</span>})
  }
  <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">tab</span> = <span style="color:#a6e22e">getitab</span>(<span style="color:#a6e22e">inter</span>, <span style="color:#a6e22e">t</span>, <span style="color:#66d9ef">false</span>)
  <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">data</span> = <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">data</span>
  <span style="color:#66d9ef">return</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">assertE2I2</span>(<span style="color:#a6e22e">inter</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">interfacetype</span>, <span style="color:#a6e22e">e</span> <span style="color:#a6e22e">eface</span>) (<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">iface</span>, <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">bool</span>) {
  <span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">_type</span>
  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">t</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
    <span style="color:#66d9ef">return</span>
  }
  <span style="color:#a6e22e">tab</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">getitab</span>(<span style="color:#a6e22e">inter</span>, <span style="color:#a6e22e">t</span>, <span style="color:#66d9ef">true</span>)
  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">tab</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
    <span style="color:#66d9ef">return</span>
  }
  <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">tab</span> = <span style="color:#a6e22e">tab</span>
  <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">data</span> = <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">data</span>
  <span style="color:#a6e22e">b</span> = <span style="color:#66d9ef">true</span>
  <span style="color:#66d9ef">return</span>
}
</code></pre></div><p>判断需断言的变量 (iface) 是否满足接口类型 (interfacetype).</p>
<p>assertI2I 对应 接口断言返回一个参数:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
  <span style="color:#e6db74">&#34;errors&#34;</span>
  <span style="color:#e6db74">&#34;fmt&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(<span style="color:#a6e22e">args</span>) {
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">interface</span>{} = <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">New</span>(<span style="color:#e6db74">&#34;error&#34;</span>)

  <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">a</span>.(<span style="color:#66d9ef">error</span>)
  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">err</span>.<span style="color:#a6e22e">Error</span>())
}
</code></pre></div><p>assertI2I2 则对应返回两个参数的情况:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
  <span style="color:#e6db74">&#34;errors&#34;</span>
  <span style="color:#e6db74">&#34;fmt&#34;</span>
)

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>(<span style="color:#a6e22e">args</span>) {
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">interface</span>{} = <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">New</span>(<span style="color:#e6db74">&#34;error&#34;</span>)

  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">a</span>.(<span style="color:#66d9ef">error</span>); <span style="color:#a6e22e">ok</span> {
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">err</span>.<span style="color:#a6e22e">Error</span>())
  }
}
</code></pre></div><p>都在编译阶段编译器判断.</p>
<h3 id="打印接口类型的hash值">打印接口类型的hash值<a hidden class="anchor" aria-hidden="true" href="#打印接口类型的hash值">#</a></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> (
  <span style="color:#e6db74">&#34;fmt&#34;</span>
  <span style="color:#e6db74">&#34;unsafe&#34;</span>
)

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">iface</span> <span style="color:#66d9ef">struct</span> {
  <span style="color:#a6e22e">tab</span>  <span style="color:#f92672">*</span><span style="color:#a6e22e">itab</span>
  <span style="color:#a6e22e">data</span> <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">itab</span> <span style="color:#66d9ef">struct</span> {
  <span style="color:#a6e22e">inter</span> <span style="color:#66d9ef">uintptr</span>
  <span style="color:#a6e22e">_type</span> <span style="color:#66d9ef">uintptr</span>
  <span style="color:#a6e22e">hash</span>  <span style="color:#66d9ef">uint32</span>
  <span style="color:#a6e22e">_</span>     [<span style="color:#ae81ff">4</span>]<span style="color:#66d9ef">byte</span>
  <span style="color:#a6e22e">fun</span>   [<span style="color:#ae81ff">1</span>]<span style="color:#66d9ef">uintptr</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Person</span>(<span style="color:#a6e22e">Student</span>{<span style="color:#a6e22e">age</span>: <span style="color:#ae81ff">18</span>})

  <span style="color:#a6e22e">iface</span> <span style="color:#f92672">:=</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">iface</span>)(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">p</span>))
  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;iface.tab.hash = %#x\n&#34;</span>, <span style="color:#a6e22e">iface</span>.<span style="color:#a6e22e">tab</span>.<span style="color:#a6e22e">hash</span>) <span style="color:#75715e">// iface.tab.hash = 0xd4209fda
</span><span style="color:#75715e"></span>}
</code></pre></div><h2 id="类型转换和断言的区别">类型转换和断言的区别<a hidden class="anchor" aria-hidden="true" href="#类型转换和断言的区别">#</a></h2>
<h3 id="类型转换">类型转换<a hidden class="anchor" aria-hidden="true" href="#类型转换">#</a></h3>
<p>Go 语言中不允许隐式类型转换, 也就是说 = 两边, 不允许出现类型不相同的变量.
类型转换前后的两个类型必须相互兼容.</p>
<blockquote>
<p>&lt;结果类型&gt; := &lt;目标类型&gt; ( &lt;表达式&gt; )</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">int</span> = <span style="color:#ae81ff">9</span>

  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">f</span> <span style="color:#66d9ef">float64</span>
  <span style="color:#a6e22e">f</span> = float64(<span style="color:#a6e22e">i</span>)
  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%T, %v\n&#34;</span>, <span style="color:#a6e22e">f</span>, <span style="color:#a6e22e">f</span>)

  <span style="color:#a6e22e">f</span> = <span style="color:#ae81ff">10.8</span>
  <span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> int(<span style="color:#a6e22e">f</span>)
  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%T, %v\n&#34;</span>, <span style="color:#a6e22e">a</span>, <span style="color:#a6e22e">a</span>)

  <span style="color:#75715e">// s := []int(i)
</span><span style="color:#75715e"></span>}
</code></pre></div><h3 id="断言">断言<a hidden class="anchor" aria-hidden="true" href="#断言">#</a></h3>
<p>空接口 interface{} 没有定义任何函数, 因此 Go 中所有类型都实现了空接口.
当一个函数的形参是 interface{}, 那么在函数中, 需要对形参进行断言, 从而得到它的真实类型.</p>
<blockquote>
<p>&lt;目标类型的值&gt;，&lt;布尔参数&gt; := &lt;表达式&gt;.( 目标类型 ) // 安全类型断言
&lt;目标类型的值&gt; := &lt;表达式&gt;.( 目标类型 )　　        //非安全类型断言</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Student</span> <span style="color:#66d9ef">struct</span> {
  <span style="color:#a6e22e">Name</span> <span style="color:#66d9ef">string</span>
  <span style="color:#a6e22e">Age</span>  <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">interface</span>{} = new(<span style="color:#a6e22e">Student</span>)
  <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">Student</span>)

  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)
}
</code></pre></div><p>switch 形式断言</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Student</span> <span style="color:#66d9ef">struct</span> {
  <span style="color:#a6e22e">Name</span> <span style="color:#66d9ef">string</span>
  <span style="color:#a6e22e">Age</span>  <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">i</span> <span style="color:#66d9ef">interface</span>{}


  <span style="color:#a6e22e">judge</span>(<span style="color:#a6e22e">i</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">judge</span>(<span style="color:#a6e22e">v</span> <span style="color:#66d9ef">interface</span>{}) {
  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%p %v\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">v</span>)

  <span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">v</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">v</span>.(<span style="color:#66d9ef">type</span>) {
  <span style="color:#66d9ef">case</span> <span style="color:#66d9ef">nil</span>:
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%p %v\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">v</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;nil type[%T] %v\n&#34;</span>, <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">v</span>)

  <span style="color:#66d9ef">case</span> <span style="color:#a6e22e">Student</span>:
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%p %v\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">v</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;Student type[%T] %v\n&#34;</span>, <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">v</span>)

  <span style="color:#66d9ef">case</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Student</span>:
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%p %v\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">v</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;*Student type[%T] %v\n&#34;</span>, <span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">v</span>)

  <span style="color:#66d9ef">default</span>:
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;%p %v\n&#34;</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">v</span>, <span style="color:#a6e22e">v</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;unknow\n&#34;</span>)
  }
}

</code></pre></div><h3 id="fmt-dot-println-函数">fmt.Println 函数<a hidden class="anchor" aria-hidden="true" href="#fmt-dot-println-函数">#</a></h3>
<p>fmt.Println 函数的参数是 interface{}. 对于内置类型, 函数内部会用穷举法, 得出它的真实类型, 然后转换为字符串打印.
而对于自定义类型, 首先确定该类型是否实现了 String() 方法. 如果实现了, 则直接打印输出 String() 方法的结果; 否则, 会通过反射来遍历对象的成员进行打印.</p>
<p>因为 Student 结构体没有实现 String() 方法, 所以 fmt.Println 会利用反射挨个打印成员变量:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Student</span> <span style="color:#66d9ef">struct</span> {
  <span style="color:#a6e22e">Name</span> <span style="color:#66d9ef">string</span>
  <span style="color:#a6e22e">Age</span>  <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Student</span>{
    <span style="color:#a6e22e">Name</span>: <span style="color:#e6db74">&#34;zzz&#34;</span>,
    <span style="color:#a6e22e">Age</span>:  <span style="color:#ae81ff">18</span>,
  }

  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>) <span style="color:#75715e">// {zzz 18}
</span><span style="color:#75715e"></span>}
</code></pre></div><p>增加一个 String() 方法的实现:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#a6e22e">Student</span>) <span style="color:#a6e22e">String</span>() <span style="color:#66d9ef">string</span> {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;[Name: %s], [Age: %d]&#34;</span>, <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">Name</span>, <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">Age</span>) <span style="color:#75715e">// [Name: zzz], [Age: 18]
</span><span style="color:#75715e"></span>}
</code></pre></div><p>修改 String() 方法:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">s</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Student</span>) <span style="color:#a6e22e">String</span>() <span style="color:#66d9ef">string</span> {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;[Name: %s], [Age: %d]&#34;</span>, <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">Name</span>, <span style="color:#a6e22e">s</span>.<span style="color:#a6e22e">Age</span>) <span style="color:#75715e">// {zzz 18}
</span><span style="color:#75715e"></span>}
</code></pre></div><p>打印结果并没用调用 String() ,因为:</p>
<blockquote>
<p>类型 T 只有接受者是 T 的方法; 而类型 *T 拥有接受者是 T 和 *T 的方法. 语法上 T 能直接调 *T 的方法仅仅是 Go 的语法糖.</p>
</blockquote>
<p>要调用 String() 需要:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>)
</code></pre></div><h2 id="接口转换的原理">接口转换的原理<a hidden class="anchor" aria-hidden="true" href="#接口转换的原理">#</a></h2>
<p>类型有 m 个方法, 某接口有 n 个方法, 则很容易知道这种判定的时间复杂度为 O(mn); Go 会对方法集的函数按照函数名的字典序进行排序, 所以实际的时间复杂度为 O(m+n).</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">coder</span> <span style="color:#66d9ef">interface</span> {
  <span style="color:#a6e22e">code</span>()
  <span style="color:#a6e22e">run</span>()
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">runner</span> <span style="color:#66d9ef">interface</span> {
  <span style="color:#a6e22e">run</span>()
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Gopher</span> <span style="color:#66d9ef">struct</span> {
  <span style="color:#a6e22e">language</span> <span style="color:#66d9ef">string</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#a6e22e">Gopher</span>) <span style="color:#a6e22e">code</span>() {
  <span style="color:#66d9ef">return</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">g</span> <span style="color:#a6e22e">Gopher</span>) <span style="color:#a6e22e">run</span>() {
  <span style="color:#66d9ef">return</span>
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">c</span> <span style="color:#a6e22e">coder</span> = <span style="color:#a6e22e">Gopher</span>{}

  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">r</span> <span style="color:#a6e22e">runner</span>
  <span style="color:#a6e22e">r</span> = <span style="color:#a6e22e">c</span>
  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c</span>, <span style="color:#a6e22e">r</span>)
}
</code></pre></div><p>Gopher 类型同时满足 coder 接口和 runner 接口.</p>
<p>convI2I 函数将一个 interface 转换成 另一个 interface .</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">convI2I</span>(<span style="color:#a6e22e">inter</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">interfacetype</span>, <span style="color:#a6e22e">i</span> <span style="color:#a6e22e">iface</span>) (<span style="color:#a6e22e">r</span> <span style="color:#a6e22e">iface</span>) {
  <span style="color:#a6e22e">tab</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">i</span>.<span style="color:#a6e22e">tab</span>
  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">tab</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
    <span style="color:#66d9ef">return</span>
  }
  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">tab</span>.<span style="color:#a6e22e">inter</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">inter</span> {
    <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">tab</span> = <span style="color:#a6e22e">tab</span>
    <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">data</span> = <span style="color:#a6e22e">i</span>.<span style="color:#a6e22e">data</span>
    <span style="color:#66d9ef">return</span>
  }
  <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">tab</span> = <span style="color:#a6e22e">getitab</span>(<span style="color:#a6e22e">inter</span>, <span style="color:#a6e22e">tab</span>.<span style="color:#a6e22e">_type</span>, <span style="color:#66d9ef">false</span>)
  <span style="color:#a6e22e">r</span>.<span style="color:#a6e22e">data</span> = <span style="color:#a6e22e">i</span>.<span style="color:#a6e22e">data</span>
  <span style="color:#66d9ef">return</span>
}
</code></pre></div><p>inter 表示要转成的接口类型, i 表示一个实体类型.
如果要转换的接口类型和实体类型的接口类型相同就直接返回; 否则就用调用 getitab 函数去匹配满转方法集的接口.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;unsafe&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">getitab</span>(<span style="color:#a6e22e">inter</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">interfacetype</span>, <span style="color:#a6e22e">typ</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">_type</span>, <span style="color:#a6e22e">canfail</span> <span style="color:#66d9ef">bool</span>) <span style="color:#f92672">*</span><span style="color:#a6e22e">itab</span> {
  <span style="color:#66d9ef">if</span> len(<span style="color:#a6e22e">inter</span>.<span style="color:#a6e22e">mhdr</span>) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
    <span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;internal error - misuse of itab&#34;</span>)
  }

  <span style="color:#75715e">// easy case
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">typ</span>.<span style="color:#a6e22e">tflag</span><span style="color:#f92672">&amp;</span><span style="color:#a6e22e">tflagUncommon</span> <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> {
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">canfail</span> {
      <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
    }
    <span style="color:#a6e22e">name</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">inter</span>.<span style="color:#a6e22e">typ</span>.<span style="color:#a6e22e">nameOff</span>(<span style="color:#a6e22e">inter</span>.<span style="color:#a6e22e">mhdr</span>[<span style="color:#ae81ff">0</span>].<span style="color:#a6e22e">name</span>)
    panic(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">TypeAssertionError</span>{<span style="color:#66d9ef">nil</span>, <span style="color:#a6e22e">typ</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">inter</span>.<span style="color:#a6e22e">typ</span>, <span style="color:#a6e22e">name</span>.<span style="color:#a6e22e">name</span>()})
  }

  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">itab</span>

  <span style="color:#75715e">// First, look in the existing table to see if we can find the itab we need.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// This is by far the most common case, so do it without locks.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Use atomic to ensure we see any previous writes done by the thread
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// that updates the itabTable field (with atomic.Storep in itabAdd).
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">itabTableType</span>)(<span style="color:#a6e22e">atomic</span>.<span style="color:#a6e22e">Loadp</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">itabTable</span>)))
  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">m</span> = <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">find</span>(<span style="color:#a6e22e">inter</span>, <span style="color:#a6e22e">typ</span>); <span style="color:#a6e22e">m</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
    <span style="color:#66d9ef">goto</span> <span style="color:#a6e22e">finish</span>
  }

  <span style="color:#75715e">// Not found.  Grab the lock and try again.
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">lock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">itabLock</span>)
  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">m</span> = <span style="color:#a6e22e">itabTable</span>.<span style="color:#a6e22e">find</span>(<span style="color:#a6e22e">inter</span>, <span style="color:#a6e22e">typ</span>); <span style="color:#a6e22e">m</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
    <span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">itabLock</span>)
    <span style="color:#66d9ef">goto</span> <span style="color:#a6e22e">finish</span>
  }

  <span style="color:#75715e">// Entry doesn&#39;t exist yet. Make a new entry &amp; add it.
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">m</span> = (<span style="color:#f92672">*</span><span style="color:#a6e22e">itab</span>)(<span style="color:#a6e22e">persistentalloc</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Sizeof</span>(<span style="color:#a6e22e">itab</span>{})<span style="color:#f92672">+</span>uintptr(len(<span style="color:#a6e22e">inter</span>.<span style="color:#a6e22e">mhdr</span>)<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)<span style="color:#f92672">*</span><span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">PtrSize</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">memstats</span>.<span style="color:#a6e22e">other_sys</span>))
  <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">inter</span> = <span style="color:#a6e22e">inter</span>
  <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">_type</span> = <span style="color:#a6e22e">typ</span>
  <span style="color:#75715e">// The hash is used in type switches. However, compiler statically generates itab&#39;s
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// for all interface/type pairs used in switches (which are added to itabTable
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// in itabsinit). The dynamically-generated itab&#39;s never participate in type switches,
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// and thus the hash is irrelevant.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Note: m.hash is _not_ the hash used for the runtime itabTable hash table.
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">hash</span> = <span style="color:#ae81ff">0</span>
  <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">init</span>()
  <span style="color:#a6e22e">itabAdd</span>(<span style="color:#a6e22e">m</span>)
  <span style="color:#a6e22e">unlock</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">itabLock</span>)
<span style="color:#a6e22e">finish</span>:
  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">fun</span>[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">m</span>
  }
  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">canfail</span> {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
  }
  <span style="color:#75715e">// this can only happen if the conversion
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// was already done once using the , ok form
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// and we have a cached negative result.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// The cached result doesn&#39;t record which
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// interface function was missing, so initialize
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// the itab again to get the missing function name.
</span><span style="color:#75715e"></span>  panic(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">TypeAssertionError</span>{<span style="color:#a6e22e">concrete</span>: <span style="color:#a6e22e">typ</span>, <span style="color:#a6e22e">asserted</span>: <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">inter</span>.<span style="color:#a6e22e">typ</span>, <span style="color:#a6e22e">missingMethod</span>: <span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">init</span>()})
}
</code></pre></div><p>getitab 函数会根据 interfacetype 和 _type 去全局的 itab 哈希表中查找, 如果能找到, 则直接返回; 否则, 会根据给定的 interfacetype 和 _type 新生成一个 itab, 并插入到 itab 哈希表, 这样下一次就可以直接拿到 itab.</p>
<p>这里查找了两次, 并且第二次上锁了, 这是因为如果第一次没找到, 在第二次仍然没有找到相应的 itab 的情况下, 需要新生成一个, 并且写入哈希表, 因此需要加锁.
这样, 其他协程在查找相同的 itab 并且也没有找到时, 第二次查找时, 会被挂住, 之后, 就会查到第一个协程写入哈希表的 itab.</p>
<p>itabAdd 函数会把 itab 写入到全局itabTable</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;unsafe&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">itabAdd</span>(<span style="color:#a6e22e">m</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">itab</span>) {
  <span style="color:#75715e">// Bugs can lead to calling this while mallocing is set,
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// typically because this is called while panicing.
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// Crash reliably, rather than only when we need to grow
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// the hash table.
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">getg</span>().<span style="color:#a6e22e">m</span>.<span style="color:#a6e22e">mallocing</span> <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span> {
    <span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;malloc deadlock&#34;</span>)
  }

  <span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">itabTable</span>
  <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">count</span> <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">3</span><span style="color:#f92672">*</span>(<span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">size</span><span style="color:#f92672">/</span><span style="color:#ae81ff">4</span>) { <span style="color:#75715e">// 75% load factor
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Grow hash table.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// t2 = new(itabTableType) + some additional entries
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// We lie and tell malloc we want pointer-free memory because
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// all the pointed-to values are not in the heap.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">t2</span> <span style="color:#f92672">:=</span> (<span style="color:#f92672">*</span><span style="color:#a6e22e">itabTableType</span>)(<span style="color:#a6e22e">mallocgc</span>((<span style="color:#ae81ff">2</span><span style="color:#f92672">+</span><span style="color:#ae81ff">2</span><span style="color:#f92672">*</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">size</span>)<span style="color:#f92672">*</span><span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">PtrSize</span>, <span style="color:#66d9ef">nil</span>, <span style="color:#66d9ef">true</span>))
    <span style="color:#a6e22e">t2</span>.<span style="color:#a6e22e">size</span> = <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">size</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">2</span>

    <span style="color:#75715e">// Copy over entries.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// Note: while copying, other threads may look for an itab and
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// fail to find it. That&#39;s ok, they will then try to get the itab lock
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// and as a consequence wait until this copying is complete.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">iterate_itabs</span>(<span style="color:#a6e22e">t2</span>.<span style="color:#a6e22e">add</span>)
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">t2</span>.<span style="color:#a6e22e">count</span> <span style="color:#f92672">!=</span> <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">count</span> {
      <span style="color:#a6e22e">throw</span>(<span style="color:#e6db74">&#34;mismatched count during itab table copy&#34;</span>)
    }
    <span style="color:#75715e">// Publish new hash table. Use an atomic write: see comment in getitab.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">atomicstorep</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">itabTable</span>), <span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#a6e22e">t2</span>))
    <span style="color:#75715e">// Adopt the new table as our own.
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">t</span> = <span style="color:#a6e22e">itabTable</span>
    <span style="color:#75715e">// Note: the old table can be GC&#39;ed here.
</span><span style="color:#75715e"></span>  }
  <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">m</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">iterate_itabs</span>(<span style="color:#a6e22e">fn</span> <span style="color:#66d9ef">func</span>(<span style="color:#f92672">*</span><span style="color:#a6e22e">itab</span>)) {
  <span style="color:#75715e">// Note: only runs during stop the world or with itabLock held,
</span><span style="color:#75715e"></span>  <span style="color:#75715e">// so no other locks/atomics needed.
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">t</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">itabTable</span>
  <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> uintptr(<span style="color:#ae81ff">0</span>); <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">size</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
    <span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">*</span>(<span style="color:#f92672">**</span><span style="color:#a6e22e">itab</span>)(<span style="color:#a6e22e">add</span>(<span style="color:#a6e22e">unsafe</span>.<span style="color:#a6e22e">Pointer</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">t</span>.<span style="color:#a6e22e">entries</span>), <span style="color:#a6e22e">i</span><span style="color:#f92672">*</span><span style="color:#a6e22e">sys</span>.<span style="color:#a6e22e">PtrSize</span>))
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">m</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
      <span style="color:#a6e22e">fn</span>(<span style="color:#a6e22e">m</span>)
    }
  }
}
</code></pre></div><h2 id="如何用-interface-实现多态">如何用 interface 实现多态<a hidden class="anchor" aria-hidden="true" href="#如何用-interface-实现多态">#</a></h2>
<p>多态是一种运行期的行为, 它有以下几个特点:</p>
<ol>
<li>一种类型具有多种类型的能力</li>
<li>允许不同的对象对同一消息做出灵活的反应</li>
<li>以一种通用的方式对待个使用的对象</li>
<li>非动态语言必须通过继承和接口的方式来实现</li>
</ol>
<!--listend-->
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>

<span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Student</span>{<span style="color:#a6e22e">age</span>: <span style="color:#ae81ff">18</span>}
  <span style="color:#a6e22e">whatJob</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>)

  <span style="color:#a6e22e">growUp</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">s</span>)
  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">s</span>)

  <span style="color:#a6e22e">p</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">Programmer</span>{<span style="color:#a6e22e">age</span>: <span style="color:#ae81ff">100</span>}
  <span style="color:#a6e22e">whatJob</span>(<span style="color:#a6e22e">p</span>)

  <span style="color:#a6e22e">growUp</span>(<span style="color:#a6e22e">p</span>)
  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">p</span>)
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">whatJob</span>(<span style="color:#a6e22e">p</span> <span style="color:#a6e22e">Person</span>) {
  <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">job</span>()
}

<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">growUp</span>(<span style="color:#a6e22e">p</span> <span style="color:#a6e22e">Person</span>) {
  <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">growUp</span>()
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Person</span> <span style="color:#66d9ef">interface</span> {
  <span style="color:#a6e22e">job</span>()
  <span style="color:#a6e22e">growUp</span>()
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Student</span> <span style="color:#66d9ef">struct</span> {
  <span style="color:#a6e22e">age</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#a6e22e">Student</span>) <span style="color:#a6e22e">job</span>() {
  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;I am a student.&#34;</span>)
  <span style="color:#66d9ef">return</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Student</span>) <span style="color:#a6e22e">growUp</span>() {
  <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">age</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>
  <span style="color:#66d9ef">return</span>
}

<span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Programmer</span> <span style="color:#66d9ef">struct</span> {
  <span style="color:#a6e22e">age</span> <span style="color:#66d9ef">int</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#a6e22e">Programmer</span>) <span style="color:#a6e22e">job</span>() {
  <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;I am a programmer.&#34;</span>)
  <span style="color:#66d9ef">return</span>
}

<span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">p</span> <span style="color:#a6e22e">Programmer</span>) <span style="color:#a6e22e">growUp</span>() {
  <span style="color:#a6e22e">p</span>.<span style="color:#a6e22e">age</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">10</span>
  <span style="color:#66d9ef">return</span>
}
</code></pre></div><h2 id="go-接口与-c-plus-plus-接口有何异同">Go 接口与 C++ 接口有何异同<a hidden class="anchor" aria-hidden="true" href="#go-接口与-c-plus-plus-接口有何异同">#</a></h2>
<p>接口定义了一种规范, 描述了类的行为和功能, 而不做具体实现.</p>
<p>C++ 的接口是使用抽象类来实现的, 如果类中至少有一个函数被声明为纯虚函数, 则这个类就是抽象类.
纯虚函数是通过在声明中使用 &ldquo;= 0&rdquo; 来指定的. 例如:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Shape</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  <span style="color:#75715e">// 纯虚函数
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">virtual</span> <span style="color:#66d9ef">double</span> getArea() <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
  string name; <span style="color:#75715e">// 名称
</span><span style="color:#75715e"></span>};
</code></pre></div><blockquote>
<p>设计抽象类的目的, 是为了给其他类提供一个可以继承的适当的基类. 抽象类不能被用于实例化对象, 它只能作为接口使用.
派生类需要明确地声明它继承自基类, 并且需要实现基类中所有的纯虚函数.</p>
<p>C++ 定义接口的方式称为“侵入式”, 而 Go 采用的是 “非侵入式”, 不需要显式声明, 只需要实现接口定义的函数, 编译器自动会识别.</p>
<p>C++ 和 Go 在定义接口方式上的不同, 也导致了底层实现上的不同. C++ 通过虚函数表来实现基类调用派生类的函数;
而 Go 通过 itab 中的 fun 字段来实现接口变量调用实体类型的函数. C++ 中的虚函数表是在编译期生成的; 而 Go 的 itab 中的 fun 字段是在运行期间动态生成的.
原因在于, Go 中实体类型可能会无意中实现 N 多接口, 很多接口并不是本来需要的, 所以不能为类型实现的所有接口都生成一个 itab, 这也是“非侵入式”带来的影响;
这在 C++ 中是不存在的, 因为派生需要显示声明它继承自哪个基类.</p>
</blockquote>


  </div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://dingansichKum0.github.io/tags/golang/">golang</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://dingansichKum0.github.io/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BAemoji/">
    <span class="title">« Prev Page</span>
    <br>
    <span>浏览器显示emoji</span>
  </a>
  <a class="next" href="https://dingansichKum0.github.io/posts/%E6%96%87%E5%AD%97%E8%B6%85%E5%87%BA%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7/">
    <span class="title">Next Page »</span>
    <br>
    <span>文字超出显示省略号</span>
  </a>
</nav>

<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share interface类型 on twitter"
        href="https://twitter.com/intent/tweet/?text=interface%e7%b1%bb%e5%9e%8b&amp;url=https%3a%2f%2fdingansichKum0.github.io%2fposts%2finterface%25E7%25B1%25BB%25E5%259E%258B%2f&amp;hashtags=golang">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share interface类型 on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fdingansichKum0.github.io%2fposts%2finterface%25E7%25B1%25BB%25E5%259E%258B%2f&amp;title=interface%e7%b1%bb%e5%9e%8b&amp;summary=interface%e7%b1%bb%e5%9e%8b&amp;source=https%3a%2f%2fdingansichKum0.github.io%2fposts%2finterface%25E7%25B1%25BB%25E5%259E%258B%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share interface类型 on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fdingansichKum0.github.io%2fposts%2finterface%25E7%25B1%25BB%25E5%259E%258B%2f&title=interface%e7%b1%bb%e5%9e%8b">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share interface类型 on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fdingansichKum0.github.io%2fposts%2finterface%25E7%25B1%25BB%25E5%259E%258B%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share interface类型 on whatsapp"
        href="https://api.whatsapp.com/send?text=interface%e7%b1%bb%e5%9e%8b%20-%20https%3a%2f%2fdingansichKum0.github.io%2fposts%2finterface%25E7%25B1%25BB%25E5%259E%258B%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share interface类型 on telegram"
        href="https://telegram.me/share/url?text=interface%e7%b1%bb%e5%9e%8b&amp;url=https%3a%2f%2fdingansichKum0.github.io%2fposts%2finterface%25E7%25B1%25BB%25E5%259E%258B%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main>
    <footer class="footer">
    <span>&copy; 2021 <a href="https://dingansichKum0.github.io/">谟涅摩绪涅📖</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
