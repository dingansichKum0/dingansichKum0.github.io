[{"content":"interactive 参数的含义 若一个函数带有交互模式声明，则它是一个命令函数。即可以通过 M-x(execute-command) 来调用。\n声明格式 (defun kumo-interactive-func () (interactive \u0026#34;code-string\u0026#34;) ;; do something...) 种类  Completion: 提供补全。TAB，SPC 和 RET 完成补全。 Existing: 必须是存在的对象名。不接受无效名称。如果输入无效则不会退出 minibuffer。 Default: 如果未输入则使用默认值。 No I/O: 不读取任何输入。因此不会使用提示符。 Prompt: 放在提示符或\\n之前。 Special: 只能放在交互式字符参数前。  含义   接收多个输入以 \\n 来分隔。\n  *: 如果当前buffer处于read-only-mode时提示。 [Special]\n  @: 在第一个鼠标事件触发的window调用。[Special]\n  ^: 通过 shift 调用前需要标记区域，没有公共 shift 调用则停止标记。[Special]\n  a: 一个函数定义的符号名。[Existing, Completion, Prompt]\n(defun with-func-arg (arg) (interactive \u0026#34;aEnter a function:\u0026#34;) (funcall arg))   b: buffer名（已存在）。[Existing, Completion, Default, Prompt]\n  B: buffer名（可以不存在）。[Completion, Default, Prompt]\n  c: 字符。（接收任意输入，不用回车，不能使用输入法）。[Prompt]\n  C: 一个interactive函数的符号名。即满足(commandp xx)为t。[Existing, Completion, Prompt]\n  d: 光标位置，提供 int 类型的参数。[No I/O]\n  D: 目录。[Existing, Completion, Default, Prompt]\n  e: 必须绑定一个非键盘事件。提供event的list形式参数。Input Events [No I/O]\n(defun with-not-keyboard-event-arg (arg) (interactive \u0026#34;e\u0026#34;) (print arg)) ;; ((down-mouse-1 (#\u0026lt;window 130 on a.el\u0026gt; 2845 (664 . 365) 460355375 nil 2845 (94 . 15) nil (664 . 19) (7 . 23)))) (global-set-key (kbd \u0026#34;\u0026lt;down-mouse-1\u0026gt;\u0026#34;) \u0026#39;with-not-keyboard-event-arg)   f: 文件名（已存在）。[Existing, Completion, Default, Prompt]\n  F: 文件名（可以不存在）。[Completion, Default, Prompt]\n  G: 文件名（可以不存在），如果只输入目录名不含有文件名则使用目录名。[Completion, Default, Prompt]\n  i: 总是提供nil作为参数。[No I/O]\n  k: 按键序列。一直读取知道触发按键映射的指令，或直到没定义的按键序列。提供 string 或 vector 的参数。k 只会读取down-event事件，而忽律之后的up-event(主要是指鼠标点击后松开的event)。可以使用 U code 读取up-event事件。[Prompt]\n(kbd \u0026#34;C-x\u0026#34;) ⇒ \u0026#34;\\C-x\u0026#34; (kbd \u0026#34;C-x C-f\u0026#34;) ⇒ \u0026#34;\\C-x\\C-f\u0026#34; (kbd \u0026#34;C-x 4 C-f\u0026#34;) ⇒ \u0026#34;\\C-x4\\C-f\u0026#34; (kbd \u0026#34;X\u0026#34;) ⇒ \u0026#34;X\u0026#34; (kbd \u0026#34;RET\u0026#34;) ⇒ \u0026#34;\\^M\u0026#34; (kbd \u0026#34;C-c SPC\u0026#34;) ⇒ \u0026#34;\\C-c \u0026#34; (kbd \u0026#34;\u0026lt;f1\u0026gt; SPC\u0026#34;) ⇒ [f1 32] (kbd \u0026#34;C-M-\u0026lt;down\u0026gt;\u0026#34;) ⇒ [C-M-down]   K: 和 k 类似。改变已定义的按键序列。\n  m: mark位置。提供 int 类型的参数。[No I/O]\n  M: 任意文本。使用当前 buffer 的输入法在 minibuffer 中读取，并作为 string 返回。[Prompt]\n  n: int 类型参数。如果输入的不是 int 会提示再次输入。n 之前几乎不使用前缀参数。[Prompt]\n  N: 读取数字前缀参数。如果没有前缀参数则读取一个 int 作为参数。Prefix Command Arguments [Prompt]\n  p: 数字前缀参数。也可以不用p参数，直接在代码中判断 current-prefix-arg 的值。[No I/O]\n(defun with-num-arg (arg) (interactive \u0026#34;p\u0026#34;) (print arg)) ;; 4 (numberp arg) t (defun with-expression-arg (arg) (interactive (list (prefix-numeric-value current-prefix-arg))) (print arg)) ;; 4 (numberp arg) t ;; Same as \u0026#39;with-num-arg   P: 原始前缀参数。[No I/O]\n(defun with-num-arg (arg) (interactive \u0026#34;P\u0026#34;) (print arg)) ;; (4) (lisp arg) t   r: region 的开始/结束位置。提供两个参数(beg end)，唯一提供两个参数的code。如果调用该命令时没有触发 region 则会报错[No I/O]\n  s: 任意文本。读入 minibuffer 并作为 string 返回。使用 C-j 或 RET 终止输入。[Prompt]\n  S: 在 minibuffer 中读取输入的 interned symbol 名。使用 C-j 或 RET 终止输入。[Prompt]\n  U: 一个按键序列或者 nil。可以在 k 或 K 之后使用，以获取在 k 或 K 读取down-event后被忽略的up-event(如果有。主要是指鼠标点击后松开的event)。如果没有up-event被忽略则提供 nil 参数。[No I/O]\n  v: 一个用户声明的变量。即满足(custom-variable-p)为t。[Existing, Completion, Prompt]\n  x: 一个 list。不会被 evaluated。使用C-j 或 RET 终止输入。[Prompt]\n(defun with-list-arg (arg) (interactive \u0026#34;x\u0026#34;) (print arg)) ;; M-x with-list-arg is invoked; input (+ 1 2), print \u0026#34;(+ 1 2)\u0026#34;   x: 一个 list。会被 evaluated。使用C-j 或 RET 终止输入。[Prompt]\n(defun with-list-arg (arg) (interactive \u0026#34;X\u0026#34;) (print arg)) ;; M-x with-list-arg is invoked; input (+ 1 2), print \u0026#34;3\u0026#34;   z: 一个 code system 名(symbol)。如果输入为无效 code system，则参数为 nil。 [Completion, Existing, Prompt]\n(defun save-buffer-as-utf8 (coding-system) \u0026#34;Revert a buffer with `CODING-SYSTEM\u0026#39; and save as UTF-8.\u0026#34; (interactive \u0026#34;zCoding system for visited file (default nil):\u0026#34;) (revert-buffer-with-coding-system coding-system) (set-buffer-file-coding-system \u0026#39;utf-8))   Z: 一个 code system 名(symbol)。仅当该命令有前缀参数时，否则参数为 nil。 [Completion, Existing, Prompt]\n  ","permalink":"https://rx-78-kum0.github.io/posts/elisp%E4%B8%AD%E7%9A%84interactive%E5%8F%82%E6%95%B0/","summary":"interactive 参数的含义 若一个函数带有交互模式声明，则它是一个命令函数。即可以通过 M-x(execute-command) 来调用。\n声明格式 (defun kumo-interactive-func () (interactive \u0026#34;code-string\u0026#34;) ;; do something...) 种类  Completion: 提供补全。TAB，SPC 和 RET 完成补全。 Existing: 必须是存在的对象名。不接受无效名称。如果输入无效则不会退出 minibuffer。 Default: 如果未输入则使用默认值。 No I/O: 不读取任何输入。因此不会使用提示符。 Prompt: 放在提示符或\\n之前。 Special: 只能放在交互式字符参数前。  含义   接收多个输入以 \\n 来分隔。\n  *: 如果当前buffer处于read-only-mode时提示。 [Special]\n  @: 在第一个鼠标事件触发的window调用。[Special]\n  ^: 通过 shift 调用前需要标记区域，没有公共 shift 调用则停止标记。[Special]\n  a: 一个函数定义的符号名。[Existing, Completion, Prompt]\n(defun with-func-arg (arg) (interactive \u0026#34;aEnter a function:\u0026#34;) (funcall arg))   b: buffer名（已存在）。[Existing, Completion, Default, Prompt]","title":"Elisp中的interactive参数"},{"content":"要点  会计政策的改变； 会计事务所出具 “标准无保留意见”； 上市时间长于5年； 某科目出现大比例变化，查看附注； 与同行对比；  关注的重点  财务会计报告 董事会报告 重要事项  财务会计报告    货币资金\n 货币资金余额比短期负债小很多； 货币资金充裕，却借了很多有息甚至高息负债； 定期存款很多，其他货币资金很多，流动资金却严重缺乏； 其他货币资金数额巨大，但没有合理解释；       经营相关资产\n 应收票据，银行承兑汇票\u0026gt;商业承兑汇票； 应收账款，增长幅度及坏账准备计提政策； 其他应收款，越小越好； 存货，存货和营业成本的合理比例；       生产相关资产\n 固定资产，年年折旧，折旧算费用； 在建工程，迟迟不转固定资产一般有鬼； 折旧 == 摊销； 无形资产，研发费用 = 机会+风险。房企，土地算存货而非无形资产 利润高的公司更愿意把研发支出都记入费用中，这样可以减少当期税收支出；反之计入无形资产凸显财报好看； 商誉：若一家企业的获利能力超过可辨认净资产的正常获利能力，超出的部分，一定是另外一种资产带来的，这个资产就被叫作“商誉”。没有进行过收购的企业商誉栏目为0。商誉不用摊销； 长期待摊费用，越小越好； 递延所得税资产，税务局收的税大于公司酸的应交税款； 递延所得税负债，税务局收的税小于公司算的应交税款； 企业净资产与真实相差甚远，如资产折旧或商誉价值；       投资相关资产\n 交易性金融资产，不折旧。以卖出产生利润收税；产生递延所得税资产和负债的重要源头。公允价值变动计入利润表； 持有至到期投资，按实际利率计算的投资收益，减值损失； 可供出售金融资产，汇兑损益，股利或利息，减值损失等公允价值变动加入净资产； 长期股权投资，分红影响利润，或经营盈亏影响利润； 买入返售金融资产，规避监管的抵押贷款； 投资性房地产，公允价值对利润和净资产影响巨大；       负债和所有人权益\n 负债，关注有息负债和现金及等价物及总资产比例； 股本和资本公积，面值算股本，股东投入超过面值的部分算资本公积； 盈余公积，法定或自愿留下来的用于扩大再生产的钱； 未分配利润，资金支配自由度高，有未分配利润不等于有现金可分；       资产负债表 企业所控制资源的多寡，决定了企业持续经营喝成长的能力\n 资产=负债+所有者权益； 负债率，同行业比较。有息负债不宜占总资产5成以上； 四个指标。生产资产/总资产，应收/总资产，货币资金/有息负债，非主业资产/总资产； 生产资产（固定资产、在建工程、工程物资以及无形资产里的土地）； 轻资产公司优于重资产公司，当期税前纯利润总额/生产资产，远高于社会资本平均回报率（按银行贷款标准利率的两倍毛估） 应收（资产负债表里应收科目-应收票据里的银行承兑汇票）/总资产，同行比较，越小越好，不宜超过三成； 货币资金/有息负债，是否有债务危机，货币资金应该覆盖有息负债； 非主业资产/总资产，是否将注意力放在所在行业。比值增大说明行业内已经很难有较大投资潜力；       利润表 企业当前经营的成果\n P（股价）=PE（市盈率）*E（每股收益）； 戴维斯双击，10倍市盈率以下，经营业绩增长率10-15%的企业； 收入确认规则； 利润三因素，毛利率（茅台模式）、周转率（沃尔玛模式）、经营杠杆（银行模式）； 主营业务单一为主； 资产减值损失，不提或少提增加当期利润，多提减少当期利润，一次性计提减少后期折旧和摊销从而增加后期财报利润； 营业利润=营业总收入-营业总成本（销售费用+管理费用+财务费用+资产减值损失+-（公允价值变动损益+投资收益+汇兑收益））； 净利润=营业利润+营业外收支净额-所得税； 经营现金流净额/净利润 常年大于1最佳； 毛利润=营业收入-营业成本，毛利率=毛利润/营业收入，毛利率最好高于40%； 费用率=三费（销售费用+管理费用+财务费用）/营业总收入； 费用/毛利润 超过70%关注价值不大； 营业利润率=营业利润/营业收入； 确认净利润是否变成现金回到公司账户，经营现金流净额/净利润，持续大于1最佳，说明供不应求，先款后货（房企除外，期房产生大量预收款）；       现金流量表 企业对资金的筹措和管控能力\n 一家企业，没有利润，也可以活得很滋润。过去20年，美国在线零售商亚马逊公司，一直以负利润或零利润状态经营。这没有妨碍它为美国、中国乃至全世界的消费者提供优质服务，也没妨碍它的股票自1997年上市至今，上涨超过200倍。\n  现金流量表是对货币资金科目下“现金及现金等价物”变化的展开‘ 现金活动：筹资活动现金流、投资活动现金流、经营活动现金流； 销售商品、提供劳务收到的现金/营业收入*1.17。大于1说明销售的大部分款项收到了，经营良好； 自由现金流=经营活动现金流净额-投资活动现金流出净额； 债务性筹资活动利率越高越危险；警惕货币资金不少但债务性活动筹资借款利率高的企业； 经营活动产生的现金流量净额\u0026gt;净利润\u0026gt;0； 销售商品、提供劳务收到的现金\u0026gt;=营业收入； 投资活动产生的现金流量净额\u0026lt;0，且主要投入新项目； 现金及现金等价物净增加额\u0026gt;0，可放款为排除分红因素； 期末现金及现金等价物余额+应收票据中的银行承兑汇票\u0026gt;=有息负债；     经营现金流净额 投资现金流净额 筹资现金流净额 -     + - - 可持续性   + - + 视项目前景、资金支持   + + - 低PE高股息         财务指标分析\n   安全性分析\n 流动比率=流动资产/流动负债，流动比率一般在2左右； 速动比率=速动资产（流动资产-存货）/流动负债，速动比率一般在1左右； 比率过高说明流动资产未能有效利用，太低说明有短期偿债风险； 安全性指标：现金及现金等价物/有息负债\u0026gt;=1 或放宽为 （货币资金+金融资产净值）/有息负债\u0026gt;=1;含义：变现迅速的资产足以偿还有息负债；       盈利能力分析\n 从收入角度，营业利润率最为重要。  营业利润率=（营业收入-营业成本-三费）/营业收入；   从资产角度，净资产收益率最为重要，总资产收益率是在净资产收益率上考虑了杠杆因素，净资产收益率相同的两家企业，总资产收益率更高的那家，有更强的盈利能力和更小的风险；  净资产收益率=净利润/平均净资产（期末值和期初值之和除以2）； 总资产收益率=净利润/平均总资产（期末值和期初值之和除以2）；         成长性分析\n 从收入角度，营业收入增长率和营业利润增长率；  营业收入增长率=（本期营业收入-上期营业收入）/上期营业收入； 营业利润增长率=（本期营业利润-上期营业利润）/上期营业利润；   从资产角度，总资产增长率和净资产增长率；  总资产增长率=（本期总资产-上期总资产）/上期总资产 净资产增长率=（本期净资产-上期净资产）/上期净资产   管理层能力（运营能力，固定周期对企业资源利用次数）分析：  平均应收账款=（期初应收账款总额+期末应收账款总额）/2 应收账款周转率=营业收入/平均应收账款 这个比率应该与历史数据比较观察。营业收入增长的同时，应收账款周转率是否下降了。应收账款周转率下降，意味着营业收入的增长，有放松销售政策的因素。反之，营业收入的增长，伴随着应收账款周转率的稳定或提高，意味着营业收入的增长是可靠的。         总体分析\n 净资产收益率（ROE）=净利润/净资产=净资产/销售收入*销售收入/平均总资产*平均总资产/净资产；         财务数据估值\n 现金流折现法，只适用评估产品变化小，需求偏好稳定，具有持续竞争优势的、未来自由现金流可预测的企业；（不适用低市值、初创、科技企业）  自由现金流=经营现金流入净额-投资活动现金流出   清算价值估算法，投资市值低于有形资产账面值的企业，涉及企业财报资产负债表的所有有形资产； 股票价值法，对比可比较性公司，参照当前市盈率、市净率和收入水平，预测目标公司的市盈率、市净率或收入水平，再结合净利润、净资产或销售收入进行估值；    董事会报告    当期经营情况的讨论与分析\n 主营业务分析 行业与产品地区分析 资产负债分析 投资状况分析       公司未来发展的讨论与分析\n需要与行业其他公司对比\n  重要事项  是否有重大事项影响公司的价值判断； 会计事务所改聘；  ","permalink":"https://rx-78-kum0.github.io/posts/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%AF%BB%E8%B4%A2%E6%8A%A5/","summary":"要点  会计政策的改变； 会计事务所出具 “标准无保留意见”； 上市时间长于5年； 某科目出现大比例变化，查看附注； 与同行对比；  关注的重点  财务会计报告 董事会报告 重要事项  财务会计报告    货币资金\n 货币资金余额比短期负债小很多； 货币资金充裕，却借了很多有息甚至高息负债； 定期存款很多，其他货币资金很多，流动资金却严重缺乏； 其他货币资金数额巨大，但没有合理解释；       经营相关资产\n 应收票据，银行承兑汇票\u0026gt;商业承兑汇票； 应收账款，增长幅度及坏账准备计提政策； 其他应收款，越小越好； 存货，存货和营业成本的合理比例；       生产相关资产\n 固定资产，年年折旧，折旧算费用； 在建工程，迟迟不转固定资产一般有鬼； 折旧 == 摊销； 无形资产，研发费用 = 机会+风险。房企，土地算存货而非无形资产 利润高的公司更愿意把研发支出都记入费用中，这样可以减少当期税收支出；反之计入无形资产凸显财报好看； 商誉：若一家企业的获利能力超过可辨认净资产的正常获利能力，超出的部分，一定是另外一种资产带来的，这个资产就被叫作“商誉”。没有进行过收购的企业商誉栏目为0。商誉不用摊销； 长期待摊费用，越小越好； 递延所得税资产，税务局收的税大于公司酸的应交税款； 递延所得税负债，税务局收的税小于公司算的应交税款； 企业净资产与真实相差甚远，如资产折旧或商誉价值；       投资相关资产\n 交易性金融资产，不折旧。以卖出产生利润收税；产生递延所得税资产和负债的重要源头。公允价值变动计入利润表； 持有至到期投资，按实际利率计算的投资收益，减值损失； 可供出售金融资产，汇兑损益，股利或利息，减值损失等公允价值变动加入净资产； 长期股权投资，分红影响利润，或经营盈亏影响利润； 买入返售金融资产，规避监管的抵押贷款； 投资性房地产，公允价值对利润和净资产影响巨大；       负债和所有人权益","title":"手把手教你读财报"},{"content":"package sliceSafe type SliceSafe struct { channel chan int `desc:\u0026#34;即将加入到数据slice的数据\u0026#34;` data []int `desc:\u0026#34;数据slice\u0026#34;` } // 新建一个size大小缓存的active object对象 func New(size int, done func()) *SliceSafe { s := \u0026amp;SliceSafe{ channel: make(chan int, size), data: make([]int, 0), } go func() { s.schedule() done() }() return s } // 把管道中的数据append到slice中 func (s *SliceSafe) schedule() { for v := range s.channel { s.data = append(s.data, v) } } // 增加一个值 func (s *SliceSafe) Add(v int) { s.channel \u0026lt;- v } // 管道使用完关闭 func (s *SliceSafe) Close() { close(s.channel) } // 返回slice func (s *Service) Slice() []int { return s.data } ","permalink":"https://rx-78-kum0.github.io/posts/golang%E5%B9%B6%E5%8F%91%E5%86%99slice/","summary":"package sliceSafe type SliceSafe struct { channel chan int `desc:\u0026#34;即将加入到数据slice的数据\u0026#34;` data []int `desc:\u0026#34;数据slice\u0026#34;` } // 新建一个size大小缓存的active object对象 func New(size int, done func()) *SliceSafe { s := \u0026amp;SliceSafe{ channel: make(chan int, size), data: make([]int, 0), } go func() { s.schedule() done() }() return s } // 把管道中的数据append到slice中 func (s *SliceSafe) schedule() { for v := range s.channel { s.data = append(s.data, v) } } // 增加一个值 func (s *SliceSafe) Add(v int) { s.","title":"golang并发写slice"},{"content":"函数参数类型 type FuncParamsType\u0026lt;T\u0026gt; = T extends (arg: infer P) =\u0026gt; void ? P : string; function func(arg: string) {} type ParamsType = FuncParamsType\u0026lt;typeof func\u0026gt;; // ParamsType: string 函数返回值类型 type FuncReturnType\u0026lt;T\u0026gt; = T extends (arg: any) =\u0026gt; infer P ? P : string; function func(arg: string): number {} type ReturnType = FuncReturnType\u0026lt;typeof func\u0026gt;; // ReturnType: number 数组成员作为键约束 const keys = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;] as const; type Keys = typeof keys[number] type KeysMap = Record\u0026lt;Keys, string\u0026gt; // KeysMap: { a: string; b: string; c: string; }  可选键约束 type Key = \u0026#34;a\u0026#34; | \u0026#34;b\u0026#34;; type OptionalKeyMap={ // optionalKeyMap: { \u0026#34;a\u0026#34; | \u0026#34;b\u0026#34;: number }  [K in Key]?: number }; ","permalink":"https://rx-78-kum0.github.io/posts/%E5%B8%B8%E7%94%A8%E7%9A%84typescript%E7%B1%BB%E5%9E%8B%E5%85%AC%E5%BC%8F/","summary":"函数参数类型 type FuncParamsType\u0026lt;T\u0026gt; = T extends (arg: infer P) =\u0026gt; void ? P : string; function func(arg: string) {} type ParamsType = FuncParamsType\u0026lt;typeof func\u0026gt;; // ParamsType: string 函数返回值类型 type FuncReturnType\u0026lt;T\u0026gt; = T extends (arg: any) =\u0026gt; infer P ? P : string; function func(arg: string): number {} type ReturnType = FuncReturnType\u0026lt;typeof func\u0026gt;; // ReturnType: number 数组成员作为键约束 const keys = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;] as const; type Keys = typeof keys[number] type KeysMap = Record\u0026lt;Keys, string\u0026gt; // KeysMap: { a: string; b: string; c: string; }  可选键约束 type Key = \u0026#34;a\u0026#34; | \u0026#34;b\u0026#34;; type OptionalKeyMap={ // optionalKeyMap: { \u0026#34;a\u0026#34; | \u0026#34;b\u0026#34;: number }  [K in Key]?","title":"常用的typescript类型推导公式"},{"content":"// 复制文字 // copyText(\u0026#39;h5实现一键复制到粘贴板 兼容ios\u0026#39;) /*兼容性补充： 移动端： 安卓手机: 微信（chrome）和几个手机浏览器都可以用。 苹果手机: 微信里面和sarafi浏览器里也都可以， PC: sarafi版本必须在10.2以上，其他浏览器可以. */ export function copyText(text: string | number) { // number类型没有 .length 不能执行selectText 需要转化成字符串  const textString = text.toString(); let input: HTMLInputElement | null = document.querySelector(\u0026#39;#copy-input\u0026#39;); if (!input) { input = document.createElement(\u0026#39;input\u0026#39;); input.id = \u0026#39;copy-input\u0026#39;; input.readOnly = true; // 防止ios聚焦触发键盘事件  input.style.position = \u0026#39;absolute\u0026#39;; input.style.left = \u0026#39;-1000px\u0026#39;; input.style.zIndex = \u0026#39;-1000\u0026#39;; document.body.appendChild(input); } input.value = textString; // ios必须先选中文字且不支持 input.select();  selectText(input, 0, textString.length); if (document.execCommand(\u0026#39;copy\u0026#39;)) { document.execCommand(\u0026#39;copy\u0026#39;); alert(\u0026#39;It has copy the code to the clipboard\u0026#39;); } else { console.error(\u0026#39;不兼容\u0026#39;); } input.blur(); } // input自带的select()方法在苹果端无法进行选择，所以需要自己去写一个类似的方法 function selectText(textbox: HTMLInputElement | any, startIndex: number, stopIndex: number) { if (textbox.createTextRange) { // ie  const range = textbox.createTextRange(); range.collapse(true); range.moveStart(\u0026#39;character\u0026#39;, startIndex); // 起始光标  range.moveEnd(\u0026#39;character\u0026#39;, stopIndex - startIndex); // 结束光标  range.select(); // 不兼容苹果  } else { // firefox/chrome  textbox.setSelectionRange(startIndex, stopIndex); textbox.focus(); } } ","permalink":"https://rx-78-kum0.github.io/posts/h5%E5%A4%8D%E5%88%B6%E6%96%87%E5%AD%97%E5%88%B0%E5%89%AA%E5%88%87%E6%9D%BF/","summary":"// 复制文字 // copyText(\u0026#39;h5实现一键复制到粘贴板 兼容ios\u0026#39;) /*兼容性补充： 移动端： 安卓手机: 微信（chrome）和几个手机浏览器都可以用。 苹果手机: 微信里面和sarafi浏览器里也都可以， PC: sarafi版本必须在10.2以上，其他浏览器可以. */ export function copyText(text: string | number) { // number类型没有 .length 不能执行selectText 需要转化成字符串  const textString = text.toString(); let input: HTMLInputElement | null = document.querySelector(\u0026#39;#copy-input\u0026#39;); if (!input) { input = document.createElement(\u0026#39;input\u0026#39;); input.id = \u0026#39;copy-input\u0026#39;; input.readOnly = true; // 防止ios聚焦触发键盘事件  input.style.position = \u0026#39;absolute\u0026#39;; input.style.left = \u0026#39;-1000px\u0026#39;; input.style.zIndex = \u0026#39;-1000\u0026#39;; document.body.appendChild(input); } input.value = textString; // ios必须先选中文字且不支持 input.select();  selectText(input, 0, textString.","title":"H5复制文字到剪切板"},{"content":"从今天起这里多了一只白色，高冷的看门喵。视线会一直跟着你的鼠标，鼠标靠近它就可以撸了！\n目前只设定让它在PC出现，在移动端显示有些突兀。\n养猫攻略  喵喵基于 live2d 绘图技术，在前端使用canvas绘制。\n  使用hexo搭建的站点可以直接使用 hexo-helper-live2d 快速养猫 使用 live2d-widget.js 源码导入  打包源码 # 拉取源码 $ git clone https://github.com/xiazeyu/live2d-widget.js.git # 下载依赖 $ yarn # 打包源码 $ npm run build:prod lib文件夹里就是打包成果。\n在hugo中使用   将打包后的lib路径中的 L2Dwidget.min.js 文件放到hugo根目录的 static/js 目录中。\n  在这儿下载喜欢的 live2d 模型放到hugo根目录的 static/live2d_models 目录中。\n  在当前使用的主题模板中导入和执行以上代码。一般是在 hugo/themes/xx/layouts/partials/script.html 中，这个文件是页面导入的script部分(虽是html文件，但是编辑时不能使用prettier-js格式化，会破坏hugo的模板语法)。\n\u0026lt;script src=\u0026#34;/js/L2Dwidget.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; /** ​ * The init function ​ * @param {Object} [userConfig] User\u0026#39;s custom config 用户自定义设置 ​ * @param {String} [userConfig.model.jsonPath = \u0026#39;\u0026#39;] Path to Live2D model\u0026#39;s main json eg. `https://test.com/miku.model.json` model主文件路径 ​ * @param {Number} [userConfig.model.scale = 1] Scale between the model and the canvas 模型与canvas的缩放 ​ * @param {Number} [userConfig.display.superSample = 2] rate for super sampling rate 超采样等级 ​ * @param {Number} [userConfig.display.width = 150] Width to the canvas which shows the model canvas的长度 ​ * @param {Number} [userConfig.display.height = 300] Height to the canvas which shows the model canvas的高度 ​ * @param {String} [userConfig.display.position = \u0026#39;right\u0026#39;] Left of right side to show 显示位置：左或右 ​ * @param {Number} [userConfig.display.hOffset = 0] Horizontal offset of the canvas canvas水平偏移 ​ * @param {Number} [userConfig.display.vOffset = -20] Vertical offset of the canvas canvas垂直偏移 ​ * @param {Boolean} [userConfig.mobile.show = true] Whether to show on mobile device 是否在移动设备上显示 ​ * @param {Number} [userConfig.mobile.scale = 0.5] Scale on mobile device 移动设备上的缩放 ​ * @param {String} [userConfig.name.canvas = \u0026#39;live2dcanvas\u0026#39;] ID name of the canvas canvas元素的ID ​ * @param {String} [userConfig.name.div = \u0026#39;live2d-widget\u0026#39;] ID name of the div div元素的ID ​ * @param {Number} [userConfig.react.opacity = 0.7] opacity 透明度 ​ * @param {Boolean} [userConfig.dev.border = false] Whether to show border around the canvas 在canvas周围显示边界 ​ * @param {Boolean} [userConfig.dialog.enable = false] Display dialog 显示人物对话框 ​ * @param {Boolean} [userConfig.dialog.hitokoto = false] Enable hitokoto 使用一言API ​ * @return {null} */ L2Dwidget.init({ model: { jsonPath: \u0026#39;/live2d_models/tororo/tororo.model.json\u0026#39;, scale: 1, }, display: { superSample: 1, width: 150, height: 300, position: \u0026#39;left\u0026#39;, hOffset: 60, vOffset: 0 }, mobile: { show: false, scale: 0.5, }, react: { opacity: 0.8 } }); \u0026lt;/script\u0026gt;   大功告成 有猫了有猫了\n","permalink":"https://rx-78-kum0.github.io/posts/%E5%9C%A8%E5%8D%9A%E5%AE%A2%E5%85%BB%E4%B8%80%E5%8F%AA%E7%8C%AB/","summary":"从今天起这里多了一只白色，高冷的看门喵。视线会一直跟着你的鼠标，鼠标靠近它就可以撸了！\n目前只设定让它在PC出现，在移动端显示有些突兀。\n养猫攻略  喵喵基于 live2d 绘图技术，在前端使用canvas绘制。\n  使用hexo搭建的站点可以直接使用 hexo-helper-live2d 快速养猫 使用 live2d-widget.js 源码导入  打包源码 # 拉取源码 $ git clone https://github.com/xiazeyu/live2d-widget.js.git # 下载依赖 $ yarn # 打包源码 $ npm run build:prod lib文件夹里就是打包成果。\n在hugo中使用   将打包后的lib路径中的 L2Dwidget.min.js 文件放到hugo根目录的 static/js 目录中。\n  在这儿下载喜欢的 live2d 模型放到hugo根目录的 static/live2d_models 目录中。\n  在当前使用的主题模板中导入和执行以上代码。一般是在 hugo/themes/xx/layouts/partials/script.html 中，这个文件是页面导入的script部分(虽是html文件，但是编辑时不能使用prettier-js格式化，会破坏hugo的模板语法)。\n\u0026lt;script src=\u0026#34;/js/L2Dwidget.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; /** ​ * The init function ​ * @param {Object} [userConfig] User\u0026#39;s custom config 用户自定义设置 ​ * @param {String} [userConfig.","title":"在博客养一只猫"},{"content":"使用emacs作为hugo博客的客户端  Hugo 生成博客的静态页面虽然已经很方便了，ox-hugo 自动md -\u0026gt; org也很便捷了，但写作和发布博客需要经过若干命令行操作才能完成。没有客户端界面直观。\n 目前写作和发布的流程 新建org文件 -\u0026gt; balabala并自动转md -\u0026gt; 命令行: $ hugo // 生成静态页面 -\u0026gt; magit stage/commit/push -\u0026gt; 完成 hugo 的 major-mode 插件: easy-hugo  easy-hugo 是 emacs 上的 hugo 博客管理的插件。支持markdown or org-mode or AsciiDoc or reStructuredText or mmark or html 等格式文档，多博客多站点，以及多平台部署。\n   easy-hugo 配置 (use-package easy-hugo :commands easy-hugo :bind (:map easy-hugo-mode-map (\u0026#34;SPC\u0026#34; . general-simulate-C-c) (\u0026#34;G\u0026#34; . kumo-easy-hugo-github-deploy)) :custom (easy-hugo-org-header t) (easy-hugo-basedir kumo/easy-hugo-basedir) (easy-hugo-postdir kumo/easy-hugo-postdir) (easy-hugo-url kumo/easy-hugo-url) (easy-hugo-preview-url kumo/easy-hugo-preview-url) (easy-hugo-github-deploy-script kumo/easy-hugo-github-deploy-script) (easy-hugo-default-ext \u0026#34;.org\u0026#34;) :hook (easy-hugo-mode . (lambda () (evil-set-initial-state \u0026#39;easy-hugo-mode \u0026#39;emacs))) )  需要配置 easy-hugo 的 basedir/postdir/preview-url/deploy-script 等等。方便 easy-hugo 读取出博客列表、部署脚本，以及执行一键预览等。\n 部署脚本 #!/bin/sh  # If a command fails then the deploy stops set -e printf \u0026#34;\\033[0;32mDeploying updates to GitHub...\\033[0m\\n\u0026#34; # Build the project. hugo # if using a theme, replace with `hugo -t \u0026lt;YOURTHEME\u0026gt;` # Go To Public folder cd public # Add changes to git. git add . # Commit changes. msg=\u0026#34;rebuilding site $(date)\u0026#34; if [ -n \u0026#34;$*\u0026#34; ]; then msg=\u0026#34;$*\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. git push origin master -f    配置的一些坑\n 由于我使用了evil-mode，所以 easy-hugo-mode-map 的原生键位是不能用了。只有在 easy-hugo-mode 中屏蔽 evil-mode.   :hook (easy-hugo-mode . (lambda () (evil-set-initial-state \u0026#39;easy-hugo-mode \u0026#39;emacs)))  屏蔽 evil-mode 同时也屏蔽了 general 的触发键 SPC。 emacs 上没有了 SPC 就像走路蒙着双眼\u0026hellip;   :bind (:map easy-hugo-mode-map (\u0026#34;SPC\u0026#34; . general-simulate-C-c))  easy-hugo 原生的 github page 部署函数不支持交互式shell脚本，导致 git push 时不能输入密码。需要自己写个函数来替换它。   这里使用 C-q 而不是 q 退出 async-shell-command 的 buffer。因为万一账号或密码中带有 \u0026ldquo;q\u0026rdquo; 就不好了\u0026hellip;😅\n :bind (:map easy-hugo-mode-map (\u0026#34;G\u0026#34; . kumo-easy-hugo-github-deploy)) (defun kumo-easy-hugo-github-deploy () \u0026#34;Easy-Hugo deploy github page.\u0026#34; (interactive) (let* ((output-buffer (get-buffer-create kumo/easy-hugo-github-deploy-buffer-name)) (command-window (async-shell-command (expand-file-name (concat kumo/easy-hugo-basedir kumo/easy-hugo-github-deploy-script)) output-buffer nil))) (select-window command-window) (local-set-key (kbd \u0026#34;C-q\u0026#34;) \u0026#39;kill-buffer-and-window)))   现在的写作和发布的流程 呼出 easy-hugo -\u0026gt; n键 新建org balabala并自动转md -\u0026gt; G键 发布部署 博客总算能有一个像样的管理界面了😅\n现在写作/发布可以直接依托 emacs，并且都不需要键入一个命令行。\n","permalink":"https://rx-78-kum0.github.io/posts/emacs%E7%AE%A1%E7%90%86%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C%E6%B5%81%E7%A8%8B/","summary":"使用emacs作为hugo博客的客户端  Hugo 生成博客的静态页面虽然已经很方便了，ox-hugo 自动md -\u0026gt; org也很便捷了，但写作和发布博客需要经过若干命令行操作才能完成。没有客户端界面直观。\n 目前写作和发布的流程 新建org文件 -\u0026gt; balabala并自动转md -\u0026gt; 命令行: $ hugo // 生成静态页面 -\u0026gt; magit stage/commit/push -\u0026gt; 完成 hugo 的 major-mode 插件: easy-hugo  easy-hugo 是 emacs 上的 hugo 博客管理的插件。支持markdown or org-mode or AsciiDoc or reStructuredText or mmark or html 等格式文档，多博客多站点，以及多平台部署。\n   easy-hugo 配置 (use-package easy-hugo :commands easy-hugo :bind (:map easy-hugo-mode-map (\u0026#34;SPC\u0026#34; . general-simulate-C-c) (\u0026#34;G\u0026#34; . kumo-easy-hugo-github-deploy)) :custom (easy-hugo-org-header t) (easy-hugo-basedir kumo/easy-hugo-basedir) (easy-hugo-postdir kumo/easy-hugo-postdir) (easy-hugo-url kumo/easy-hugo-url) (easy-hugo-preview-url kumo/easy-hugo-preview-url) (easy-hugo-github-deploy-script kumo/easy-hugo-github-deploy-script) (easy-hugo-default-ext \u0026#34;.","title":"emacs管理博客写作流程"},{"content":"redis发布订阅  相比rabbitmq等专业消息队列的缺陷: 没有相应的机制保证消息的可靠消费，如果发布者发布一条消息，而没有对应的订阅者的话，这条消息将丢失，不会存在内存中。\n package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/gomodule/redigo/redis\u0026#34; ) // ConsumeFunc consumes message at the channel. type ConsumeFunc func(channel string, message []byte) error // RedisClient represents a redis client with connection pool. type RedisClient struct { pool *redis.Pool } // NewRedisClient returns a RedisClient. func NewRedisClient(addr string, passwd string) *RedisClient { pool := \u0026amp;redis.Pool{ MaxIdle: 10, IdleTimeout: 300 * time.Second, Dial: func() (redis.Conn, error) { c, err := redis.Dial(\u0026#34;tcp\u0026#34;, addr, redis.DialPassword(passwd), redis.DialDatabase(0)) if err != nil { return nil, err } return c, nil }, TestOnBorrow: func(c redis.Conn, t time.Time) error { if time.Since(t) \u0026lt; time.Minute { return nil } _, err := c.Do(\u0026#34;PING\u0026#34;) return err }, } log.Printf(\u0026#34;new redis pool at %s\u0026#34;, addr) client := \u0026amp;RedisClient{ pool: pool, } return client } // Close closes connection pool. func (r *RedisClient) Close() error { err := r.pool.Close() return err } // Publish publishes message to channel. func (r *RedisClient) Publish(channel, message string) (int, error) { c := r.pool.Get() defer c.Close() n, err := redis.Int(c.Do(\u0026#34;PUBLISH\u0026#34;, channel, message)) if err != nil { return 0, fmt.Errorf(\u0026#34;redis publish %s %s, err: %v\u0026#34;, channel, message, err) } return n, nil } // Subscribe subscribes messages at the channels. func (r *RedisClient) Subscribe(ctx context.Context, consume ConsumeFunc, channel ...string) error { psc := redis.PubSubConn{Conn: r.pool.Get()} log.Printf(\u0026#34;redis pubsub subscribe channel: %v\u0026#34;, channel) if err := psc.Subscribe(redis.Args{}.AddFlat(channel)...); err != nil { return err } done := make(chan error, 1) // start a new goroutine to receive message  go func() { defer psc.Close() for { switch msg := psc.Receive().(type) { case error: done \u0026lt;- fmt.Errorf(\u0026#34;redis pubsub receive err: %v\u0026#34;, msg) return case redis.Message: if err := consume(msg.Channel, msg.Data); err != nil { done \u0026lt;- err return } case redis.Subscription: if msg.Count == 0 { // all channels are unsubscribed  done \u0026lt;- nil return } } } }() ch \u0026lt;- 0 // health check  tick := time.NewTicker(time.Minute) defer tick.Stop() for { select { case \u0026lt;-ctx.Done(): if err := psc.Unsubscribe(); err != nil { return fmt.Errorf(\u0026#34;redis pubsub unsubscribe err: %v\u0026#34;, err) } return nil case err := \u0026lt;-done: return err case \u0026lt;-tick.C: if err := psc.Ping(\u0026#34;\u0026#34;); err != nil { return err } log.Println(\u0026#34;over\u0026#34;) return nil } } } func myConsumer(channel string, message []byte) error { log.Printf(\u0026#34;receive message[%s] at the channel[%s]\\n\u0026#34;, string(message), channel) return nil } // ch 用于保证发布线程在订阅线程启动成功后才开始发布消息 var ch = make(chan int) func main() { redisClient := NewRedisClient(\u0026#34;127.0.0.1:6300\u0026#34;, \u0026#34;zyhua1122\u0026#34;) defer redisClient.Close() go func() { var subscriber int \u0026lt;-ch for i := 0; i \u0026lt; 3; i++ { subscriber, _ = redisClient.Publish(\u0026#34;testx\u0026#34;, \u0026#34;hello world\u0026#34;+strconv.Itoa(i)) log.Printf(\u0026#34;there is %d subscriber.\\n\u0026#34;, subscriber) } }() ctx, cancel := context.WithCancel(context.Background()) err := redisClient.Subscribe(ctx, func(channel string, message []byte) error { log.Printf(\u0026#34;receive message[%s] at the channel[%s]\\n\u0026#34;, string(message), channel) if string(message) == \u0026#34;goodbye\u0026#34; { cancel() } return nil }, \u0026#34;testx\u0026#34;) if err != nil { fmt.Printf(\u0026#34;get error: %v\\n\u0026#34;, err) } return } ","permalink":"https://rx-78-kum0.github.io/posts/redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/","summary":"redis发布订阅  相比rabbitmq等专业消息队列的缺陷: 没有相应的机制保证消息的可靠消费，如果发布者发布一条消息，而没有对应的订阅者的话，这条消息将丢失，不会存在内存中。\n package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/gomodule/redigo/redis\u0026#34; ) // ConsumeFunc consumes message at the channel. type ConsumeFunc func(channel string, message []byte) error // RedisClient represents a redis client with connection pool. type RedisClient struct { pool *redis.Pool } // NewRedisClient returns a RedisClient. func NewRedisClient(addr string, passwd string) *RedisClient { pool := \u0026amp;redis.Pool{ MaxIdle: 10, IdleTimeout: 300 * time.Second, Dial: func() (redis.Conn, error) { c, err := redis.","title":"redis发布订阅"},{"content":"package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) type Glimit struct { n int c chan struct{} } func New(n int) *Glimit { return \u0026amp;Glimit{ n: n, c: make(chan struct{}, n), } } func (g *Glimit) Run(f func()) { g.c \u0026lt;- struct{}{} go func() { f() \u0026lt;-g.c }() } var wg = sync.WaitGroup{} func main() { number := 10 g := New(2) for i := 0; i \u0026lt; number; i++ { wg.Add(1) value := i g.Run(func() { // 做一些业务逻辑处理  fmt.Printf(\u0026#34;go func: %d\\n\u0026#34;, value) time.Sleep(time.Second) wg.Done() }) } wg.Wait() } ","permalink":"https://rx-78-kum0.github.io/posts/%E9%99%90%E5%88%B6goroutine%E6%95%B0%E9%87%8F/","summary":"package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) type Glimit struct { n int c chan struct{} } func New(n int) *Glimit { return \u0026amp;Glimit{ n: n, c: make(chan struct{}, n), } } func (g *Glimit) Run(f func()) { g.c \u0026lt;- struct{}{} go func() { f() \u0026lt;-g.c }() } var wg = sync.WaitGroup{} func main() { number := 10 g := New(2) for i := 0; i \u0026lt; number; i++ { wg.","title":"限制goroutine数量"},{"content":"小对象要合并 函数频繁创建的简单的对象，直接返回对象，效果比返回指针效果要好 类型转换要注意，官方用法消耗特别大。 package string_util import ( \u0026#34;unsafe\u0026#34; ) func str2bytes(s string) []byte { x := (*[2]uintptr)(unsafe.Pointer(\u0026amp;s)) h := [3]uintptr{x[0], x[1], x[1]} return *(*[]byte)(unsafe.Pointer(\u0026amp;h)) } func bytes2str(b []byte) string { return *(*string)(unsafe.Pointer(\u0026amp;b)) } 避免反复创建slice，map func(r*Reader)Read()([]byte,error) // 此函数没有形参，每次调用的时候返回一个[]byte。 func(r*Reader)Read(buf[]byte)(int,error) // 此函数个函数在每次迪调用的时候，会重用形参声明。  避免使用\u0026quot;+\u0026ldquo;拼接字符串 package string_utils import ( \u0026#34;strings\u0026#34; ) func strAppend(s string, ss ...string) string { var r strings.Builder r.WriteString(s) for _, v := range ss { r.WriteString(v) } return r.String() } ","permalink":"https://rx-78-kum0.github.io/posts/gc%E4%BC%98%E5%8C%96/","summary":"小对象要合并 函数频繁创建的简单的对象，直接返回对象，效果比返回指针效果要好 类型转换要注意，官方用法消耗特别大。 package string_util import ( \u0026#34;unsafe\u0026#34; ) func str2bytes(s string) []byte { x := (*[2]uintptr)(unsafe.Pointer(\u0026amp;s)) h := [3]uintptr{x[0], x[1], x[1]} return *(*[]byte)(unsafe.Pointer(\u0026amp;h)) } func bytes2str(b []byte) string { return *(*string)(unsafe.Pointer(\u0026amp;b)) } 避免反复创建slice，map func(r*Reader)Read()([]byte,error) // 此函数没有形参，每次调用的时候返回一个[]byte。 func(r*Reader)Read(buf[]byte)(int,error) // 此函数个函数在每次迪调用的时候，会重用形参声明。  避免使用\u0026quot;+\u0026ldquo;拼接字符串 package string_utils import ( \u0026#34;strings\u0026#34; ) func strAppend(s string, ss ...string) string { var r strings.Builder r.WriteString(s) for _, v := range ss { r.WriteString(v) } return r.String() } ","title":"golang gc优化"},{"content":"package util-time import ( \u0026#34;strconv\u0026#34; \u0026#34;time\u0026#34; ) // 获取当前的时间 - 字符串 func GetCurrentDate() string { return time.Now().Format(\u0026#34;2006/01/02 15:04:05\u0026#34;) } // 获取当前的时间 - Unix时间戳 func GetCurrentUnix() int64 { return time.Now().Unix() } // 获取当前的时间 - 毫秒级时间戳 func GetCurrentMilliUnix() int64 { return time.Now().UnixNano() / 1000000 } // 获取当前的时间 - 纳秒级时间戳 func GetCurrentNanoUnix() int64 { return time.Now().UnixNano() } func GetCurrentTime() string { var cstSh, _ = time.LoadLocation(\u0026#34;Asia/Shanghai\u0026#34;) t := time.Now().In(cstSh).Format(\u0026#34;2006/01/02/ 15:04:05\u0026#34;) return t } func GetCurrentHour() int { var cstSh, _ = time.LoadLocation(\u0026#34;Asia/Shanghai\u0026#34;) t,_ := strconv.Atoi(time.Now().In(cstSh).Format(\u0026#34;2006010215\u0026#34;)) return t } func GetCurrentDay() int { var cstSh, _ = time.LoadLocation(\u0026#34;Asia/Shanghai\u0026#34;) t,_ := strconv.Atoi(time.Now().In(cstSh).Format(\u0026#34;20060102\u0026#34;)) return t } func GetLastDay() int { var cstSh, _ = time.LoadLocation(\u0026#34;Asia/Shanghai\u0026#34;) nTime := time.Now() t,_ := strconv.Atoi(nTime.AddDate(0,0,-1).In(cstSh).Format(\u0026#34;20060102\u0026#34;)) return t } func GetlastHour() int { nTime := time.Now() lastTime := nTime.Add(time.Hour * -1) t,_ := strconv.Atoi(lastTime.Format(\u0026#34;2006010215\u0026#34;)) return t } ","permalink":"https://rx-78-kum0.github.io/posts/time/","summary":"package util-time import ( \u0026#34;strconv\u0026#34; \u0026#34;time\u0026#34; ) // 获取当前的时间 - 字符串 func GetCurrentDate() string { return time.Now().Format(\u0026#34;2006/01/02 15:04:05\u0026#34;) } // 获取当前的时间 - Unix时间戳 func GetCurrentUnix() int64 { return time.Now().Unix() } // 获取当前的时间 - 毫秒级时间戳 func GetCurrentMilliUnix() int64 { return time.Now().UnixNano() / 1000000 } // 获取当前的时间 - 纳秒级时间戳 func GetCurrentNanoUnix() int64 { return time.Now().UnixNano() } func GetCurrentTime() string { var cstSh, _ = time.LoadLocation(\u0026#34;Asia/Shanghai\u0026#34;) t := time.Now().In(cstSh).Format(\u0026#34;2006/01/02/ 15:04:05\u0026#34;) return t } func GetCurrentHour() int { var cstSh, _ = time.","title":"golang time工具函数"},{"content":"GDT(Global Descriptor Table)全局描述符表 GDT是一个以 段描述符 为表项的数组类型的数据结构，在内存中线性存放。每个段描述符占 8 个字节。\nGDTR寄存器存放GDT表的基地址和表长界限(高32位存放GDT基址，低16为存放GDT限长)。指令LGDT和SGDT分别用于加载和保存GDTR寄存器的内容。在机器刚加电或处理器复位后，基地址被默认地设置为0，而长度值被设置成0xFFFF。在保护模式初始化过程中必须给GDTR加载一个新值。\n段选择子(Segement Selector) 由GDTR访问全局描述符表是通过“段选择子”(实模式下的段寄存器)来完成的。段选择子是一个16位的寄存器(同实模式下的段寄存器相同)。\n段选择子共16bit，由三部分组成: 描述符索引(index)、TI、请求特权级(RPL)  描述符索引(index): 在描述符表中定位一个段描述符。 TI: 描述符表指示器， TI＝0 时，表示描述符在 GDT 中； TI＝1 时，描述符在 LDT 中。 RPL: 请求特权级，表示给出当前选择子访问的内存段的特权级别。每一个段都有一个特定的级别。每当一个程序试图访问某一个段时，就将该程序所拥有的特权级与要访问的特权级进行比较，以决定能否访问该段。系统约定，CPU只能访问同一特权级或级别较低特权级的段。  因为每个描述符占 8 字节，因此描述符在表内的偏移地址是索引号乘以 8 处理器在执行任何改变段选择器的指令时(比如 pop、 mov、jmp far、 call far、 iret、 retf)，就将指令中提供的索引号乘以 8 作为偏移地址，同 GDTR 中提供的线性基地址相加，以访问 GDT。在表内找到的描述符，并加载到不可见的描述符高速缓存部分。此后每当有访问内存的指令时，就不再访问 GDT 中的描述符，直接用当前段寄存器描述符高速缓存器提供线性基地址。\n段描述符(Segment Descriptor) 每个段描述符占 8 个字节。由三部分组成: 线性基地址、段界限和段的访问属性。\n    G: 粒度位，用于解释段界限的含义。当 G 位是\u0026quot;0\u0026quot;时，段界限以字节为单位。此时，段的扩展范围是从 1 字节到 1 兆字节（ 1B～1MB），因为描述符中的界限值是 20 位的。相反，如果该位是\u0026quot;1\u0026quot;，那么，段界限是以 4KB 为单位的。这样，段的扩展范围是从 4KB到 4GB。\n  D/B: \u0026ldquo;默认的操作数大小\u0026rdquo;(Default Operation Size)或者\u0026quot;默认的堆栈指针大小\u0026quot;，又或者\u0026quot;上部边界\u0026quot;标志。设立该标志位，主要是为了能够在 32 位处理器上兼容运行 16 位保护模式的程序。D＝0 表示指令中的偏移地址或者操作数是 16 位的； D＝1，指示 32 位的偏移地址或者操作数。\n  L: 64 位代码段标志。保留此位给 64 位处理器使用。32位将此位置\u0026quot;0\u0026quot;。\n  AVL: 保留位。可以被系统软件使用。\n  P: 段存在位(Segment Present)。 P 位用于指示描述符所对应的段是否存在。一般来说，描述符所指示的段都位于内存中。但是，当内存空间紧张时，有可能只是建立了描述符，对应的内存空间并不存在，这时，就应当把描述符的 P 位清零，表示段并不存在。P 位是由处理器负责检查的。每当通过描述符访问内存中的段时，如果 P 位是\u0026quot;0\u0026quot;，处理器就会产生一个异常中断。\n  DPL: 描述符的特权级(Descriptor Privilege Level， DPL)。这两位用于指定段的特权级。共有 4 种处理器支持的特权级别，分别是 0、 1、 2、 3，其中 0 是最高特权级别， 3 是最低特权级别。刚进入保护模式时执行的代码具有最高特权级 0(可以看成是从处理器那里继承来的)，这些代码通常都是操作系统代码(内核段)，因此它的特权级别最高。每当操作系统加载一个用户程序时，它通常都会指定一个稍低的特权级(用户段)，比如 3 特权级。不同特权级别的程序是互相隔离的，其互访是严格限制的，而且有些处理器指令(特权指令)只能由 0 特权级的程序来执行，为的就是安全。这里再次点明了为何叫保护模式。\n  S: 用于指定描述符的类型(Descriptor Type)。当该位是\u0026quot;0\u0026quot;时，表示是一个系统段；为\u0026quot;1\u0026quot;时，表示是一个代码段或者数据段(堆栈段也是特殊的数据段)。\n  TYPE: 共 4 位，用于指示描述符的子类型，或者说是类别。\n  描述符类型   对于数据段来说， 这 4 位分别是 X、 E、 W、 A 位；而对于代码段来说，这 4 位则分别是 X、 C、 R、 A 位。\n数据段  X: 表示是否可以执行（ eXecutable）。数据段总是不可执行的，X＝0。 E: 针对数据段。E 位指示段的扩展方向。 E＝0 是向上扩展的，也就是向高地址方向扩展的，是普通的数据段； E＝1 是向下扩展的，也就是向低地址方向扩展的，通常是堆栈段。 W: 段的读写属性，W＝0 的段是不允许写入的，否则会引发处理器异常中断； W＝1的段是可以正常写入的。 A: 已访问位，用于指示它所指向的段最近是否被访问过。在描述符创建的时候，应该清零。之后，每当该段被访问时，处理器自动将该位置\u0026quot;1\u0026quot;。  代码段   X: 表示是否可以执行(eXecutable)。代码段总是可以执行的 X＝1。\n  C: 是否为特权级依从的(Conforming)。 C＝0 表示非依从的代码段，这样的代码段可以从与它特权级相同的代码段调用，或者通过门调用； C＝1 表示允许从低特权级的程序转移到该段执行。\n  R: 是否允许读出。代码段总是可以执行的，但是，为了防止程序被破坏，它是不能写入的。至于是否有读出的可能，由 R 位指定。 R＝0 表示不能读出，如果企图去读一个 R＝0 的代码段，会引发处理器异常中断；如果 R＝1，则代码段是可以读出的，即可以把这个段的内容当成 ROM 一样使用。\n 也许有人会问，既然代码段是不可读的，那处理器怎么从里面取指令执行呢？事实上，这里的R属性并非用来限制处理器， 而是用来限制程序和指令的行为。\n   A: 已访问位，用于指示它所指向的段最近是否被访问过。在描述符创建的时候，应该清零。之后，每当该段被访问时，处理器自动将该位置\u0026quot;1\u0026quot;。\n  ","permalink":"https://rx-78-kum0.github.io/posts/gdtldt/","summary":"GDT(Global Descriptor Table)全局描述符表 GDT是一个以 段描述符 为表项的数组类型的数据结构，在内存中线性存放。每个段描述符占 8 个字节。\nGDTR寄存器存放GDT表的基地址和表长界限(高32位存放GDT基址，低16为存放GDT限长)。指令LGDT和SGDT分别用于加载和保存GDTR寄存器的内容。在机器刚加电或处理器复位后，基地址被默认地设置为0，而长度值被设置成0xFFFF。在保护模式初始化过程中必须给GDTR加载一个新值。\n段选择子(Segement Selector) 由GDTR访问全局描述符表是通过“段选择子”(实模式下的段寄存器)来完成的。段选择子是一个16位的寄存器(同实模式下的段寄存器相同)。\n段选择子共16bit，由三部分组成: 描述符索引(index)、TI、请求特权级(RPL)  描述符索引(index): 在描述符表中定位一个段描述符。 TI: 描述符表指示器， TI＝0 时，表示描述符在 GDT 中； TI＝1 时，描述符在 LDT 中。 RPL: 请求特权级，表示给出当前选择子访问的内存段的特权级别。每一个段都有一个特定的级别。每当一个程序试图访问某一个段时，就将该程序所拥有的特权级与要访问的特权级进行比较，以决定能否访问该段。系统约定，CPU只能访问同一特权级或级别较低特权级的段。  因为每个描述符占 8 字节，因此描述符在表内的偏移地址是索引号乘以 8 处理器在执行任何改变段选择器的指令时(比如 pop、 mov、jmp far、 call far、 iret、 retf)，就将指令中提供的索引号乘以 8 作为偏移地址，同 GDTR 中提供的线性基地址相加，以访问 GDT。在表内找到的描述符，并加载到不可见的描述符高速缓存部分。此后每当有访问内存的指令时，就不再访问 GDT 中的描述符，直接用当前段寄存器描述符高速缓存器提供线性基地址。\n段描述符(Segment Descriptor) 每个段描述符占 8 个字节。由三部分组成: 线性基地址、段界限和段的访问属性。\n    G: 粒度位，用于解释段界限的含义。当 G 位是\u0026quot;0\u0026quot;时，段界限以字节为单位。此时，段的扩展范围是从 1 字节到 1 兆字节（ 1B～1MB），因为描述符中的界限值是 20 位的。相反，如果该位是\u0026quot;1\u0026quot;，那么，段界限是以 4KB 为单位的。这样，段的扩展范围是从 4KB到 4GB。","title":"GDT\u0026LDT"},{"content":"func Home() (string, error) { user, err := user.Current() if nil == err { return user.HomeDir, nil } // cross compile support  if runtime.GOOS == \u0026#34;windows\u0026#34; { return homeWindows() } // Unix-like system, so just assume Unix  return homeUnix() } func homeUnix() (string, error) { // First prefer the HOME environmental variable  if home := os.Getenv(\u0026#34;HOME\u0026#34;); home != \u0026#34;\u0026#34; { return home, nil } // If that fails, try the shell  var stdout bytes.Buffer cmd := exec.Command(\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;eval echo ~$USER\u0026#34;) cmd.Stdout = \u0026amp;stdout if err := cmd.Run(); err != nil { return \u0026#34;\u0026#34;, err } result := strings.TrimSpace(stdout.String()) if result == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;blank output when reading home directory\u0026#34;) } return result, nil } func homeWindows() (string, error) { drive := os.Getenv(\u0026#34;HOMEDRIVE\u0026#34;) path := os.Getenv(\u0026#34;HOMEPATH\u0026#34;) home := drive + path if drive == \u0026#34;\u0026#34; || path == \u0026#34;\u0026#34; { home = os.Getenv(\u0026#34;USERPROFILE\u0026#34;) } if home == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;HOMEDRIVE, HOMEPATH, and USERPROFILE are blank\u0026#34;) } return home, nil } ","permalink":"https://rx-78-kum0.github.io/posts/%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7home%E7%9B%AE%E5%BD%95%E8%B7%AF%E5%BE%84/","summary":"func Home() (string, error) { user, err := user.Current() if nil == err { return user.HomeDir, nil } // cross compile support  if runtime.GOOS == \u0026#34;windows\u0026#34; { return homeWindows() } // Unix-like system, so just assume Unix  return homeUnix() } func homeUnix() (string, error) { // First prefer the HOME environmental variable  if home := os.Getenv(\u0026#34;HOME\u0026#34;); home != \u0026#34;\u0026#34; { return home, nil } // If that fails, try the shell  var stdout bytes.","title":"获取用户home目录路径"},{"content":"标签(Label) 指向一大块的首地址。使用方法: LABEL_NAME: XXX XXX\n局部Label 以(点)开头，比如.begin，.1，.2。在不同的段中可以使用相同的带点开头的LABEL，不能重复。最好只用在代码段中。\n变量 函数变量 指的是一个SUB_RUTIN的首地址。比如DispStr，使用的时候是call DispStr，然后在声明时候因为它本来就是一个地址，就是用上面标签的同样的声明方式。 DispStr:（注意后面有冒号）\n普通变量 使用equ生成的纯的变量(宏) 比如：TopOfStack equ $ - LABEL_STACK - 1\n使用db dd dw生成的变量(地址) 生成的各种变量分别指向的是不同的数据类型(冒号可加可不加) 比如： _dwDispPos: dd (80 * 6 + 0) * 2\n","permalink":"https://rx-78-kum0.github.io/posts/%E5%8F%98%E9%87%8F%E5%92%8C%E6%A0%87%E7%AD%BE/","summary":"标签(Label) 指向一大块的首地址。使用方法: LABEL_NAME: XXX XXX\n局部Label 以(点)开头，比如.begin，.1，.2。在不同的段中可以使用相同的带点开头的LABEL，不能重复。最好只用在代码段中。\n变量 函数变量 指的是一个SUB_RUTIN的首地址。比如DispStr，使用的时候是call DispStr，然后在声明时候因为它本来就是一个地址，就是用上面标签的同样的声明方式。 DispStr:（注意后面有冒号）\n普通变量 使用equ生成的纯的变量(宏) 比如：TopOfStack equ $ - LABEL_STACK - 1\n使用db dd dw生成的变量(地址) 生成的各种变量分别指向的是不同的数据类型(冒号可加可不加) 比如： _dwDispPos: dd (80 * 6 + 0) * 2","title":"变量和标签"},{"content":"Mac   首先需安装cmake和llvm\nbrew install cmake llvm   emacs里执行M-x irony-install-server得到安装执行命令\ncmake -DCMAKE_INSTALL_PREFIX\\=/Users/kumotyou/.emacs.d/irony/ \\ /Users/kumotyou/.emacs.d/elpa/irony-20200130.849/server \\ \u0026amp;\u0026amp; cmake --build . --use-stderr --config Release --target install   添加环境变量\n-DCMAKE_PREFIX_PATH=/usr/local/opt/llvm -DCMAKE_INSTALL_RPATH_USE_LINK_PATH=ON -DLIBCLANG_INCLUDE_DIR=/usr/local/opt/llvm/include -DLIBCLANG_LIBRARY=/usr/local/opt/llvm/lib/libclang.dylib   最终编译命令\ncmake -DCMAKE_INSTALL_PREFIX\\=/Users/kumotyou/.emacs.d/irony/ \\ -DCMAKE_PREFIX_PATH=/usr/local/opt/llvm \\ -DCMAKE_INSTALL_RPATH_USE_LINK_PATH=ON \\ -DLIBCLANG_INCLUDE_DIR=/usr/local/opt/llvm/include \\ -DLIBCLANG_LIBRARY=/usr/local/opt/llvm/lib/libclang.dylib \\ /Users/kumotyou/.emacs.d/elpa/irony-20200130.849/server \\ \u0026amp;\u0026amp; cmake --build . --use-stderr --config Release --target install   Ubuntu   拉取ccls源码, 并进入ccls根目录\ngit clone https://github.com/MaskRay/ccls cd ccls   拉取第三方依赖. (主要是rapidjson)\ngit submodule update --init --recursive   下载llvm的二进制包并解压\nwget -c http://releases.llvm.org/9.0.0/clang+llvm-9.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz tar xf clang+llvm-9.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz   在根目录下执行cmake 执行结果保存到Release文件夹中\ncmake -H. -BRelease -DCMAKE_BUILD_TYPE=Release -DCMAKE_PREFIX_PATH=/path/to/clang+llvm-9.0.0-x86_64-linux-gnu-ubuntu-18.04 cmake --build Release   开始编译\ncd Release make -j4 #使用4线程编译   编译完成, 安装\nsudo make install   ","permalink":"https://rx-78-kum0.github.io/posts/irony-server-install/","summary":"Mac   首先需安装cmake和llvm\nbrew install cmake llvm   emacs里执行M-x irony-install-server得到安装执行命令\ncmake -DCMAKE_INSTALL_PREFIX\\=/Users/kumotyou/.emacs.d/irony/ \\ /Users/kumotyou/.emacs.d/elpa/irony-20200130.849/server \\ \u0026amp;\u0026amp; cmake --build . --use-stderr --config Release --target install   添加环境变量\n-DCMAKE_PREFIX_PATH=/usr/local/opt/llvm -DCMAKE_INSTALL_RPATH_USE_LINK_PATH=ON -DLIBCLANG_INCLUDE_DIR=/usr/local/opt/llvm/include -DLIBCLANG_LIBRARY=/usr/local/opt/llvm/lib/libclang.dylib   最终编译命令\ncmake -DCMAKE_INSTALL_PREFIX\\=/Users/kumotyou/.emacs.d/irony/ \\ -DCMAKE_PREFIX_PATH=/usr/local/opt/llvm \\ -DCMAKE_INSTALL_RPATH_USE_LINK_PATH=ON \\ -DLIBCLANG_INCLUDE_DIR=/usr/local/opt/llvm/include \\ -DLIBCLANG_LIBRARY=/usr/local/opt/llvm/lib/libclang.dylib \\ /Users/kumotyou/.emacs.d/elpa/irony-20200130.849/server \\ \u0026amp;\u0026amp; cmake --build . --use-stderr --config Release --target install   Ubuntu   拉取ccls源码, 并进入ccls根目录\ngit clone https://github.com/MaskRay/ccls cd ccls   拉取第三方依赖.","title":"irony-server-install"},{"content":"############################################################### # Configuration file for Bochs ############################################################### # how much memory the emulated machine will have megs: 32 # filename of ROM images romimage: file=/usr/local/share/bochs/BIOS-bochs-latest vgaromimage: file=/usr/local/share/bochs/VGABIOS-lgpl-latest # what disk images will be used floppya: 1_44=a.img, status=inserted # choose the boot disk. boot: floppy # where do we send log messages? # log: bochsout.txt # disable the mouse mouse: enabled=0 # enable key mapping, using US layout as default. # keyboard_mapping: enabled=1, map=/usr/local/share/bochs/keymaps/x11-pc-us.map keyboard: keymap=/usr/local/share/bochs/keymaps/x11-pc-us.map ","permalink":"https://rx-78-kum0.github.io/posts/bochsrc/","summary":"############################################################### # Configuration file for Bochs ############################################################### # how much memory the emulated machine will have megs: 32 # filename of ROM images romimage: file=/usr/local/share/bochs/BIOS-bochs-latest vgaromimage: file=/usr/local/share/bochs/VGABIOS-lgpl-latest # what disk images will be used floppya: 1_44=a.img, status=inserted # choose the boot disk. boot: floppy # where do we send log messages? # log: bochsout.txt # disable the mouse mouse: enabled=0 # enable key mapping, using US layout as default. # keyboard_mapping: enabled=1, map=/usr/local/share/bochs/keymaps/x11-pc-us.","title":"bochsrc"},{"content":"ld: dynamic main executables must link with libSystem.dylib for architecture x86_64 # -lSystem ld a.o -o a -lSystem ","permalink":"https://rx-78-kum0.github.io/posts/mac%E7%BC%96%E8%AF%91nasm%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/","summary":"ld: dynamic main executables must link with libSystem.dylib for architecture x86_64 # -lSystem ld a.o -o a -lSystem ","title":"mac编译nasm问题汇总"},{"content":" 汇编语言和CPU息息相关，但是不能把汇编语言完全等同于CPU的机器指令。不同架构的CPU指令并不相同，如x86，powerpc，arm各有各的指令系统；甚至同一种架构的CPU有几套指令集，典型的如arm除了有32位的指令集外，还有一套16位的thumb指令集。但是作为开发语言的汇编，本质上是一套语法规则和助记符的集合，它可以包容不同的指令集。如果从CPU体系来划分，常见的汇编有两种：IBM PC汇编和ARM汇编。 IBM PC汇编也就是Intel的汇编，因为IBM 最早推出PC机，后来的体系很多都要和它兼容，所以也使用了相同的汇编语言。ARM压根没考虑过兼容，它的指令集和x86完全是两个体系，所以汇编语言也独立发展出一套。 CPU只是限定了机器码，作为开发语言的汇编，其实还和编译器息息相关。汇编语言出现的早，没有像C语言一样定义出标准，所以编译器的厂商各搞一套。到现在，最有名的也是两家：MASM和GNU ASM。前者是微软的，只支持x86，用在DOS/Windows平台中；后者是开源产品，主要用在Linux中，基本上支持大部分的CPU架构。这两者的区别在于伪指令的不同，伪指令是用来告诉编译器如何工作的，和编译器相关，和CPU无关。其实汇编的编译相当简单，这两套伪指令只是符号不相同，含义是大同小异，明白了一种，看另一种就很容易了。\n CPU体系分类  IBM PC汇编 ARM汇编  汇编格式分类 Intel格式 windows平台常见，后者最早由贝尔实验室推出，用于Unix中\nAT\u0026amp;T格式 GUN汇编器的缺省格式\n GNU的汇编器和调试器gdb对这两种格式都支持，可以随便切换。MASM只支持Intel格式。Intel格式和AT\u0026amp;T格式的区别只是符号系统的区别，这与x86和arm的区别可不一样，后者是CPU体系的区别。\n内嵌汇编 用于C语言和汇编语言混合编程的，所以和编译器也关系紧密。\n GNU的内嵌汇编 (不是很容易看懂，需要专门学习) MASM的内嵌汇编 (MASM的内嵌汇编和普通汇编的区别则不大)  ","permalink":"https://rx-78-kum0.github.io/posts/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A7%8D%E7%B1%BB/","summary":" 汇编语言和CPU息息相关，但是不能把汇编语言完全等同于CPU的机器指令。不同架构的CPU指令并不相同，如x86，powerpc，arm各有各的指令系统；甚至同一种架构的CPU有几套指令集，典型的如arm除了有32位的指令集外，还有一套16位的thumb指令集。但是作为开发语言的汇编，本质上是一套语法规则和助记符的集合，它可以包容不同的指令集。如果从CPU体系来划分，常见的汇编有两种：IBM PC汇编和ARM汇编。 IBM PC汇编也就是Intel的汇编，因为IBM 最早推出PC机，后来的体系很多都要和它兼容，所以也使用了相同的汇编语言。ARM压根没考虑过兼容，它的指令集和x86完全是两个体系，所以汇编语言也独立发展出一套。 CPU只是限定了机器码，作为开发语言的汇编，其实还和编译器息息相关。汇编语言出现的早，没有像C语言一样定义出标准，所以编译器的厂商各搞一套。到现在，最有名的也是两家：MASM和GNU ASM。前者是微软的，只支持x86，用在DOS/Windows平台中；后者是开源产品，主要用在Linux中，基本上支持大部分的CPU架构。这两者的区别在于伪指令的不同，伪指令是用来告诉编译器如何工作的，和编译器相关，和CPU无关。其实汇编的编译相当简单，这两套伪指令只是符号不相同，含义是大同小异，明白了一种，看另一种就很容易了。\n CPU体系分类  IBM PC汇编 ARM汇编  汇编格式分类 Intel格式 windows平台常见，后者最早由贝尔实验室推出，用于Unix中\nAT\u0026amp;T格式 GUN汇编器的缺省格式\n GNU的汇编器和调试器gdb对这两种格式都支持，可以随便切换。MASM只支持Intel格式。Intel格式和AT\u0026amp;T格式的区别只是符号系统的区别，这与x86和arm的区别可不一样，后者是CPU体系的区别。\n内嵌汇编 用于C语言和汇编语言混合编程的，所以和编译器也关系紧密。\n GNU的内嵌汇编 (不是很容易看懂，需要专门学习) MASM的内嵌汇编 (MASM的内嵌汇编和普通汇编的区别则不大)  ","title":"汇编语言种类"},{"content":"docker-compose 配置 version: \u0026#39;3\u0026#39; services: # mysql blog_mysql: image: mysql restart: always ports: - \u0026#39;3306:3306\u0026#39; environment: - MYSQL_ROOT_PASSWORD=xxxx volumes: - \u0026#39;/data/mysql:/var/lib/mysql\u0026#39; docker 安装完mysql 后客户端无法访问 进入镜像中的mysql docker exec -it container_id /bin/bash 登录mysql mysql -u root -p 修改root账号, 可以通过任何客户端连接 ALTER USER \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;xxxxx\u0026#39;; ","permalink":"https://rx-78-kum0.github.io/posts/docker%E9%83%A8%E7%BD%B2mysql%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/","summary":"docker-compose 配置 version: \u0026#39;3\u0026#39; services: # mysql blog_mysql: image: mysql restart: always ports: - \u0026#39;3306:3306\u0026#39; environment: - MYSQL_ROOT_PASSWORD=xxxx volumes: - \u0026#39;/data/mysql:/var/lib/mysql\u0026#39; docker 安装完mysql 后客户端无法访问 进入镜像中的mysql docker exec -it container_id /bin/bash 登录mysql mysql -u root -p 修改root账号, 可以通过任何客户端连接 ALTER USER \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;xxxxx\u0026#39;; ","title":"docker部署mysql问题汇总"},{"content":".flex { flex-shrink: 0; } ","permalink":"https://rx-78-kum0.github.io/posts/flex%E5%AE%BD%E5%BA%A6%E5%A4%B1%E6%95%88/","summary":".flex { flex-shrink: 0; } ","title":"flex宽度失效"},{"content":"context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);  img 规定要使用的图像, 画布或视频. sx 可选. 开始剪切的 x 坐标位置. sy 可选. 开始剪切的 y 坐标位置. swidth 可选. 被剪切图像的宽度. sheight 可选. 被剪切图像的高度. x 在画布上放置图像的 x 坐标位置. y 在画布上放置图像的 y 坐标位置. width 可选. 要使用的图像的宽度.(伸展或缩小图像) height 可选. 要使用的图像的高度.(伸展或缩小图像)  ","permalink":"https://rx-78-kum0.github.io/posts/canvas-drawimage/","summary":"context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);  img 规定要使用的图像, 画布或视频. sx 可选. 开始剪切的 x 坐标位置. sy 可选. 开始剪切的 y 坐标位置. swidth 可选. 被剪切图像的宽度. sheight 可选. 被剪切图像的高度. x 在画布上放置图像的 x 坐标位置. y 在画布上放置图像的 y 坐标位置. width 可选. 要使用的图像的宽度.(伸展或缩小图像) height 可选. 要使用的图像的高度.(伸展或缩小图像)  ","title":"canvas-drawImage"},{"content":"#!/usr/bin/env bash  # Print nyan cat # https://github.com/steckel/Git-Nyan-Graph/blob/master/nyan.sh # If you want big animated version: `telnet miku.acm.uiuc.edu` e=\u0026#39;\\033\u0026#39; RESET=\u0026#34;$e[0m\u0026#34; BOLD=\u0026#34;$e[1m\u0026#34; CYAN=\u0026#34;$e[0;96m\u0026#34; RED=\u0026#34;$e[0;91m\u0026#34; YELLOW=\u0026#34;$e[0;93m\u0026#34; GREEN=\u0026#34;$e[0;92m\u0026#34; echo if [ $[$RANDOM%2] -eq \u0026#34;0\u0026#34; ]; then echo -en $RED\u0026#39;`·.,¸,.·*·.\u0026#39; echo -e $RESET$BOLD\u0026#39;╭━━━━╮\u0026#39;$RESET echo -en $YELLOW\u0026#39;`·.,¸,.·*·.\u0026#39; echo -e $RESET$BOLD\u0026#39;|::: /\\_/\\\\\u0026#39;$RESET echo -en $GREEN\u0026#39;`·.,¸,.·*·.\u0026#39; echo -e $RESET$BOLD\u0026#39;|:::( ◕ᴥ◕)\u0026#39;$RESET echo -en $CYAN\u0026#39;`·.,¸,.·*·.\u0026#39; echo -e $RESET$BOLD\u0026#39;u-u━━-u--u\u0026#39;$RESET else echo -en $RED\u0026#39;-_-_-_-_-_-_-_\u0026#39; echo -e $RESET$BOLD\u0026#39;,------,\u0026#39;$RESET echo -en $YELLOW\u0026#39;_-_-_-_-_-_-_-\u0026#39; echo -e $RESET$BOLD\u0026#39;| /\\_/\\\\\u0026#39;$RESET echo -en $GREEN\u0026#39;-_-_-_-_-_-_-\u0026#39; echo -e $RESET$BOLD\u0026#39;~|__( ^ .^)\u0026#39;$RESET echo -en $CYAN\u0026#39;-_-_-_-_-_-_-\u0026#39; echo -e $RESET$BOLD\u0026#39;\u0026#34;\u0026#34; \u0026#34;\u0026#34;\u0026#39;$RESET fi echo   ","permalink":"https://rx-78-kum0.github.io/posts/nyan/","summary":"#!/usr/bin/env bash  # Print nyan cat # https://github.com/steckel/Git-Nyan-Graph/blob/master/nyan.sh # If you want big animated version: `telnet miku.acm.uiuc.edu` e=\u0026#39;\\033\u0026#39; RESET=\u0026#34;$e[0m\u0026#34; BOLD=\u0026#34;$e[1m\u0026#34; CYAN=\u0026#34;$e[0;96m\u0026#34; RED=\u0026#34;$e[0;91m\u0026#34; YELLOW=\u0026#34;$e[0;93m\u0026#34; GREEN=\u0026#34;$e[0;92m\u0026#34; echo if [ $[$RANDOM%2] -eq \u0026#34;0\u0026#34; ]; then echo -en $RED\u0026#39;`·.,¸,.·*·.\u0026#39; echo -e $RESET$BOLD\u0026#39;╭━━━━╮\u0026#39;$RESET echo -en $YELLOW\u0026#39;`·.,¸,.·*·.\u0026#39; echo -e $RESET$BOLD\u0026#39;|::: /\\_/\\\\\u0026#39;$RESET echo -en $GREEN\u0026#39;`·.,¸,.·*·.\u0026#39; echo -e $RESET$BOLD\u0026#39;|:::( ◕ᴥ◕)\u0026#39;$RESET echo -en $CYAN\u0026#39;`·.,¸,.·*·.\u0026#39; echo -e $RESET$BOLD\u0026#39;u-u━━-u--u\u0026#39;$RESET else echo -en $RED\u0026#39;-_-_-_-_-_-_-_\u0026#39; echo -e $RESET$BOLD\u0026#39;,------,\u0026#39;$RESET echo -en $YELLOW\u0026#39;_-_-_-_-_-_-_-\u0026#39; echo -e $RESET$BOLD\u0026#39;| /\\_/\\\\\u0026#39;$RESET echo -en $GREEN\u0026#39;-_-_-_-_-_-_-\u0026#39; echo -e $RESET$BOLD\u0026#39;~|__( ^ .","title":"nyan"},{"content":"// js 表情emoji转码 // 发送请求时将uft16转为utf-8 function utf16toEntities(str) { var patt = /[\\ud800-\\udbff][\\udc00-\\udfff]/g; // 检测utf16字符正则  return str.replace(patt, function(char) { var H, L, code; if (char.length === 2) { H = char.charCodeAt(0); // 取出高位  L = char.charCodeAt(1); // 取出低位  code = (H - 0xd800) * 0x400 + 0x10000 + L - 0xdc00; // 转换算法  return \u0026#39;\u0026amp;#\u0026#39; + code + \u0026#39;;\u0026#39;; } else { return char; } }); } // 收到后端的数据时展示emoji function entitiesToUtf16(str) { return str.replace(/\u0026amp;#(\\d+);/g, function(match, dec) { let H = Math.floor((dec - 0x10000) / 0x400) + 0xd800; let L = (Math.floor(dec - 0x10000) % 0x400) + 0xdc00; return String.fromCharCode(H, L); }); } ","permalink":"https://rx-78-kum0.github.io/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BAemoji/","summary":"// js 表情emoji转码 // 发送请求时将uft16转为utf-8 function utf16toEntities(str) { var patt = /[\\ud800-\\udbff][\\udc00-\\udfff]/g; // 检测utf16字符正则  return str.replace(patt, function(char) { var H, L, code; if (char.length === 2) { H = char.charCodeAt(0); // 取出高位  L = char.charCodeAt(1); // 取出低位  code = (H - 0xd800) * 0x400 + 0x10000 + L - 0xdc00; // 转换算法  return \u0026#39;\u0026amp;#\u0026#39; + code + \u0026#39;;\u0026#39;; } else { return char; } }); } // 收到后端的数据时展示emoji function entitiesToUtf16(str) { return str.","title":"浏览器显示emoji"},{"content":"Go 语言与鸭子类型的关系  If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.\n如果某个东西长得像鸭子, 像鸭子一样游泳, 像鸭子一样嘎嘎叫, 那它就可以被看成是一只鸭子.\n在 Go 语言中, 如果类型的方法集完全包含接口的方法集，则可认为该类型实现了该接口.\n 鸭子类型是一种动态语言的风格, 在这种风格中, 一个对象有效的语义, 不是由继承自特定的类或实现特定的接口, 而是由它\u0026quot;当前方法和属性的集合\u0026quot;决定. Go 作为一种静态语言, 通过接口实现了 鸭子类型, 实际上是 Go 的编译器在其中作了隐匿的转换工作.\n值接收者和指针接收者的区别 package main import \u0026#34;fmt\u0026#34; type Person struct { age int } func (p Person) howOld() int { return p.age } func (p *Person) growUp() { p.age += 1 } func main() { // qcrao 是值类型  qcrao := Person{age: 18} // 值类型 调用接收者也是值类型的方法  fmt.Println(qcrao.howOld()) // 值类型 调用接收者是指针类型的方法  qcrao.growUp() fmt.Println(qcrao.howOld()) // ----------------------  // stefno 是指针类型  stefno := \u0026amp;Person{age: 100} // 指针类型 调用接收者是值类型的方法  fmt.Println(stefno.howOld()) // 指针类型 调用接收者也是指针类型的方法  stefno.growUp() fmt.Println(stefno.howOld()) }    - 值接收者 指针接收者     值类型调用者 方法会使用调用者的一个副本，类似于\u0026quot;传值\u0026quot; 使用值的引用来调用方法, 上例中 qcrao.growUp() 实际上是 (\u0026amp;qcrao).growUp()   指针类型调用者 指针被解引用为值, 上例中, stefno.howOld() 实际上是 (*stefno).howOld() 实际上也是\u0026quot;传值\u0026quot;, 方法里的操作会影响到调用者, 类似于指针传参, 拷贝了一份指针    区别 如果方法的接收者是值类型, 无论调用者是对象还是对象指针, 修改的都是对象的副本, 不影响调用者; 如果方法的接收者是指针类型, 则调用者修改的是指针指向的对象本身.\n使用值接收者还是指针接收者, 不是由该方法是否修改了调用者 (也就是接收者) 来决定, 而是应该基于该类型的本质.\n 如果类型具备\u0026quot;原始的本质\u0026quot;, 也就是说它的成员都是由 Go 语言里内置的原始类型, 如字符串, 整型值等, 那就定义值接收者类型的方法. 像内置的引用类型, 如 slice, map, interface, channel, 这些类型比较特殊, 声明他们的时候, 实际上是创建了一个 header, 对于他们也是直接定义值接收者类型的方法. 这样, 调用函数时, 是直接 copy 了这些类型的 header, 而 header 本身就是为复制设计的. 如果类型具备非原始的本质, 不能被安全地复制, 这种类型总是应该被共享, 那就定义指针接收者的方法. 比如 go 源码里的文件结构体 (struct File) 就不应该被复制, 应该只有一份实体.  iface 和 eface 的区别 iface 和 eface 都是 Go 中描述接口的底层结构体, 区别在于 iface 描述的接口包含方法, 而 eface 则是不包含任何方法的空接口: interface{}.\niface import \u0026#34;unsafe\u0026#34; type iface struct { tab *itab // 接口类型以及实际类型  data unsafe.Pointer // 接口具体的值, 一般而言是一个指向堆内存的指针 } type itab struct { inter *interfacetype _type *_type hash uint32 // copy of _type.hash. Used for type switches.  _ [4]byte fun [1]uintptr // variable sized. 存储的是第一个方法的函数指针，如果有更多的方法，在它之后的内存空间里继续存储. } type interfacetype struct { typ _type pkgpath name mhdr []imethod } type _type struct { // 类型大小  size uintptr ptrdata uintptr // 类型的 hash 值  hash uint32 // 类型的 flag，和反射相关  tflag tflag // 内存对齐相关  align uint8 fieldalign uint8 // 类型的编号，有bool, slice, struct 等等等等  kind uint8 equal func(unsafe.Pointer, unsafe.Pointer) bool // gc 相关  gcdata *byte str nameOff ptrToThis typeOff }   eface type eface struct { _type *_type data unsafe.Pointer } _type _type 是描述 Go 语言中各种数据类型的结构体\ntype _type struct { // 类型大小  size uintptr ptrdata uintptr // 类型的 hash 值  hash uint32 // 类型的 flag，和反射相关  tflag tflag // 内存对齐相关  align uint8 fieldalign uint8 // 类型的编号，有bool, slice, struct 等等等等  kind uint8 equal func(unsafe.Pointer, unsafe.Pointer) bool // gc 相关  gcdata *byte str nameOff ptrToThis typeOff } Go 语言各种数据类型都是在 _type 字段的基础上, 增加一些额外的字段来进行管理的:\ntype arraytype struct { typ _type elem *_type slice *_type len uintptr } type chantype struct { typ _type elem *_type dir uintptr } type slicetype struct { typ _type elem *_type } type functype struct { typ _type inCount uint16 outCount uint16 } type ptrtype struct { typ _type elem *_type } type structfield struct { name name typ *_type offsetAnon uintptr } 这些数据类型的结构体定义, 是反射实现的基础.\n接口的动态类型和动态值 import \u0026#34;unsafe\u0026#34; type iface struct { tab *itab // 接口类型以及实际类型  data unsafe.Pointer // 接口具体的值, 一般而言是一个指向堆内存的指针 } iface 类型包含两个字段:\n tab: 是接口表指针，指向类型信息 data: 是数据指针，则指向具体的数据  接口类型和 nil 作比较 接口值的零值是指动态类型和动态值都为 nil, 这个接口才能被认为 接口值 == nil.\n  package main import \u0026#34;fmt\u0026#34; func main() { var a interface{} fmt.Println(c == nil) // true  var b *string fmt.Println(b == nil) // true  a = b fmt.Println(a == nil) // false } b 赋值给 a 后, a 的动态类型为 *string , 动态值为 nil , 所以 a == nil 为 false .\n  package main import \u0026#34;fmt\u0026#34; type MyError string func (i MyError) Error() string { return i } func main() { err := HandleError() fmt.Println(err == nil) // false } func HandleError() error { var err *MyError = nil return err } 调用 HandleError 返回 error 接口类型, 动态类型为 *MyError , 动态值为 nil .\n  打印接口的动态值和类型 package main import ( \u0026#34;unsafe\u0026#34; \u0026#34;fmt\u0026#34; ) type iface struct { itab, data uintptr } func main() { var a interface{} = nil var b interface{} = (*int)(nil) x := 5 var c interface{} = (*int)(\u0026amp;x) ia := *(*iface)(unsafe.Pointer(\u0026amp;a)) ib := *(*iface)(unsafe.Pointer(\u0026amp;b)) ic := *(*iface)(unsafe.Pointer(\u0026amp;c)) fmt.Println(ia) // {0 0}  fmt.Println(ib) // {17426912 0}  fmt.Println(ic) // {17426912 842350714568}  fmt.Println(*(*int)(unsafe.Pointer(ic.data))) // 5 }  a 的动态类型和动态值的地址均为 0, 也就是 nil; b 的动态类型和 c 的动态类型一致, 都是 *int; c 的动态值为 5.  编译器自动检测类型是否实现接口 var _ io.Writer = (*myWriter)(nil) 编译器会由此检查 *myWriter 类型是否实现了 io.Writer 接口.\npackage main import \u0026#34;io\u0026#34; type myWriter string func (w *myWriter) Write(p []byte) (n int, err error) { return } func main() { // 检查 *myWriter 类型是否实现了 io.Writer 接口  var _ io.Writer = (*myWriter)(nil) // 检查 myWriter 类型是否实现了 io.Writer 接口  var _ io.Writer = myWriter{} } src/main.go:15:6: cannot use myWriter literal (type myWriter) as type io.Writer in assignment: myWriter does not implement io.Writer (missing Write method) myWriter 没用实现 io.Writer\n接口类型的赋值 (构造) 和断言 赋值 针对不同类型有以下函数:\n convT2E16, convT2I16 convT2E32, convT2I32 convT2E64, convT2I64 convT2Estring, convT2Istring convT2Eslice, convT2Islice convT2Enoptr, convT2Inoptr\n func convT2I(tab *itab, elem unsafe.Pointer) (i iface) { t := tab._type if raceenabled { raceReadObjectPC(t, elem, getcallerpc(), funcPC(convT2I)) } if msanenabled { msanread(elem, t.size) } x := mallocgc(t.size, t, true) typedmemmove(t, x, elem) i.tab = tab i.data = x return } 把 tab 赋给了 iface 的 tab 字段; data 部分则是在堆上申请了一块内存, 然后将 elem 指向的数据拷贝过去.\n断言 func assertI2I(inter *interfacetype, i iface) (r iface) { tab := i.tab if tab == nil { // explicit conversions require non-nil interface value.  panic(\u0026amp;TypeAssertionError{nil, nil, \u0026amp;inter.typ, \u0026#34;\u0026#34;}) } if tab.inter == inter { r.tab = tab r.data = i.data return } r.tab = getitab(inter, tab._type, false) r.data = i.data return } func assertI2I2(inter *interfacetype, i iface) (r iface, b bool) { tab := i.tab if tab == nil { return } if tab.inter != inter { tab = getitab(inter, tab._type, true) if tab == nil { return } } r.tab = tab r.data = i.data b = true return } func assertE2I(inter *interfacetype, e eface) (r iface) { t := e._type if t == nil { // explicit conversions require non-nil interface value.  panic(\u0026amp;TypeAssertionError{nil, nil, \u0026amp;inter.typ, \u0026#34;\u0026#34;}) } r.tab = getitab(inter, t, false) r.data = e.data return } func assertE2I2(inter *interfacetype, e eface) (r iface, b bool) { t := e._type if t == nil { return } tab := getitab(inter, t, true) if tab == nil { return } r.tab = tab r.data = e.data b = true return } 判断需断言的变量 (iface) 是否满足接口类型 (interfacetype).\nassertI2I 对应 接口断言返回一个参数:\npackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) func main(args) { var a interface{} = errors.New(\u0026#34;error\u0026#34;) err := a.(error) fmt.Println(err.Error()) } assertI2I2 则对应返回两个参数的情况:\npackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) func main(args) { var a interface{} = errors.New(\u0026#34;error\u0026#34;) if err, ok := a.(error); ok { fmt.Println(err.Error()) } } 都在编译阶段编译器判断.\n打印接口类型的hash值 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) type iface struct { tab *itab data unsafe.Pointer } type itab struct { inter uintptr _type uintptr hash uint32 _ [4]byte fun [1]uintptr } func main() { p := Person(Student{age: 18}) iface := (*iface)(unsafe.Pointer(\u0026amp;p)) fmt.Printf(\u0026#34;iface.tab.hash = %#x\\n\u0026#34;, iface.tab.hash) // iface.tab.hash = 0xd4209fda } 类型转换和断言的区别 类型转换 Go 语言中不允许隐式类型转换, 也就是说 = 两边, 不允许出现类型不相同的变量. 类型转换前后的两个类型必须相互兼容.\n \u0026lt;结果类型\u0026gt; := \u0026lt;目标类型\u0026gt; ( \u0026lt;表达式\u0026gt; )\n package main import \u0026#34;fmt\u0026#34; func main() { var i int = 9 var f float64 f = float64(i) fmt.Printf(\u0026#34;%T, %v\\n\u0026#34;, f, f) f = 10.8 a := int(f) fmt.Printf(\u0026#34;%T, %v\\n\u0026#34;, a, a) // s := []int(i) } 断言 空接口 interface{} 没有定义任何函数, 因此 Go 中所有类型都实现了空接口. 当一个函数的形参是 interface{}, 那么在函数中, 需要对形参进行断言, 从而得到它的真实类型.\n \u0026lt;目标类型的值\u0026gt;，\u0026lt;布尔参数\u0026gt; := \u0026lt;表达式\u0026gt;.( 目标类型 ) // 安全类型断言 \u0026lt;目标类型的值\u0026gt; := \u0026lt;表达式\u0026gt;.( 目标类型 )　//非安全类型断言\n package main import \u0026#34;fmt\u0026#34; type Student struct { Name string Age int } func main() { var i interface{} = new(Student) s := i.(*Student) fmt.Println(s) } switch 形式断言\npackage main import \u0026#34;fmt\u0026#34; type Student struct { Name string Age int } func main() { var i interface{} judge(i) } func judge(v interface{}) { fmt.Printf(\u0026#34;%p %v\\n\u0026#34;, \u0026amp;v, v) switch v := v.(type) { case nil: fmt.Printf(\u0026#34;%p %v\\n\u0026#34;, \u0026amp;v, v) fmt.Printf(\u0026#34;nil type[%T] %v\\n\u0026#34;, v, v) case Student: fmt.Printf(\u0026#34;%p %v\\n\u0026#34;, \u0026amp;v, v) fmt.Printf(\u0026#34;Student type[%T] %v\\n\u0026#34;, v, v) case *Student: fmt.Printf(\u0026#34;%p %v\\n\u0026#34;, \u0026amp;v, v) fmt.Printf(\u0026#34;*Student type[%T] %v\\n\u0026#34;, v, v) default: fmt.Printf(\u0026#34;%p %v\\n\u0026#34;, \u0026amp;v, v) fmt.Printf(\u0026#34;unknow\\n\u0026#34;) } } fmt.Println 函数 fmt.Println 函数的参数是 interface{}. 对于内置类型, 函数内部会用穷举法, 得出它的真实类型, 然后转换为字符串打印. 而对于自定义类型, 首先确定该类型是否实现了 String() 方法. 如果实现了, 则直接打印输出 String() 方法的结果; 否则, 会通过反射来遍历对象的成员进行打印.\n因为 Student 结构体没有实现 String() 方法, 所以 fmt.Println 会利用反射挨个打印成员变量:\npackage main import \u0026#34;fmt\u0026#34; type Student struct { Name string Age int } func main() { s := Student{ Name: \u0026#34;zzz\u0026#34;, Age: 18, } fmt.Println(s) // {zzz 18} } 增加一个 String() 方法的实现:\nimport \u0026#34;fmt\u0026#34; func (s Student) String() string { return fmt.Sprintf(\u0026#34;[Name: %s], [Age: %d]\u0026#34;, s.Name, s.Age) // [Name: zzz], [Age: 18] } 修改 String() 方法:\nimport \u0026#34;fmt\u0026#34; func (s *Student) String() string { return fmt.Sprintf(\u0026#34;[Name: %s], [Age: %d]\u0026#34;, s.Name, s.Age) // {zzz 18} } 打印结果并没用调用 String() ,因为:\n 类型 T 只有接受者是 T 的方法; 而类型 *T 拥有接受者是 T 和 *T 的方法. 语法上 T 能直接调 *T 的方法仅仅是 Go 的语法糖.\n 要调用 String() 需要:\nfmt.Println(\u0026amp;s) 接口转换的原理 类型有 m 个方法, 某接口有 n 个方法, 则很容易知道这种判定的时间复杂度为 O(mn); Go 会对方法集的函数按照函数名的字典序进行排序, 所以实际的时间复杂度为 O(m+n).\npackage main import \u0026#34;fmt\u0026#34; type coder interface { code() run() } type runner interface { run() } type Gopher struct { language string } func (g Gopher) code() { return } func (g Gopher) run() { return } func main() { var c coder = Gopher{} var r runner r = c fmt.Println(c, r) } Gopher 类型同时满足 coder 接口和 runner 接口.\nconvI2I 函数将一个 interface 转换成 另一个 interface .\nfunc convI2I(inter *interfacetype, i iface) (r iface) { tab := i.tab if tab == nil { return } if tab.inter == inter { r.tab = tab r.data = i.data return } r.tab = getitab(inter, tab._type, false) r.data = i.data return } inter 表示要转成的接口类型, i 表示一个实体类型. 如果要转换的接口类型和实体类型的接口类型相同就直接返回; 否则就用调用 getitab 函数去匹配满转方法集的接口.\nimport \u0026#34;unsafe\u0026#34; func getitab(inter *interfacetype, typ *_type, canfail bool) *itab { if len(inter.mhdr) == 0 { throw(\u0026#34;internal error - misuse of itab\u0026#34;) } // easy case  if typ.tflag\u0026amp;tflagUncommon == 0 { if canfail { return nil } name := inter.typ.nameOff(inter.mhdr[0].name) panic(\u0026amp;TypeAssertionError{nil, typ, \u0026amp;inter.typ, name.name()}) } var m *itab // First, look in the existing table to see if we can find the itab we need.  // This is by far the most common case, so do it without locks.  // Use atomic to ensure we see any previous writes done by the thread  // that updates the itabTable field (with atomic.Storep in itabAdd).  t := (*itabTableType)(atomic.Loadp(unsafe.Pointer(\u0026amp;itabTable))) if m = t.find(inter, typ); m != nil { goto finish } // Not found. Grab the lock and try again.  lock(\u0026amp;itabLock) if m = itabTable.find(inter, typ); m != nil { unlock(\u0026amp;itabLock) goto finish } // Entry doesn\u0026#39;t exist yet. Make a new entry \u0026amp; add it.  m = (*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*sys.PtrSize, 0, \u0026amp;memstats.other_sys)) m.inter = inter m._type = typ // The hash is used in type switches. However, compiler statically generates itab\u0026#39;s  // for all interface/type pairs used in switches (which are added to itabTable  // in itabsinit). The dynamically-generated itab\u0026#39;s never participate in type switches,  // and thus the hash is irrelevant.  // Note: m.hash is _not_ the hash used for the runtime itabTable hash table.  m.hash = 0 m.init() itabAdd(m) unlock(\u0026amp;itabLock) finish: if m.fun[0] != 0 { return m } if canfail { return nil } // this can only happen if the conversion  // was already done once using the , ok form  // and we have a cached negative result.  // The cached result doesn\u0026#39;t record which  // interface function was missing, so initialize  // the itab again to get the missing function name.  panic(\u0026amp;TypeAssertionError{concrete: typ, asserted: \u0026amp;inter.typ, missingMethod: m.init()}) } getitab 函数会根据 interfacetype 和 _type 去全局的 itab 哈希表中查找, 如果能找到, 则直接返回; 否则, 会根据给定的 interfacetype 和 _type 新生成一个 itab, 并插入到 itab 哈希表, 这样下一次就可以直接拿到 itab.\n这里查找了两次, 并且第二次上锁了, 这是因为如果第一次没找到, 在第二次仍然没有找到相应的 itab 的情况下, 需要新生成一个, 并且写入哈希表, 因此需要加锁. 这样, 其他协程在查找相同的 itab 并且也没有找到时, 第二次查找时, 会被挂住, 之后, 就会查到第一个协程写入哈希表的 itab.\nitabAdd 函数会把 itab 写入到全局itabTable\nimport \u0026#34;unsafe\u0026#34; func itabAdd(m *itab) { // Bugs can lead to calling this while mallocing is set,  // typically because this is called while panicing.  // Crash reliably, rather than only when we need to grow  // the hash table.  if getg().m.mallocing != 0 { throw(\u0026#34;malloc deadlock\u0026#34;) } t := itabTable if t.count \u0026gt;= 3*(t.size/4) { // 75% load factor  // Grow hash table.  // t2 = new(itabTableType) + some additional entries  // We lie and tell malloc we want pointer-free memory because  // all the pointed-to values are not in the heap.  t2 := (*itabTableType)(mallocgc((2+2*t.size)*sys.PtrSize, nil, true)) t2.size = t.size * 2 // Copy over entries.  // Note: while copying, other threads may look for an itab and  // fail to find it. That\u0026#39;s ok, they will then try to get the itab lock  // and as a consequence wait until this copying is complete.  iterate_itabs(t2.add) if t2.count != t.count { throw(\u0026#34;mismatched count during itab table copy\u0026#34;) } // Publish new hash table. Use an atomic write: see comment in getitab.  atomicstorep(unsafe.Pointer(\u0026amp;itabTable), unsafe.Pointer(t2)) // Adopt the new table as our own.  t = itabTable // Note: the old table can be GC\u0026#39;ed here.  } t.add(m) } func iterate_itabs(fn func(*itab)) { // Note: only runs during stop the world or with itabLock held,  // so no other locks/atomics needed.  t := itabTable for i := uintptr(0); i \u0026lt; t.size; i++ { m := *(**itab)(add(unsafe.Pointer(\u0026amp;t.entries), i*sys.PtrSize)) if m != nil { fn(m) } } } 如何用 interface 实现多态 多态是一种运行期的行为, 它有以下几个特点:\n 一种类型具有多种类型的能力 允许不同的对象对同一消息做出灵活的反应 以一种通用的方式对待个使用的对象 非动态语言必须通过继承和接口的方式来实现   package main import \u0026#34;fmt\u0026#34; func main() { s := Student{age: 18} whatJob(\u0026amp;s) growUp(\u0026amp;s) fmt.Println(s) p := Programmer{age: 100} whatJob(p) growUp(p) fmt.Println(p) } func whatJob(p Person) { p.job() } func growUp(p Person) { p.growUp() } type Person interface { job() growUp() } type Student struct { age int } func (p Student) job() { fmt.Println(\u0026#34;I am a student.\u0026#34;) return } func (p *Student) growUp() { p.age += 1 return } type Programmer struct { age int } func (p Programmer) job() { fmt.Println(\u0026#34;I am a programmer.\u0026#34;) return } func (p Programmer) growUp() { p.age += 10 return } Go 接口与 C++ 接口有何异同 接口定义了一种规范, 描述了类的行为和功能, 而不做具体实现.\nC++ 的接口是使用抽象类来实现的, 如果类中至少有一个函数被声明为纯虚函数, 则这个类就是抽象类. 纯虚函数是通过在声明中使用 \u0026ldquo;= 0\u0026rdquo; 来指定的. 例如:\nclass Shape { public: // 纯虚函数  virtual double getArea() = 0; private: string name; // 名称 };  设计抽象类的目的, 是为了给其他类提供一个可以继承的适当的基类. 抽象类不能被用于实例化对象, 它只能作为接口使用. 派生类需要明确地声明它继承自基类, 并且需要实现基类中所有的纯虚函数.\nC++ 定义接口的方式称为“侵入式”, 而 Go 采用的是 “非侵入式”, 不需要显式声明, 只需要实现接口定义的函数, 编译器自动会识别.\nC++ 和 Go 在定义接口方式上的不同, 也导致了底层实现上的不同. C++ 通过虚函数表来实现基类调用派生类的函数; 而 Go 通过 itab 中的 fun 字段来实现接口变量调用实体类型的函数. C++ 中的虚函数表是在编译期生成的; 而 Go 的 itab 中的 fun 字段是在运行期间动态生成的. 原因在于, Go 中实体类型可能会无意中实现 N 多接口, 很多接口并不是本来需要的, 所以不能为类型实现的所有接口都生成一个 itab, 这也是“非侵入式”带来的影响; 这在 C++ 中是不存在的, 因为派生需要显示声明它继承自哪个基类.\n ","permalink":"https://rx-78-kum0.github.io/posts/interface%E7%B1%BB%E5%9E%8B/","summary":"Go 语言与鸭子类型的关系  If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.\n如果某个东西长得像鸭子, 像鸭子一样游泳, 像鸭子一样嘎嘎叫, 那它就可以被看成是一只鸭子.\n在 Go 语言中, 如果类型的方法集完全包含接口的方法集，则可认为该类型实现了该接口.\n 鸭子类型是一种动态语言的风格, 在这种风格中, 一个对象有效的语义, 不是由继承自特定的类或实现特定的接口, 而是由它\u0026quot;当前方法和属性的集合\u0026quot;决定. Go 作为一种静态语言, 通过接口实现了 鸭子类型, 实际上是 Go 的编译器在其中作了隐匿的转换工作.\n值接收者和指针接收者的区别 package main import \u0026#34;fmt\u0026#34; type Person struct { age int } func (p Person) howOld() int { return p.age } func (p *Person) growUp() { p.","title":"interface类型"},{"content":"// 文字超出省略号 .text-overflow { overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } // 文字超出两行省略号, block元素 .text-overflow-2 { word-break: break-all; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; line-clamp: 2; -webkit-box-orient: vertical; } ","permalink":"https://rx-78-kum0.github.io/posts/%E6%96%87%E5%AD%97%E8%B6%85%E5%87%BA%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7/","summary":"// 文字超出省略号 .text-overflow { overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } // 文字超出两行省略号, block元素 .text-overflow-2 { word-break: break-all; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; line-clamp: 2; -webkit-box-orient: vertical; } ","title":"文字超出显示省略号"},{"content":"线程: 执行指令序列 保留了并发的优点, 避免了进程切换的代价. 实质: 映射表不变, PC指针变.\n价值, 用处 浏览器\n 一个线程用来从服务器接收数据 一个线程用来显示文本 一个线程用来处理图片(解压缩) 一个线程用来显示图片  接收数据线程等待时可以切换到另一个线程(如显示文本), 更加高效利用CPU, 程序交互更加人性化.\n线程切换 多线程执行互不干扰, 所以一个线程执行序列对应一个(或套)栈. 线程切换就是切换TCB.\nTCB (Thread Control Block) 保存线程的信息(执行序列的栈). 与PCB相似, 只是比PCB储存的信息少而已.\n用户级线程 用户态切来切去. CPL为3. TCB在用户程序中.\nvoid ThreadCeate(A) { TCB *tcb = malloc(); // 申请内存创建TCB  *stack = malloc(); // 创建栈  *stack = A; // 保存栈  tcb.esp = stack } // 线程切换 void Yield() { TCB2.esp = esp; esp = TCB1.esp; // esp: CPU寄存器  // jmp xxx; // 不需要再jmp xxx, 因为调用Yield时已经把Yield后面执行的内容压栈. } 缺点 一个进程里的某个用户级线程触发系统IO(如网卡, 磁盘等)后系统会切换到其他进程执行. 这个进程其他线程就无法执行.\n核心级线程 多\u0026quot;套\u0026quot;(用户栈 + 内核栈)TCB在内核中. 中断进入内核\n优点 多核心CPU支持, 核心级线程可以并行执行.\n","permalink":"https://rx-78-kum0.github.io/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","summary":"线程: 执行指令序列 保留了并发的优点, 避免了进程切换的代价. 实质: 映射表不变, PC指针变.\n价值, 用处 浏览器\n 一个线程用来从服务器接收数据 一个线程用来显示文本 一个线程用来处理图片(解压缩) 一个线程用来显示图片  接收数据线程等待时可以切换到另一个线程(如显示文本), 更加高效利用CPU, 程序交互更加人性化.\n线程切换 多线程执行互不干扰, 所以一个线程执行序列对应一个(或套)栈. 线程切换就是切换TCB.\nTCB (Thread Control Block) 保存线程的信息(执行序列的栈). 与PCB相似, 只是比PCB储存的信息少而已.\n用户级线程 用户态切来切去. CPL为3. TCB在用户程序中.\nvoid ThreadCeate(A) { TCB *tcb = malloc(); // 申请内存创建TCB  *stack = malloc(); // 创建栈  *stack = A; // 保存栈  tcb.esp = stack } // 线程切换 void Yield() { TCB2.esp = esp; esp = TCB1.","title":"多线程"},{"content":"进程: 进行中的程序 进行中的程序与磁盘中的静态程序不一样. 进程是描述一个运行中的程序. 进程 = 资源(映射表) + 多个执行指令序列(线程) 进程只能在内核. 要分配资源, 访问文件.\n 有开始, 结束 走走停停(切换) 需要记录  为了充分使用CPU 一次IO操作对应数百万(很多很多)次CPU计算操作. 为了充分合理使用CPU, 需要多个进程交替执行. \u0026ndash; [并发]\n多进程是操作系统的核心 操作系统的核心就是记录, 管理, 合理推进多个进程. 使用计算机就是启用多个进程.\n多进程的组织 PCB + 状态 + 队列\nPCB(Proess Control Block) 记录进程信息的数据结构. 便于切回时继续执行.\n状态  就绪态 阻塞态 运行态  就绪态 \u0026mdash;\u0026mdash;\u0026ndash;\u0026raquo; 运行态 \\ / \\ / 阻塞态\n队列  就绪队列 PCB1 \u0026ndash; PCB3 \u0026ndash; PCB5 磁盘等待队列 PCB2 \u0026ndash; PCB4 \u0026ndash; PCB6  多进程的交替 队列 + 调度 + 切换\nvoid schedule() { pNew = getNext(ReadyQueue); // 调度  switch_to(pCur, pNew); // pCur, pNew PCB } 把当前进程保存起来, 切入另一个的进程.\nvoid swtich_to(pCur, pNew) { pCur.ax = CPU.ax; pCur.bx = CPU.bx; // ...  pCur.cs = CPU.cs; pCur.retpc = CPU.pc; CPU.ax = pNew.ax; CPU.bx = pNew.bx; // ...  CPU.cs = pNew.cs; CPU.pc = pNew.retpc; } 多进程的内存管理 通过映射表实现内存地址空间的分离.\n进程1 内存地址[100] \u0026mdash;\u0026gt; 进程1的映射表 \u0026mdash;-\u0026gt; 物理内存 780 进程2 内存地址[100] \u0026mdash;\u0026gt; 进程2的映射表 \u0026mdash;-\u0026gt; 物理内存 1260\n多进程的合作 生产者与消费者 进程同步不能随意切换进程, 必须同步进程合理切换.\n","permalink":"https://rx-78-kum0.github.io/posts/%E5%A4%9A%E8%BF%9B%E7%A8%8B/","summary":"进程: 进行中的程序 进行中的程序与磁盘中的静态程序不一样. 进程是描述一个运行中的程序. 进程 = 资源(映射表) + 多个执行指令序列(线程) 进程只能在内核. 要分配资源, 访问文件.\n 有开始, 结束 走走停停(切换) 需要记录  为了充分使用CPU 一次IO操作对应数百万(很多很多)次CPU计算操作. 为了充分合理使用CPU, 需要多个进程交替执行. \u0026ndash; [并发]\n多进程是操作系统的核心 操作系统的核心就是记录, 管理, 合理推进多个进程. 使用计算机就是启用多个进程.\n多进程的组织 PCB + 状态 + 队列\nPCB(Proess Control Block) 记录进程信息的数据结构. 便于切回时继续执行.\n状态  就绪态 阻塞态 运行态  就绪态 \u0026mdash;\u0026mdash;\u0026ndash;\u0026raquo; 运行态 \\ / \\ / 阻塞态\n队列  就绪队列 PCB1 \u0026ndash; PCB3 \u0026ndash; PCB5 磁盘等待队列 PCB2 \u0026ndash; PCB4 \u0026ndash; PCB6  多进程的交替 队列 + 调度 + 切换","title":"多进程"},{"content":"// 硬编码一个二进制 trie type BinaryTrie = [ [ [ [ [[[[0, 1], [2, 3]], [[4, 5], [6, 7]]], [[[8, 9], [10, 11]], [[12, 13], [14, 15]]]], [[[[16, 17], [18, 19]], [[20, 21], [22, 23]]], [[[24, 25], [26, 27]], [[28, 29], [30, 31]]]] ], [ [[[[32, 33], [34, 35]], [[36, 37], [38, 39]]], [[[40, 41], [42, 43]], [[44, 45], [46, 47]]]], [[[[48, 49], [50, 51]], [[52, 53], [54, 55]]], [[[56, 57], [58, 59]], [[60, 61], [62, 63]]]] ] ], [ [ [[[[64, 65], [66, 67]], [[68, 69], [70, 71]]], [[[72, 73], [74, 75]], [[76, 77], [78, 79]]]], [[[[80, 81], [82, 83]], [[84, 85], [86, 87]]], [[[88, 89], [90, 91]], [[92, 93], [94, 95]]]] ], [ [[[[96, 97], [98, 99]], [[100, 101], [102, 103]]], [[[104, 105], [106, 107]], [[108, 109], [110, 111]]]], [[[[112, 113], [114, 115]], [[116, 117], [118, 119]]], [[[120, 121], [122, 123]], [[124, 125], [126, 127]]]] ] ] ], [ [ [ [[[[128, 129], [130, 131]], [[132, 133], [134, 135]]], [[[136, 137], [138, 139]], [[140, 141], [142, 143]]]], [[[[144, 145], [146, 147]], [[148, 149], [150, 151]]], [[[152, 153], [154, 155]], [[156, 157], [158, 159]]]] ], [ [[[[160, 161], [162, 163]], [[164, 165], [166, 167]]], [[[168, 169], [170, 171]], [[172, 173], [174, 175]]]], [[[[176, 177], [178, 179]], [[180, 181], [182, 183]]], [[[184, 185], [186, 187]], [[188, 189], [190, 191]]]] ] ], [ [ [[[[192, 193], [194, 195]], [[196, 197], [198, 199]]], [[[200, 201], [202, 203]], [[204, 205], [206, 207]]]], [[[[208, 209], [210, 211]], [[212, 213], [214, 215]]], [[[216, 217], [218, 219]], [[220, 221], [222, 223]]]] ], [ [[[[224, 225], [226, 227]], [[228, 229], [230, 231]]], [[[232, 233], [234, 235]], [[236, 237], [238, 239]]]], [[[[240, 241], [242, 243]], [[244, 245], [246, 247]]], [[[248, 249], [250, 251]], [[252, 253], [254, 255]]]] ] ] ] ]; // 数组操作 type Copy\u0026lt;T, S extends any\u0026gt; = { [P in keyof T]: S[P] }; type Unshift\u0026lt;T, A\u0026gt; = ((a: A, ...b: T extends any[] ? T : never) =\u0026gt; void) extends (...a: infer R) =\u0026gt; void ? R : never; type Push\u0026lt;T, A\u0026gt; = Copy\u0026lt;Unshift\u0026lt;T, any\u0026gt;, T \u0026amp; Record\u0026lt;string, A\u0026gt;\u0026gt;; // 搜索二进制 trie type SearchInTrie\u0026lt;Num, Node, Digits\u0026gt; = { 1: Node extends [infer A, infer B] ? Num extends A ? Push\u0026lt;Digits, 0\u0026gt; : Num extends B ? Push\u0026lt;Digits, 1\u0026gt; : never : never; 0: Node extends [infer A, infer B] ? SearchInTrie\u0026lt;Num, A, Push\u0026lt;Digits, 0\u0026gt;\u0026gt; | SearchInTrie\u0026lt;Num, B, Push\u0026lt;Digits, 1\u0026gt;\u0026gt; : never; }[Node extends [number, number] ? 1 : 0]; // 定义数字类型 type Digit = 0 | 1; type Bits = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7; type Uint8 = Record\u0026lt;Bits, Digit\u0026gt;; // 也可以定义成8个Digit的数组，这样写比较简短  type AsDigit\u0026lt;T\u0026gt; = T extends Digit ? T : never; type AsUint8\u0026lt;T\u0026gt; = T extends Uint8 ? T : never; // 数字转二进制表示 type ToUint8\u0026lt;A extends number\u0026gt; = SearchInTrie\u0026lt;A, BinaryTrie, []\u0026gt;; // 二进制表示转数字 type ToNumber\u0026lt;A extends Uint8\u0026gt; = BinaryTrie[A[0]][A[1]][A[2]][A[3]][A[4]][A[5]][A[6]][A[7]]; // 两个1 bit数相加，C 表示进位 type BitAdd\u0026lt;A extends Digit, B extends Digit, C extends Digit\u0026gt; = [ [[[0, 0], [1, 0]], [[1, 0], [0, 1]]], [[[1, 0], [0, 1]], [[0, 1], [1, 1]]] ][A][B][C]; // 8位数相加 type Uint8Add\u0026lt;A extends Uint8, B extends Uint8\u0026gt; = BitAdd\u0026lt;A[7], B[7], 0\u0026gt; extends [infer S7, infer C] ? BitAdd\u0026lt;A[6], B[6], AsDigit\u0026lt;C\u0026gt;\u0026gt; extends [infer S6, infer C] ? BitAdd\u0026lt;A[5], B[5], AsDigit\u0026lt;C\u0026gt;\u0026gt; extends [infer S5, infer C] ? BitAdd\u0026lt;A[4], B[4], AsDigit\u0026lt;C\u0026gt;\u0026gt; extends [infer S4, infer C] ? BitAdd\u0026lt;A[3], B[3], AsDigit\u0026lt;C\u0026gt;\u0026gt; extends [infer S3, infer C] ? BitAdd\u0026lt;A[2], B[2], AsDigit\u0026lt;C\u0026gt;\u0026gt; extends [infer S2, infer C] ? BitAdd\u0026lt;A[1], B[1], AsDigit\u0026lt;C\u0026gt;\u0026gt; extends [infer S1, infer C] ? BitAdd\u0026lt;A[0], B[0], AsDigit\u0026lt;C\u0026gt;\u0026gt; extends [infer S0, infer C] // ? C extends 1 ? \u0026#34;overflow\u0026#34; :  ? AsUint8\u0026lt;[S0, S1, S2, S3, S4, S5, S6, S7]\u0026gt; : never : never : never : never : never : never : never : never; // 位取反 type Reverse = [1, 0]; type Uint8Reverse\u0026lt;A extends Uint8\u0026gt; = [ Reverse[A[0]], Reverse[A[1]], Reverse[A[2]], Reverse[A[3]], Reverse[A[4]], Reverse[A[5]], Reverse[A[6]], Reverse[A[7]] ]; // 两个特殊数字方便使用 type ZERO = [0, 0, 0, 0, 0, 0, 0, 0]; type ONE = [0, 0, 0, 0, 0, 0, 0, 1]; // 补码 type Uint8Negate\u0026lt;A extends Uint8\u0026gt; = Uint8Add\u0026lt;Uint8Reverse\u0026lt;A\u0026gt;, ONE\u0026gt;; // 8位数相减 type Uint8Sub\u0026lt;A extends Uint8, B extends Uint8\u0026gt; = Uint8Add\u0026lt;A, Uint8Negate\u0026lt;B\u0026gt;\u0026gt;; // 左移 type LShift\u0026lt;A extends Uint8, B extends number, P extends Digit\u0026gt; = B extends 1 ? [A[1], A[2], A[3], A[4], A[5], A[6], A[7], P] : B extends 2 ? [A[2], A[3], A[4], A[5], A[6], A[7], P, P] : B extends 3 ? [A[3], A[4], A[5], A[6], A[7], P, P, P] : B extends 4 ? [A[4], A[5], A[6], A[7], P, P, P, P] : B extends 5 ? [A[5], A[6], A[7], P, P, P, P, P] : B extends 6 ? [A[6], A[7], P, P, P, P, P, P] : B extends 7 ? [A[7], P, P, P, P, P, P, P] : B extends 0 ? A : [P, P, P, P, P, P, P, P]; // 8位数乘1位数 type BitMul\u0026lt;A extends Uint8, B extends Digit, C extends Bits\u0026gt; = B extends 1 ? LShift\u0026lt;A, C, 0\u0026gt; : ZERO; // 8位数相乘 type Uint8Mul\u0026lt;A extends Uint8, B extends Uint8\u0026gt; = Uint8Add\u0026lt;ZERO, BitMul\u0026lt;A, B[7], 0\u0026gt;\u0026gt; extends infer S ? Uint8Add\u0026lt;AsUint8\u0026lt;S\u0026gt;, BitMul\u0026lt;A, B[6], 1\u0026gt;\u0026gt; extends infer S ? Uint8Add\u0026lt;AsUint8\u0026lt;S\u0026gt;, BitMul\u0026lt;A, B[5], 2\u0026gt;\u0026gt; extends infer S ? Uint8Add\u0026lt;AsUint8\u0026lt;S\u0026gt;, BitMul\u0026lt;A, B[4], 3\u0026gt;\u0026gt; extends infer S ? Uint8Add\u0026lt;AsUint8\u0026lt;S\u0026gt;, BitMul\u0026lt;A, B[3], 4\u0026gt;\u0026gt; extends infer S ? Uint8Add\u0026lt;AsUint8\u0026lt;S\u0026gt;, BitMul\u0026lt;A, B[2], 5\u0026gt;\u0026gt; extends infer S ? Uint8Add\u0026lt;AsUint8\u0026lt;S\u0026gt;, BitMul\u0026lt;A, B[1], 6\u0026gt;\u0026gt; extends infer S ? Uint8Add\u0026lt;AsUint8\u0026lt;S\u0026gt;, BitMul\u0026lt;A, B[0], 7\u0026gt;\u0026gt; : never : never : never : never : never : never : never; // 比较结果 type EQ = 0; type GT = 1; type LT = 2; // 1位数比较 type BitCMP\u0026lt;A extends Digit, B extends Digit\u0026gt; = [[EQ, LT], [GT, EQ]][A][B]; // 8位数比较 type Uint8CMP\u0026lt;A extends Uint8, B extends Uint8\u0026gt; = BitCMP\u0026lt;A[0], B[0]\u0026gt; extends GT | LT ? BitCMP\u0026lt;A[0], B[0]\u0026gt; : BitCMP\u0026lt;A[1], B[1]\u0026gt; extends GT | LT ? BitCMP\u0026lt;A[1], B[1]\u0026gt; : BitCMP\u0026lt;A[2], B[2]\u0026gt; extends GT | LT ? BitCMP\u0026lt;A[2], B[2]\u0026gt; : BitCMP\u0026lt;A[3], B[3]\u0026gt; extends GT | LT ? BitCMP\u0026lt;A[3], B[3]\u0026gt; : BitCMP\u0026lt;A[4], B[4]\u0026gt; extends GT | LT ? BitCMP\u0026lt;A[4], B[4]\u0026gt; : BitCMP\u0026lt;A[5], B[5]\u0026gt; extends GT | LT ? BitCMP\u0026lt;A[5], B[5]\u0026gt; : BitCMP\u0026lt;A[6], B[6]\u0026gt; extends GT | LT ? BitCMP\u0026lt;A[6], B[6]\u0026gt; : BitCMP\u0026lt;A[7], B[7]\u0026gt;; // 简单求余 type Remainder\u0026lt;A extends Uint8, B extends Uint8\u0026gt; = Uint8CMP\u0026lt;A, B\u0026gt; extends LT ? [0, A] : [1, Uint8Sub\u0026lt;A, B\u0026gt;]; // 8位数相除 type Uint8Div\u0026lt;A extends Uint8, B extends Uint8\u0026gt; = Remainder\u0026lt;LShift\u0026lt;ZERO, 1, A[0]\u0026gt;, B\u0026gt; extends [infer Q0, infer R] ? Remainder\u0026lt;LShift\u0026lt;AsUint8\u0026lt;R\u0026gt;, 1, A[1]\u0026gt;, B\u0026gt; extends [infer Q1, infer R] ? Remainder\u0026lt;LShift\u0026lt;AsUint8\u0026lt;R\u0026gt;, 1, A[2]\u0026gt;, B\u0026gt; extends [infer Q2, infer R] ? Remainder\u0026lt;LShift\u0026lt;AsUint8\u0026lt;R\u0026gt;, 1, A[3]\u0026gt;, B\u0026gt; extends [infer Q3, infer R] ? Remainder\u0026lt;LShift\u0026lt;AsUint8\u0026lt;R\u0026gt;, 1, A[4]\u0026gt;, B\u0026gt; extends [infer Q4, infer R] ? Remainder\u0026lt;LShift\u0026lt;AsUint8\u0026lt;R\u0026gt;, 1, A[5]\u0026gt;, B\u0026gt; extends [infer Q5, infer R] ? Remainder\u0026lt;LShift\u0026lt;AsUint8\u0026lt;R\u0026gt;, 1, A[6]\u0026gt;, B\u0026gt; extends [infer Q6, infer R] ? Remainder\u0026lt;LShift\u0026lt;AsUint8\u0026lt;R\u0026gt;, 1, A[7]\u0026gt;, B\u0026gt; extends [infer Q7, infer R] ? [AsUint8\u0026lt;[Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7]\u0026gt;, AsUint8\u0026lt;R\u0026gt;] : never : never : never : never : never : never : never : never; // 加 type Add\u0026lt;A extends number, B extends number\u0026gt; = ToNumber\u0026lt;Uint8Add\u0026lt;ToUint8\u0026lt;A\u0026gt;, ToUint8\u0026lt;B\u0026gt;\u0026gt;\u0026gt;; // 减 type Sub\u0026lt;A extends number, B extends number\u0026gt; = ToNumber\u0026lt;Uint8Sub\u0026lt;ToUint8\u0026lt;A\u0026gt;, ToUint8\u0026lt;B\u0026gt;\u0026gt;\u0026gt;; // 乘 type Mul\u0026lt;A extends number, B extends number\u0026gt; = ToNumber\u0026lt;Uint8Mul\u0026lt;ToUint8\u0026lt;A\u0026gt;, ToUint8\u0026lt;B\u0026gt;\u0026gt;\u0026gt;; // 除 type Div\u0026lt;A extends number, B extends number\u0026gt; = B extends 0 ? never : ToNumber\u0026lt;Uint8Div\u0026lt;ToUint8\u0026lt;A\u0026gt;, ToUint8\u0026lt;B\u0026gt;\u0026gt;[0]\u0026gt;; // 取余 type Mod\u0026lt;A extends number, B extends number\u0026gt; = B extends 0 ? never : ToNumber\u0026lt;Uint8Div\u0026lt;ToUint8\u0026lt;A\u0026gt;, ToUint8\u0026lt;B\u0026gt;\u0026gt;[1]\u0026gt;; // 测试 type case1_ShouldBe99 = Add\u0026lt;33, 66\u0026gt;; // 33 + 66 = 99 type case2_ShouldBe0 = Add\u0026lt;255, 1\u0026gt;; // 255 + 1 = 0 (overflow)  const a: case1_ShouldBe99 = 99; type case3_ShouldBe99 = Sub\u0026lt;123, 24\u0026gt;; // 123 - 24 = 99 type case4_ShouldBe255 = Sub\u0026lt;0, 1\u0026gt;; // 0 - 1 = 255 (overflow)  type case5_ShouldBe153 = Mul\u0026lt;17, 9\u0026gt;; // 17 x 9 = 153 type case6_ShouldBe253 = Mul\u0026lt;255, 3\u0026gt;; // 255 x 3 = 253 (overflow)  type case7_ShouldBe33 = Div\u0026lt;100, 3\u0026gt;; // 100 / 3 = 33 type case8_ShouldBeNever = Div\u0026lt;1, 0\u0026gt;; // 1 / 0 = error (divide by 0)  type case9_ShouldBe1 = Mod\u0026lt;100, 3\u0026gt;; // 100 % 3 = 1 type case10_ShouldBeNever = Mod\u0026lt;1, 0\u0026gt;; // 1 % 0 = error (divide by 0) ","permalink":"https://rx-78-kum0.github.io/posts/typescript%E5%85%83%E7%BC%96%E7%A8%8B/","summary":"// 硬编码一个二进制 trie type BinaryTrie = [ [ [ [ [[[[0, 1], [2, 3]], [[4, 5], [6, 7]]], [[[8, 9], [10, 11]], [[12, 13], [14, 15]]]], [[[[16, 17], [18, 19]], [[20, 21], [22, 23]]], [[[24, 25], [26, 27]], [[28, 29], [30, 31]]]] ], [ [[[[32, 33], [34, 35]], [[36, 37], [38, 39]]], [[[40, 41], [42, 43]], [[44, 45], [46, 47]]]], [[[[48, 49], [50, 51]], [[52, 53], [54, 55]]], [[[56, 57], [58, 59]], [[60, 61], [62, 63]]]] ] ], [ [ [[[[64, 65], [66, 67]], [[68, 69], [70, 71]]], [[[72, 73], [74, 75]], [[76, 77], [78, 79]]]], [[[[80, 81], [82, 83]], [[84, 85], [86, 87]]], [[[88, 89], [90, 91]], [[92, 93], [94, 95]]]] ], [ [[[[96, 97], [98, 99]], [[100, 101], [102, 103]]], [[[104, 105], [106, 107]], [[108, 109], [110, 111]]]], [[[[112, 113], [114, 115]], [[116, 117], [118, 119]]], [[[120, 121], [122, 123]], [[124, 125], [126, 127]]]] ] ] ], [ [ [ [[[[128, 129], [130, 131]], [[132, 133], [134, 135]]], [[[136, 137], [138, 139]], [[140, 141], [142, 143]]]], [[[[144, 145], [146, 147]], [[148, 149], [150, 151]]], [[[152, 153], [154, 155]], [[156, 157], [158, 159]]]] ], [ [[[[160, 161], [162, 163]], [[164, 165], [166, 167]]], [[[168, 169], [170, 171]], [[172, 173], [174, 175]]]], [[[[176, 177], [178, 179]], [[180, 181], [182, 183]]], [[[184, 185], [186, 187]], [[188, 189], [190, 191]]]] ] ], [ [ [[[[192, 193], [194, 195]], [[196, 197], [198, 199]]], [[[200, 201], [202, 203]], [[204, 205], [206, 207]]]], [[[[208, 209], [210, 211]], [[212, 213], [214, 215]]], [[[216, 217], [218, 219]], [[220, 221], [222, 223]]]] ], [ [[[[224, 225], [226, 227]], [[228, 229], [230, 231]]], [[[232, 233], [234, 235]], [[236, 237], [238, 239]]]], [[[[240, 241], [242, 243]], [[244, 245], [246, 247]]], [[[248, 249], [250, 251]], [[252, 253], [254, 255]]]] ] ] ] ]; // 数组操作 type Copy\u0026lt;T, S extends any\u0026gt; = { [P in keyof T]: S[P] }; type Unshift\u0026lt;T, A\u0026gt; = ((a: A, .","title":"typescript元编程"},{"content":"# .clang-format BasedOnStyle: LLVM Language:\tCpp IndentWidth : 2 # 开括号(开圆括号、开尖括号、开方括号)后的对齐: Align, DontAlign, AlwaysBreak(总是在开括号后换行) AlignAfterOpenBracket:\tAlign # 大括号换行，只有当BreakBeforeBraces设置为Custom时才有效 BraceWrapping: # class定义后面 AfterClass:\tfalse # 控制语句后面 AfterControlStatement:\tfalse # enum定义后面 AfterEnum:\tfalse # 函数定义后面 AfterFunction:\ttrue # 命名空间定义后面 AfterNamespace:\tfalse # ObjC定义后面 AfterObjCDeclaration:\tfalse # struct定义后面 AfterStruct:\tfalse # union定义后面 AfterUnion:\tfalse # catch之前 BeforeCatch:\ttrue # else之前 BeforeElse:\ttrue # 缩进大括号 IndentBraces:\tfalse BreakBeforeBraces:\tCustom ","permalink":"https://rx-78-kum0.github.io/posts/clang-format/","summary":"# .clang-format BasedOnStyle: LLVM Language:\tCpp IndentWidth : 2 # 开括号(开圆括号、开尖括号、开方括号)后的对齐: Align, DontAlign, AlwaysBreak(总是在开括号后换行) AlignAfterOpenBracket:\tAlign # 大括号换行，只有当BreakBeforeBraces设置为Custom时才有效 BraceWrapping: # class定义后面 AfterClass:\tfalse # 控制语句后面 AfterControlStatement:\tfalse # enum定义后面 AfterEnum:\tfalse # 函数定义后面 AfterFunction:\ttrue # 命名空间定义后面 AfterNamespace:\tfalse # ObjC定义后面 AfterObjCDeclaration:\tfalse # struct定义后面 AfterStruct:\tfalse # union定义后面 AfterUnion:\tfalse # catch之前 BeforeCatch:\ttrue # else之前 BeforeElse:\ttrue # 缩进大括号 IndentBraces:\tfalse BreakBeforeBraces:\tCustom ","title":"clang-format"},{"content":" 所有的快乐，其本质都是否定的，而痛苦的本质却是肯定的。\n ","permalink":"https://rx-78-kum0.github.io/about/","summary":" 所有的快乐，其本质都是否定的，而痛苦的本质却是肯定的。\n ","title":"About"},{"content":"Power by Hugo 现在，该博客改由 Hugo 强力驱动啦！  Hugo 是一个 golang 编写的静态网页生成器。同类型工具还有使用 node 编写的 Hexo。\n Hugo的优点 - 快 基于 golang 编写的\n- 简单 不仅使用简单，甚至自己写主题也很简单。\n- 支持org格式! (优秀) hexo, jekyll 等同类工具大多只支持 markdown. 而 hugo 支持 org 这一仅在 emacs 上有的文档格式，感动~\n 但不会直接用org来发布~ 目前支持程度远没有 markdown 格式好。因为 org 在 emacs 上原生支持太好，又不像 md 这样通用导致其他平台支持程度不是很高。好在可以使用 emacs 插件把 org 转成 md，虽然还是会丢失一些 org 的特性。\n Org -\u0026gt; Markdown Emacs 的 ox-hugo\n安装 (use-package ox-hugo :after ox) 使用    需要在org文档元数据上标明hugo博客的根目录 HUGO_BASE_DIR 和生成文档的目标目录 HUGO_SECTION\n#+HUGO_BASE_DIR: ~/Hugo-DirName #+HUGO_SECTION: posts      C-c C-e H h\n导出当前org文档\n     org-hugo-auto-export-mode\n保存org文档自动导出为md\n在hugo博客根目录添加.dir-locals.el文件:\n((\u0026#34;content-org/\u0026#34; . ((org-mode . ((eval . (org-hugo-auto-export-mode))))))) 最终Hugo目录树:\n\u0026lt;HUGO_BASE_DIR\u0026gt; ├── config.toml ├── content ├── \u0026lt;HUGO_SECTION\u0026gt; ├── content-org \u0026lt;-- Org files in there ├── static ├── themes └── .dir-locals.el   ","permalink":"https://rx-78-kum0.github.io/posts/hello_world/","summary":"Power by Hugo 现在，该博客改由 Hugo 强力驱动啦！  Hugo 是一个 golang 编写的静态网页生成器。同类型工具还有使用 node 编写的 Hexo。\n Hugo的优点 - 快 基于 golang 编写的\n- 简单 不仅使用简单，甚至自己写主题也很简单。\n- 支持org格式! (优秀) hexo, jekyll 等同类工具大多只支持 markdown. 而 hugo 支持 org 这一仅在 emacs 上有的文档格式，感动~\n 但不会直接用org来发布~ 目前支持程度远没有 markdown 格式好。因为 org 在 emacs 上原生支持太好，又不像 md 这样通用导致其他平台支持程度不是很高。好在可以使用 emacs 插件把 org 转成 md，虽然还是会丢失一些 org 的特性。\n Org -\u0026gt; Markdown Emacs 的 ox-hugo\n安装 (use-package ox-hugo :after ox) 使用    需要在org文档元数据上标明hugo博客的根目录 HUGO_BASE_DIR 和生成文档的目标目录 HUGO_SECTION","title":"Hello_World"},{"content":"# vi: ft=dosini [main] # Enables context sensitive auto-completion. If this is disabled the all # possible completions will be listed. smart_completion = True # Multi-line mode allows breaking up the sql statements into multiple lines. If # this is set to True, then the end of the statements must have a semi-colon. # If this is set to False then sql statements can\u0026#39;t be split into multiple # lines. End of line (return) is considered as the end of the statement. multi_line = True # Destructive warning mode will alert you before executing a sql statement # that may cause harm to the database such as \u0026#34;drop table\u0026#34;, \u0026#34;drop database\u0026#34; # or \u0026#34;shutdown\u0026#34;. destructive_warning = True # log_file location. log_file = ~/.mycli.log # Default log level. Possible values: \u0026#34;CRITICAL\u0026#34;, \u0026#34;ERROR\u0026#34;, \u0026#34;WARNING\u0026#34;, \u0026#34;INFO\u0026#34; # and \u0026#34;DEBUG\u0026#34;. \u0026#34;NONE\u0026#34; disables logging. log_level = INFO # Log every query and its results to a file. Enable this by uncommenting the # line below. # audit_log = ~/.mycli-audit.log # Timing of sql statments and table rendering. timing = True # Table format. Possible values: psql, plain, simple, grid, fancy_grid, pipe, # orgtbl, rst, mediawiki, html, latex, latex_booktabs, tsv. # Recommended: psql, fancy_grid and grid. table_format = psql # Syntax coloring style. Possible values (many support the \u0026#34;-dark\u0026#34; suffix): # manni, igor, xcode, vim, autumn, vs, rrt, native, perldoc, borland, tango, emacs, # friendly, monokai, paraiso, colorful, murphy, bw, pastie, paraiso, trac, default, # fruity. # Screenshots at http://mycli.net/syntax syntax_style = default # Keybindings: Possible values: emacs, vi. # Emacs mode: Ctrl-A is home, Ctrl-E is end. All emacs keybindings are available in the REPL. # When Vi mode is enabled you can use modal editing features offered by Vi in the REPL. key_bindings = emacs # Enabling this option will show the suggestions in a wider menu. Thus more items are suggested. wider_completion_menu = False # MySQL prompt # \\t - Product type (Percona, MySQL, Mariadb) # \\u - Username # \\h - Hostname of the server # \\d - Database name # \\n - Newline prompt = \u0026#39;\\t \\u@\\h:\\d\u0026gt; \u0026#39; prompt_continuation = \u0026#39;-\u0026gt; \u0026#39; # Skip intro info on startup and outro info on exit less_chatty = False # Use alias from --login-path instead of host name in prompt login_path_as_host = False # Custom colors for the completion menu, toolbar, etc. [colors] # Completion menus. Token.Menu.Completions.Completion.Current = \u0026#39;bg:#00aaaa #000000\u0026#39; Token.Menu.Completions.Completion = \u0026#39;bg:#008888 #ffffff\u0026#39; Token.Menu.Completions.MultiColumnMeta = \u0026#39;bg:#aaffff #000000\u0026#39; Token.Menu.Completions.ProgressButton = \u0026#39;bg:#003333\u0026#39; Token.Menu.Completions.ProgressBar = \u0026#39;bg:#00aaaa\u0026#39; # Selected text. Token.SelectedText = \u0026#39;#ffffff bg:#6666aa\u0026#39; # Search matches. (reverse-i-search) Token.SearchMatch = \u0026#39;#ffffff bg:#4444aa\u0026#39; Token.SearchMatch.Current = \u0026#39;#ffffff bg:#44aa44\u0026#39; # The bottom toolbar. Token.Toolbar = \u0026#39;bg:#222222 #aaaaaa\u0026#39; Token.Toolbar.Off = \u0026#39;bg:#222222 #888888\u0026#39; Token.Toolbar.On = \u0026#39;bg:#222222 #ffffff\u0026#39; # Search/arg/system toolbars. Token.Toolbar.Search = \u0026#39;noinherit bold\u0026#39; Token.Toolbar.Search.Text = \u0026#39;nobold\u0026#39; Token.Toolbar.System = \u0026#39;noinherit bold\u0026#39; Token.Toolbar.Arg = \u0026#39;noinherit bold\u0026#39; Token.Toolbar.Arg.Text = \u0026#39;nobold\u0026#39; # Favorite queries. [favorite_queries] ","permalink":"https://rx-78-kum0.github.io/posts/myclirc/","summary":"# vi: ft=dosini [main] # Enables context sensitive auto-completion. If this is disabled the all # possible completions will be listed. smart_completion = True # Multi-line mode allows breaking up the sql statements into multiple lines. If # this is set to True, then the end of the statements must have a semi-colon. # If this is set to False then sql statements can\u0026#39;t be split into multiple # lines. End of line (return) is considered as the end of the statement.","title":"myclirc"},{"content":"angular的ControlValueAccessor是一个连接表单模型和视图DOM的抽象类接口\n.org-center { margin-left: auto; margin-right: auto; text-align: center; }  使自定义表单组件像原生input一样映射到form表单模型中, 拥有自定义表单组件的form也能使用响应式表单. (也就是使自定义表单组件拥有formControlName属性和ngModel接口.)\n 毕竟响应式表单才是angular的利器.\nControlValueAccessor export interface ControlValueAccessor { writeValue(obj: any): void; registerOnChange(fn: any): void; registerOnTouched(fn: any): void; setDisabledState?(isDisabled: boolean): void; } writeValue(obj: any): 该方法是接收模版中的ngModel.\nwriteValue(value: any): void { this._renderer.setProperty(this._elementRef.nativeElement, \u0026#39;value\u0026#39;, value); } registerOnChange(fn: any): void: 该方法是组件接收到 change 事件的回调, 可以用来通知外部达成双向绑定, 即ngModelChange.\nregisterOnChange(fn: (_: any) =\u0026gt; void): void { this._onChange = fn; } registerOnTouched(fn: any): 接收到 touched 事件的回调.\nregisterOnTouched(fn: any): void { this._onTouched = fn; } setDisabledState?(isDisabled: boolean): 该方法是组件输入状态 disable \u0026lt;=\u0026gt; enable 变化时的回调。该方法会根据参数值，启用或禁用指定的DOM元素.\n以下组件类实现了ControlValueAccessor接口. CheckboxControlValueAccessor 用于checkbox复选组件选择器:\n input[type=checkbox][formControlName] input[type=checkbox][formControl] input[type=checkbox][ngModel]  NumberValueAccessor 用于number类型的输入组件选择器:\n input[type=number][formControlName] input[type=number][formControl] input[type=number][ngModel]  DefaultValueAccessor 用于 text 和 textarea 类型的输入组件选择器:\n input:not([type=checkbox])[formControlName] textarea[formControlName] input:not([type=checkbox])[formControl] textarea[formControl] input:not([type=checkbox])[ngModel] textarea[ngModel] [ngDefaultControl]  RadioControlValueAccessor 用于radio单选组件选择器:\n input[type=radio][formControlName] input[type=radio][formControl] input[type=radio][ngModel]  扩展方法:\n fireUncheck(value: any): void:取消选中的回调.  RangeValueAccessor 用于范围输入组件选择器:\n input[type=range][formControlName] input[type=range][formControl] input[type=range][ngModel]  SelectControlValueAccessor 用于select组件选择器:\n select:not([multiple])[formControlName] select:not([multiple])[formControl] select:not([multiple])[ngModel]  扩展方法:\n compareWith: (o1: any, o2: any) =\u0026gt; boolean:比较函数. 例如option的ngValue是一个对象, 当选中项填入表单时,需要编写一个比较函数来处理当前选中的对象是哪一个option.  SelectMultipleControlValueAccessor 用于多选select组件选择器:\n select[multiple][formControlName] select[multiple][formControl] select[multiple][ngModel]  扩展方法: compareWith: (o1: any, o2: any) =\u0026gt; boolean:比较函数. 例如option的ngValue是一个对象, 当选中项填入表单时, 需要编写一个比较函数来处理当前选中的对象是哪一个option.\nEG 自定义表单组件代码结构 import { Component, OnInit, HostListener, ViewEncapsulation, forwardRef, Input, OnDestroy, ChangeDetectorRef, ChangeDetectionStrategy } from \u0026#39;@angular/core\u0026#39;; import { ControlValueAccessor, NG_VALUE_ACCESSOR } from \u0026#39;@angular/forms\u0026#39;; import { Subject } from \u0026#39;rxjs\u0026#39;; @Component({ selector : \u0026#39;[app-radiobox]\u0026#39;, templateUrl : \u0026#39;./radiobox.component.html\u0026#39;, styleUrls : [\u0026#39;./radiobox.component.styl\u0026#39;], encapsulation : ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, host : { \u0026#39;[class.radio-wrapper]\u0026#39; : \u0026#39;true\u0026#39;, \u0026#39;[class.radio-wrapper-checked]\u0026#39;: \u0026#39;checked\u0026#39; }, providers: [ { provide : NG_VALUE_ACCESSOR, useExisting: forwardRef(() =\u0026gt; RadioboxComponent), multi : true } ] }) export class RadioboxComponent implements OnInit, OnDestroy, ControlValueAccessor { @Input() value: boolean; checked: boolean; select$ = new Subject\u0026lt;RadioboxComponent\u0026gt;(); onChange: (_: any) =\u0026gt; void = () =\u0026gt; null; onTouched: () =\u0026gt; void = () =\u0026gt; null; constructor(private _cdr: ChangeDetectorRef) {} @HostListener(\u0026#39;click\u0026#39;, [\u0026#39;$event\u0026#39;]) onClick(e: MouseEvent): void { e.stopPropagation(); e.preventDefault(); this.checked = !this.checked; this.onChange(this.checked); this.select$.next(this); } writeValue(value: boolean) { this.checked = value; } registerOnChange(fn: (_: boolean) =\u0026gt; {}): void { this.onChange = fn; } registerOnTouched(fn: () =\u0026gt; {}): void { this.onTouched = fn; } ngOnInit() {} ngOnDestroy() {} } 调用 import { Component, OnInit } from \u0026#39;@angular/core\u0026#39;; import { FormBuilder, FormGroup } from \u0026#39;@angular/forms\u0026#39;; @Component({ selector: \u0026#39;app-example\u0026#39;, template: ` \u0026lt;form [formGroup]=\u0026#34;testForm\u0026#34;\u0026gt; \u0026lt;label\u0026gt;试试\u0026lt;/label\u0026gt; \u0026lt;label app-radiobox formControlName=\u0026#34;check\u0026#34;\u0026gt;check me\u0026lt;/label\u0026gt; \u0026lt;/form\u0026gt; ` }) export class ExampleComponent implements OnInit { testForm: FormGroup = this._fb.group({ check: false }); constructor(private _fb: FormBuilder) {} ngOnInit() { this.testForm.valueChanges.subscribe(d =\u0026gt; { console.log(d); }); } } ","permalink":"https://rx-78-kum0.github.io/posts/angular%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E8%A1%A8%E5%8D%95%E7%BB%84%E4%BB%B6/","summary":"angular的ControlValueAccessor是一个连接表单模型和视图DOM的抽象类接口\n.org-center { margin-left: auto; margin-right: auto; text-align: center; }  使自定义表单组件像原生input一样映射到form表单模型中, 拥有自定义表单组件的form也能使用响应式表单. (也就是使自定义表单组件拥有formControlName属性和ngModel接口.)\n 毕竟响应式表单才是angular的利器.\nControlValueAccessor export interface ControlValueAccessor { writeValue(obj: any): void; registerOnChange(fn: any): void; registerOnTouched(fn: any): void; setDisabledState?(isDisabled: boolean): void; } writeValue(obj: any): 该方法是接收模版中的ngModel.\nwriteValue(value: any): void { this._renderer.setProperty(this._elementRef.nativeElement, \u0026#39;value\u0026#39;, value); } registerOnChange(fn: any): void: 该方法是组件接收到 change 事件的回调, 可以用来通知外部达成双向绑定, 即ngModelChange.\nregisterOnChange(fn: (_: any) =\u0026gt; void): void { this._onChange = fn; } registerOnTouched(fn: any): 接收到 touched 事件的回调.\nregisterOnTouched(fn: any): void { this.","title":"angular自定义双向绑定表单组件"},{"content":"\u0026#34; .vimrc \u0026#34; Configuration file for vim set modelines=0 \u0026#34; Don\u0026#39;t write backup file if vim is being called by \u0026#34;crontab -e\u0026#34; \u0026#34; au BufWrite /private/tmp/crontab.* set nowritebackup nobackup \u0026#34; Don\u0026#39;t write backup file if vim is being called by \u0026#34;chpass\u0026#34; \u0026#34; au BufWrite /private/etc/pw.* set nowritebackup nobackup set nobackup set nowritebackup let skip_defaults_vim=1 \u0026#34; \u0026lt;leader\u0026gt; let g:mapleader=\u0026#34;,\u0026#34; \u0026#34; 去掉有关vi一致性模式，避免以前版本的bug和局限 set nocompatible \u0026#34; 设置退格键可用 set backspace=2 \u0026#34; utf-8 set encoding=UTF-8 \u0026#34; 主题 \u0026#34; set background=dark \u0026#34; colorscheme dracula \u0026#34; 函数方法名加粗 let g:enable_bold_font = 1 \u0026#34; 注释斜体 let g:enable_italic_font = 1 \u0026#34; 透明背景 let g:hybrid_transparent_background = 1 \u0026#34; airline_theme let g:airline_theme = \u0026#34;hybrid\u0026#34; \u0026#34; 行号 set nu! \u0026#34; 高亮显示寻找匹配 set hls \u0026#34; 允许用指定语法高亮配色方案替换默认方案 syntax on dracula \u0026#34; 开启语法高亮 syntax enable \u0026#34; 设置匹配模式 (当输入一个左括号时会匹配相应的右括号) set showmatch \u0026#34; 显示当前光标位置 set ruler \u0026#34; 使用系统剪切板 set clipboard=unnamed \u0026#34; 设置格式化时代码缩进为2个空格 set shiftwidth=2 \u0026#34; tab键缩进为4格子 set tabstop=2 \u0026#34; 把连续数量的空格视为一个制表符 set softtabstop=2 \u0026#34; 禁止折行 set nowrap \u0026#34; tab键转换为空格 set expandtab \u0026#34; 智能缩进 set smartindent \u0026#34; 开启实时搜索功能 set incsearch \u0026#34; 搜索时大小写不敏感 set ignorecase \u0026#34; vim 自身命令行模式智能补全 set wildmenu \u0026#34; 开启文件类型侦测 filetype on \u0026#34; 根据侦测到的不同类型加载对应的插件 filetype plugin on \u0026#34; 自适应不同语言的智能缩进 filetype indent on \u0026#34; 将制表符扩展为空格 set nofoldenable \u0026#34; 基于缩进或语法进行代码折叠 set foldmethod=syntax \u0026#34; 启动 vim 时关闭折叠代码 set nofoldenable \u0026#34; 禁止光标闪烁 set gcr=a:block-blinkon0 \u0026#34; 禁止显示滚动条 set guioptions-=l set guioptions-=L set guioptions-=r set guioptions-=R \u0026#34; 高亮显示当前行/列 set cursorline set cursorcolumn \u0026#34; 让配置变更立即生效 autocmd BufWritePost $MYVIMRC source $MYVIMRC \u0026#34; normal 模式 keymap nnoremap x \u0026#34;_x nnoremap X \u0026#34;_X nnoremap d \u0026#34;_d nnoremap dd \u0026#34;_dd nnoremap D \u0026#34;_D nnoremap s \u0026#34;_s nnoremap S \u0026#34;_S nnoremap c \u0026#34;_c nnoremap C \u0026#34;_C \u0026#34; insert 模式 inoremap $( ()\u0026lt;esc\u0026gt;i inoremap $\u0026lt; \u0026lt;\u0026gt;\u0026lt;esc\u0026gt;i inoremap ${ {}\u0026lt;esc\u0026gt;i inoremap $[ []\u0026lt;esc\u0026gt;i inoremap $\u0026#39; \u0026#39;\u0026#39;\u0026lt;esc\u0026gt;i inoremap $\u0026#34; \u0026#34;\u0026#34;\u0026lt;esc\u0026gt;i \u0026#34; visual 模式 vnoremap s \u0026#34;_s vnoremap S \u0026#34;_S vnoremap z) c()\u0026lt;esc\u0026gt;hp vnoremap z} c{}\u0026lt;esc\u0026gt;hp vnoremap z] c[]\u0026lt;esc\u0026gt;hp vnoremap z\u0026#39; c\u0026#39;\u0026#39;\u0026lt;esc\u0026gt;hp vnoremap z\u0026#34; c\u0026#34;\u0026#34;\u0026lt;esc\u0026gt;hp vnoremap z\u0026gt; c\u0026lt;\u0026gt;\u0026lt;esc\u0026gt;hp vnoremap z` c``\u0026lt;esc\u0026gt;hp \u0026#34; NERDTree let g:NERDTreeIndicatorMapCustom = { \\ \u0026#34;Modified\u0026#34; : \u0026#34;✹\u0026#34;, \\ \u0026#34;Staged\u0026#34; : \u0026#34;✚\u0026#34;, \\ \u0026#34;Untracked\u0026#34; : \u0026#34;✭\u0026#34;, \\ \u0026#34;Renamed\u0026#34; : \u0026#34;➜\u0026#34;, \\ \u0026#34;Unmerged\u0026#34; : \u0026#34;═\u0026#34;, \\ \u0026#34;Deleted\u0026#34; : \u0026#34;✖\u0026#34;, \\ \u0026#34;Dirty\u0026#34; : \u0026#34;✗\u0026#34;, \\ \u0026#34;Clean\u0026#34; : \u0026#34;✔︎\u0026#34;, \\ \u0026#34;Unknown\u0026#34; : \u0026#34;?\u0026#34; \\ } \u0026#34; 自动开启NERDTree \u0026#34; autocmd vimenter * NERDTree \u0026#34; UltiSnips let g:UltiSnipsExpandTrigger=\u0026#34;\u0026lt;Leader\u0026gt;\u0026lt;TAB\u0026gt;\u0026#34; let g:UltiSnipsJumpForwardTrigger=\u0026#34;\u0026lt;c-f\u0026gt;\u0026#34; let g:UltiSnipsJumpBackwardTrigger=\u0026#34;\u0026lt;c-b\u0026gt;\u0026#34; \u0026#34;au BufRead,BufNewFile *.go set filetype=go \u0026#34; ycm \u0026#34; let g:ycm_key_list_select_completion=[\u0026#39;\u0026lt;c-n\u0026gt;\u0026#39;] \u0026#34; let g:ycm_key_list_previous_completion=[\u0026#39;\u0026lt;c-p\u0026gt;\u0026#39;] \u0026#34; let g:ycm_key_invoke_completion = \u0026#39;\u0026lt;C-Space\u0026gt;\u0026#39; \u0026#34; \u0026#34; 关闭加载.ycm_extra_conf.py提示 \u0026#34; let g:ycm_confirm_extra_conf=0 \u0026#34; \u0026#34; 开启 YCM 基于标签引擎 \u0026#34; let g:ycm_collect_identifiers_from_tags_files=1 \u0026#34; \u0026#34; 从第2个键入字符就开始罗列匹配项 \u0026#34; let g:ycm_min_num_of_chars_for_completion=1 \u0026#34; \u0026#34; 禁止缓存匹配项,每次都重新生成匹配项 \u0026#34; let g:ycm_cache_omnifunc=0 \u0026#34; \u0026#34; 语法关键字补全 \u0026#34; let g:ycm_seed_identifiers_with_syntax=1 \u0026#34; \u0026#34; 设置在下面几种格式的文件上屏蔽ycm \u0026#34; let g:ycm_filetype_blacklist = { \u0026#34; \\ \u0026#39;typescript.tsx\u0026#39; : 1, \u0026#34; \\ \u0026#39;typescript\u0026#39; : 1, \u0026#34; \\} \u0026#34; \u0026#34; 注释和字符串中的文字也会被收入补全 \u0026#34; let g:ycm_collect_identifiers_from_comments_and_strings = 0 \u0026#34; \u0026#34; 输入第2个字符开始补全 \u0026#34; let g:ycm_min_num_of_chars_for_completion=2 \u0026#34; 注释 \u0026#34; Add spaces after comment delimiters by default let g:NERDSpaceDelims = 1 \u0026#34; Use compact syntax for prettified multi-line comments let g:NERDCompactSexyComs = 1 \u0026#34; Align line-wise comment delimiters flush left instead of following code indentation let g:NERDDefaultAlign = \u0026#39;left\u0026#39; \u0026#34; Set a language to use its alternate delimiters by default let g:NERDAltDelims_java = 1 \u0026#34; Add your own custom formats or override the defaults let g:NERDCustomDelimiters = { \u0026#39;c\u0026#39;: { \u0026#39;left\u0026#39;: \u0026#39;/**\u0026#39;,\u0026#39;right\u0026#39;: \u0026#39;*/\u0026#39; } } \u0026#34; Allow commenting and inverting empty lines (useful when commenting a region) let g:NERDCommentEmptyLines = 1 \u0026#34; Enable trimming of trailing whitespace when uncommenting let g:NERDTrimTrailingWhitespace = 1 \u0026#34; Enable NERDCommenterToggle to check all selected lines is commented or not let g:NERDToggleCheckAllLines = 1 \u0026#34; coc let g:coc_global_extensions = [ \\ \u0026#39;coc-json\u0026#39;, \\ \u0026#39;coc-html\u0026#39;, \\ \u0026#39;coc-css\u0026#39;, \\ ] set cmdheight=2 set updatetime=300 set shortmess+=c set signcolumn=yes au BufNewFile,BufRead *.ts setlocal filetype=typescript au BufNewFile,BufRead *.tsx setlocal filetype=typescript.tsx nmap \u0026lt;silent\u0026gt; gd \u0026lt;Plug\u0026gt;(coc-definition) nmap \u0026lt;silent\u0026gt; gy \u0026lt;Plug\u0026gt;(coc-type-definition) nmap \u0026lt;silent\u0026gt; gi \u0026lt;Plug\u0026gt;(coc-implementation) nmap \u0026lt;silent\u0026gt; gr \u0026lt;Plug\u0026gt;(coc-references) nmap \u0026lt;leader\u0026gt;rn \u0026lt;Plug\u0026gt;(coc-rename) nmap \u0026lt;silent\u0026gt; [c \u0026lt;Plug\u0026gt;(coc-diagnostic-prev) nmap \u0026lt;silent\u0026gt; ]c \u0026lt;Plug\u0026gt;(coc-diagnostic-next) nmap \u0026lt;leader\u0026gt;a \u0026lt;Plug\u0026gt;(coc-codeaction-selected) nmap \u0026lt;leader\u0026gt;ac \u0026lt;Plug\u0026gt;(coc-codeaction) nmap \u0026lt;leader\u0026gt;qf \u0026lt;Plug\u0026gt;(coc-fix-current) nmap \u0026lt;silent\u0026gt; \u0026lt;TAB\u0026gt; \u0026lt;Plug\u0026gt;(coc-range-select) xmap \u0026lt;silent\u0026gt; \u0026lt;TAB\u0026gt; \u0026lt;Plug\u0026gt;(coc-range-select) xmap \u0026lt;silent\u0026gt; \u0026lt;S-TAB\u0026gt; \u0026lt;Plug\u0026gt;(coc-range-select-backword) xmap \u0026lt;leader\u0026gt;a \u0026lt;Plug\u0026gt;(coc-codeaction-selected) \u0026#34; 显示文档 nnoremap \u0026lt;silent\u0026gt; K :call \u0026lt;SID\u0026gt;show_documentation()\u0026lt;CR\u0026gt; \u0026#34; 回车：补全框?确认补全:回车可以撤回 inoremap \u0026lt;expr\u0026gt; \u0026lt;cr\u0026gt; pumvisible() ? \u0026#34;\\\u0026lt;C-y\u0026gt;\u0026#34; : \u0026#34;\\\u0026lt;C-g\u0026gt;u\\\u0026lt;CR\u0026gt;\u0026#34; \u0026#34; \u0026lt;c-c\u0026gt;触发补全 inoremap \u0026lt;silent\u0026gt;\u0026lt;expr\u0026gt; \u0026lt;c-c\u0026gt; coc#refresh() inoremap \u0026lt;expr\u0026gt;\u0026lt;S-TAB\u0026gt; pumvisible() ? \u0026#34;\\\u0026lt;C-p\u0026gt;\u0026#34; : \u0026#34;\\\u0026lt;C-h\u0026gt;\u0026#34; inoremap \u0026lt;silent\u0026gt;\u0026lt;expr\u0026gt; \u0026lt;TAB\u0026gt; \\ pumvisible() ? \u0026#34;\\\u0026lt;C-n\u0026gt;\u0026#34; : \\ \u0026lt;SID\u0026gt;check_back_space() ? \u0026#34;\\\u0026lt;TAB\u0026gt;\u0026#34; : \\ coc#refresh() \u0026#34; Use `:Format` to format current buffer command! -nargs=0 Format :call CocAction(\u0026#39;format\u0026#39;) \u0026#34; Use `:Fold` to fold current buffer command! -nargs=? Fold :call CocAction(\u0026#39;fold\u0026#39;, \u0026lt;f-args\u0026gt;) \u0026#34; set statusline^=%{coc#status()}%{get(b:,\u0026#39;coc_current_function\u0026#39;,\u0026#39;\u0026#39;)} \u0026#34; autocmd CursorHold * silent call CocActionAsync(\u0026#39;highlight\u0026#39;) function! s:show_documentation() if (index([\u0026#39;vim\u0026#39;,\u0026#39;help\u0026#39;], \u0026amp;filetype) \u0026gt;= 0) execute \u0026#39;h \u0026#39;.expand(\u0026#39;\u0026lt;cword\u0026gt;\u0026#39;) else call CocAction(\u0026#39;doHover\u0026#39;) endif endfunction function! s:check_back_space() abort let col = col(\u0026#39;.\u0026#39;) - 1 return !col || getline(\u0026#39;.\u0026#39;)[col - 1] =~# \u0026#39;\\s\u0026#39; endfunction \u0026#34; -------------------- plug ------------------------ call plug#begin(\u0026#39;~/.vim/plugins\u0026#39;) Plug \u0026#39;dracula/vim\u0026#39;, { \u0026#39;as\u0026#39;: \u0026#39;dracula\u0026#39; } Plug \u0026#39;mhinz/vim-startify\u0026#39; Plug \u0026#39;SirVer/ultisnips\u0026#39; Plug \u0026#39;jiangmiao/auto-pairs\u0026#39; Plug \u0026#39;vim-airline/vim-airline\u0026#39; Plug \u0026#39;vim-airline/vim-airline-themes\u0026#39; Plug \u0026#39;scrooloose/nerdcommenter\u0026#39; \u0026#34; NERDTree Plug \u0026#39;scrooloose/nerdtree\u0026#39; \u0026#34; git Plug \u0026#39;Xuyuanp/nerdtree-git-plugin\u0026#39; \u0026#34; icon \u0026#34; Plug \u0026#39;ryanoasis/vim-devicons\u0026#39; \u0026#34; coc \u0026#34; Plug \u0026#39;neoclide/coc.nvim\u0026#39;, {\u0026#39;do\u0026#39;: \u0026#39;yarn install --frozen-lockfile\u0026#39; } \u0026#34; golang \u0026#34; Plug \u0026#39;fatih/vim-go\u0026#39; \u0026#34; typescript \u0026#34; Plug \u0026#39;leafgarland/typescript-vim\u0026#39;, {\u0026#39;for\u0026#39;: [\u0026#39;typescript\u0026#39;, \u0026#39;typescript.tsx\u0026#39;, \u0026#39;js\u0026#39;]} \u0026#34; prettier \u0026#34;Plug \u0026#39;prettier/vim-prettier\u0026#39;, { \u0026#34; \\ \u0026#39;do\u0026#39;: \u0026#39;yarn install\u0026#39;, \u0026#34; \\ \u0026#39;for\u0026#39;: [\u0026#39;javascript\u0026#39;, \u0026#39;typescript\u0026#39;, \u0026#39;css\u0026#39;, \u0026#39;less\u0026#39;, \u0026#39;scss\u0026#39;, \u0026#39;json\u0026#39;, \u0026#39;graphql\u0026#39;, \u0026#39;markdown\u0026#39;, \u0026#39;vue\u0026#39;, \u0026#39;yaml\u0026#39;, \u0026#39;html\u0026#39;] } \u0026#34;Plug \u0026#39;Valloric/YouCompleteMe\u0026#39; call plug#end() \u0026#34; 替换函数 \u0026#34; 参数说明： \u0026#34; confirm：是否替换前逐一确认 \u0026#34; wholeword：是否整词匹配 \u0026#34; replace：被替换字符串 function! Replace(confirm, wholeword, replace) wa let flag = \u0026#39;\u0026#39; if a:confirm let flag .= \u0026#39;gec\u0026#39; else let flag .= \u0026#39;ge\u0026#39; endif let search = \u0026#39;\u0026#39; if a:wholeword let search .= \u0026#39;\\\u0026lt;\u0026#39; . escape(expand(\u0026#39;\u0026lt;cword\u0026gt;\u0026#39;), \u0026#39;/\\.*$^~[\u0026#39;) . \u0026#39;\\\u0026gt;\u0026#39; else let search .= expand(\u0026#39;\u0026lt;cword\u0026gt;\u0026#39;) endif let replace = escape(a:replace, \u0026#39;/\\\u0026amp;~\u0026#39;) execute \u0026#39;argdo %s/\u0026#39; . search . \u0026#39;/\u0026#39; . replace . \u0026#39;/\u0026#39; . flag . \u0026#39;| update\u0026#39; endfunction \u0026#34; 不确认、非整词 nnoremap \u0026lt;Leader\u0026gt;R :call Replace(0, 0, input(\u0026#39;Replace \u0026#39;.expand(\u0026#39;\u0026lt;cword\u0026gt;\u0026#39;).\u0026#39; with: \u0026#39;))\u0026lt;CR\u0026gt; \u0026#34; 不确认、整词 nnoremap \u0026lt;Leader\u0026gt;rw :call Replace(0, 1, input(\u0026#39;Replace \u0026#39;.expand(\u0026#39;\u0026lt;cword\u0026gt;\u0026#39;).\u0026#39; with: \u0026#39;))\u0026lt;CR\u0026gt; \u0026#34; 确认、非整词 nnoremap \u0026lt;Leader\u0026gt;rc :call Replace(1, 0, input(\u0026#39;Replace \u0026#39;.expand(\u0026#39;\u0026lt;cword\u0026gt;\u0026#39;).\u0026#39; with: \u0026#39;))\u0026lt;CR\u0026gt; \u0026#34; 确认、整词 nnoremap \u0026lt;Leader\u0026gt;rcw :call Replace(1, 1, input(\u0026#39;Replace \u0026#39;.expand(\u0026#39;\u0026lt;cword\u0026gt;\u0026#39;).\u0026#39; with: \u0026#39;))\u0026lt;CR\u0026gt; nnoremap \u0026lt;Leader\u0026gt;rwc :call Replace(1, 1, input(\u0026#39;Replace \u0026#39;.expand(\u0026#39;\u0026lt;cword\u0026gt;\u0026#39;).\u0026#39; with: \u0026#39;))\u0026lt;CR\u0026gt; ","permalink":"https://rx-78-kum0.github.io/posts/vimrc/","summary":"\u0026#34; .vimrc \u0026#34; Configuration file for vim set modelines=0 \u0026#34; Don\u0026#39;t write backup file if vim is being called by \u0026#34;crontab -e\u0026#34; \u0026#34; au BufWrite /private/tmp/crontab.* set nowritebackup nobackup \u0026#34; Don\u0026#39;t write backup file if vim is being called by \u0026#34;chpass\u0026#34; \u0026#34; au BufWrite /private/etc/pw.* set nowritebackup nobackup set nobackup set nowritebackup let skip_defaults_vim=1 \u0026#34; \u0026lt;leader\u0026gt; let g:mapleader=\u0026#34;,\u0026#34; \u0026#34; 去掉有关vi一致性模式，避免以前版本的bug和局限 set nocompatible \u0026#34; 设置退格键可用 set backspace=2 \u0026#34; utf-8 set encoding=UTF-8 \u0026#34; 主题 \u0026#34; set background=dark \u0026#34; colorscheme dracula \u0026#34; 函数方法名加粗 let g:enable_bold_font = 1 \u0026#34; 注释斜体 let g:enable_italic_font = 1 \u0026#34; 透明背景 let g:hybrid_transparent_background = 1 \u0026#34; airline_theme let g:airline_theme = \u0026#34;hybrid\u0026#34; \u0026#34; 行号 set nu!","title":"vimrc"},{"content":" golang 接口值: 一个包含 nil 指针的接口不是 nil 接口.\n一个不包含任何值的 nil 接口值和一个刚好包含 nil 指针的接口值是不同的.\n 接口值由两个部分组成:\n 一个具体的类型 那个类型的值  它们被称为接口的动态类型和动态值.\n   type value     x x    接口的零值是指动态类型为nil, 动态值也为nil.\n   type value     nil nil    这样的接口才能满足 接口值 == nil.\nvar a interface{} fmt.Println(a == nil) // true 一个不包含任何值的 nil 接口值: interface 类型变量的动态类型和动态值都为 nil. 比如 nil, 或者:\nvar a interface{} fmt.Println(a) // a为nil 一个刚好包含 nil 指针的接口值: 赋值给后，interface 类型变量的动态类型不为 nil，动态值为 nil.\nvar a interface{} var b *string a = b fmt.Println(a) // 此时a的动态类型为*string，动态值为nil 这两种对象比较: func main(){ var a interface{} // nil  var b *string // nil  a = b fmt.Println(a == nil) // false  fmt.Println(b == nil) // true  fmt.Println(b == a) // true }   a = nil 为 false: b 赋值给 a, a 的动态类型为 *string, 动态值为 nil, 所以 a = nil 为 false.\n// 空接口 type eface struct { _type *_type // 类型信息  data unsafe.Pointer // 指向数据的指针 } // 带有方法的接口 type iface struct { tab *itab // 存储type信息还有结构实现方法的集合  data unsafe.Pointer // 指向数据的指针 }   根据 interface 的底层实现, a = b 实则是 a.data = unsafe.Pointer(\u0026amp;b). a = nil 才是 a.data = nil.\n  b == nil 为 true: b 是一个空的指针(非接口)类型.\n  b == a 为 true: 值都为 nil, b 是一个空的指针(非接口)类型.\n  ","permalink":"https://rx-78-kum0.github.io/posts/%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%AB-nil-%E6%8C%87%E9%92%88%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%B8%8D%E6%98%AF-nil-%E6%8E%A5%E5%8F%A3/","summary":"golang 接口值: 一个包含 nil 指针的接口不是 nil 接口.\n一个不包含任何值的 nil 接口值和一个刚好包含 nil 指针的接口值是不同的.\n 接口值由两个部分组成:\n 一个具体的类型 那个类型的值  它们被称为接口的动态类型和动态值.\n   type value     x x    接口的零值是指动态类型为nil, 动态值也为nil.\n   type value     nil nil    这样的接口才能满足 接口值 == nil.\nvar a interface{} fmt.Println(a == nil) // true 一个不包含任何值的 nil 接口值: interface 类型变量的动态类型和动态值都为 nil. 比如 nil, 或者:","title":"一个包含 nil 指针的接口不是 nil 接口"},{"content":"{ // editor \u0026#34;editor.fontSize\u0026#34;: 14, \u0026#34;editor.snippetSuggestions\u0026#34;: \u0026#34;top\u0026#34;, \u0026#34;editor.formatOnSave\u0026#34;: true, \u0026#34;explorer.confirmDragAndDrop\u0026#34;: true, \u0026#34;explorer.confirmDelete\u0026#34;: false, \u0026#34;editor.detectIndentation\u0026#34;: false, \u0026#34;files.autoSave\u0026#34;: \u0026#34;off\u0026#34;, // \u0026#34;editor.fontFamily\u0026#34;: \u0026#34;\u0026#39;FuraCode\u0026#39;, Menlo, Monaco, \u0026#39;Courier New\u0026#39;, monospace\u0026#34;, \u0026#34;editor.fontLigatures\u0026#34;: true, \u0026#34;workbench.iconTheme\u0026#34;: \u0026#34;material-icon-theme\u0026#34;, \u0026#34;workbench.colorTheme\u0026#34;: \u0026#34;Nebula\u0026#34;, // prettier \u0026#34;prettier.printWidth\u0026#34;: 120, \u0026#34;editor.tabSize\u0026#34;: 2, \u0026#34;prettier.singleQuote\u0026#34;: false, \u0026#34;prettier.semi\u0026#34;: true, // typescript \u0026#34;typescript.updateImportsOnFileMove.enabled\u0026#34;: \u0026#34;always\u0026#34;, // emmet \u0026#34;emmet.includeLanguages\u0026#34;: { \u0026#34;javascript\u0026#34;: \u0026#34;javascriptreact\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;typescriptreact\u0026#34; }, \u0026#34;emmet.triggerExpansionOnTab\u0026#34;: true, // 装饰器 \u0026#34;javascript.implicitProjectConfig.experimentalDecorators\u0026#34;: true, // stylus \u0026#34;stylusSupremacy.insertColons\u0026#34;: false, // 是否插入冒号 \u0026#34;stylusSupremacy.insertSemicolons\u0026#34;: false, // 是否插入分好 \u0026#34;stylusSupremacy.insertBraces\u0026#34;: false, // 是否插入大括号 \u0026#34;stylusSupremacy.insertNewLineAroundImports\u0026#34;: true, // import之后是否换行 \u0026#34;stylusSupremacy.insertNewLineAroundBlocks\u0026#34;: true, \u0026#34;stylusSupremacy.insertSpaceAfterComment\u0026#34;: true, \u0026#34;window.zoomLevel\u0026#34;: 0, // Formatter \u0026#34;[javascript]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;vscode.typescript-language-features\u0026#34; }, \u0026#34;[typescript]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34; }, \u0026#34;[json]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34; }, \u0026#34;[jsonc]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34; }, \u0026#34;[typescriptreact]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34; }, \u0026#34;[html]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34; }, \u0026#34;search.followSymlinks\u0026#34;: false, // vim \u0026#34;vim.useSystemClipboard\u0026#34;: true, \u0026#34;vim.hlsearch\u0026#34;: true, \u0026#34;vim.smartcase\u0026#34;: true, \u0026#34;vim.leader\u0026#34;: \u0026#34;,\u0026#34;, \u0026#34;vim.highlightedyank.enable\u0026#34;: true, \u0026#34;vim.highlightedyank.duration\u0026#34;: 1000, \u0026#34;vim.highlightedyank.color\u0026#34;: \u0026#34;rgba(250, 240, 170, 0.5)\u0026#34;, \u0026#34;vim.history\u0026#34;: 100, // \u0026#34;vim.cursorStylePerMode.insert\u0026#34;: \u0026#34;line\u0026#34;, // \u0026#34;vim.cursorStylePerMode.normal\u0026#34;: \u0026#34;underline\u0026#34;, // \u0026#34;vim.cursorStylePerMode.replace\u0026#34;: \u0026#34;underline\u0026#34;, // \u0026#34;vim.cursorStylePerMode.visual\u0026#34;: \u0026#34;blink\u0026#34;, // \u0026#34;vim.cursorStylePerMode.visualblock\u0026#34;: \u0026#34;blink\u0026#34;, // \u0026#34;vim.cursorStylePerMode.visualline\u0026#34;: \u0026#34;underline\u0026#34;, \u0026#34;vim.easymotion\u0026#34;: true, \u0026#34;vim.easymotionMarkerFontSize\u0026#34;: \u0026#34;16\u0026#34;, \u0026#34;vim.easymotionMarkerHeight\u0026#34;: 16, \u0026#34;vim.easymotionMarkerWidthPerChar\u0026#34;: 9, \u0026#34;vim.normalModeKeyBindings\u0026#34;: [], \u0026#34;vim.normalModeKeyBindingsNonRecursive\u0026#34;: [ { \u0026#34;before\u0026#34;: [\u0026#34;d\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;d\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;d\u0026#34;, \u0026#34;d\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;d\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;D\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;D\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;t\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;x\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;X\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;X\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;s\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;s\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;S\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;S\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;c\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;c\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;C\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;C\u0026#34;] } ], \u0026#34;vim.visualModeKeyBindings\u0026#34;: [ { \u0026#34;before\u0026#34;: [\u0026#34;s\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;s\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;S\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;S\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;z\u0026#34;, \u0026#34;)\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;c\u0026#34;, \u0026#34;(\u0026#34;, \u0026#34;)\u0026#34;, \u0026#34;\u0026lt;Esc\u0026gt;\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;p\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;z\u0026#34;, \u0026#34;}\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;c\u0026#34;, \u0026#34;{\u0026#34;, \u0026#34;}\u0026#34;, \u0026#34;\u0026lt;Esc\u0026gt;\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;p\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;z\u0026#34;, \u0026#34;]\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;c\u0026#34;, \u0026#34;[\u0026#34;, \u0026#34;]\u0026#34;, \u0026#34;\u0026lt;Esc\u0026gt;\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;p\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;z\u0026#34;, \u0026#34;\u0026#39;\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;c\u0026#34;, \u0026#34;\u0026#39;\u0026#34;, \u0026#34;\u0026#39;\u0026#34;, \u0026#34;\u0026lt;Esc\u0026gt;\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;p\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;z\u0026#34;, \u0026#34;\\\u0026#34;\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;c\u0026#34;, \u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;\u0026lt;Esc\u0026gt;\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;p\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;z\u0026#34;, \u0026#34;\u0026gt;\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;c\u0026#34;, \u0026#34;\u0026lt;\u0026#34;, \u0026#34;\u0026gt;\u0026#34;, \u0026#34;\u0026lt;Esc\u0026gt;\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;p\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;z\u0026#34;, \u0026#34;`\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;c\u0026#34;, \u0026#34;`\u0026#34;, \u0026#34;`\u0026#34;, \u0026#34;\u0026lt;Esc\u0026gt;\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;p\u0026#34;] } ], \u0026#34;vim.handleKeys\u0026#34;: { \u0026#34;\u0026lt;C-a\u0026gt;\u0026#34;: false, \u0026#34;\u0026lt;C-f\u0026gt;\u0026#34;: false } } ","permalink":"https://rx-78-kum0.github.io/posts/vscode/","summary":"{ // editor \u0026#34;editor.fontSize\u0026#34;: 14, \u0026#34;editor.snippetSuggestions\u0026#34;: \u0026#34;top\u0026#34;, \u0026#34;editor.formatOnSave\u0026#34;: true, \u0026#34;explorer.confirmDragAndDrop\u0026#34;: true, \u0026#34;explorer.confirmDelete\u0026#34;: false, \u0026#34;editor.detectIndentation\u0026#34;: false, \u0026#34;files.autoSave\u0026#34;: \u0026#34;off\u0026#34;, // \u0026#34;editor.fontFamily\u0026#34;: \u0026#34;\u0026#39;FuraCode\u0026#39;, Menlo, Monaco, \u0026#39;Courier New\u0026#39;, monospace\u0026#34;, \u0026#34;editor.fontLigatures\u0026#34;: true, \u0026#34;workbench.iconTheme\u0026#34;: \u0026#34;material-icon-theme\u0026#34;, \u0026#34;workbench.colorTheme\u0026#34;: \u0026#34;Nebula\u0026#34;, // prettier \u0026#34;prettier.printWidth\u0026#34;: 120, \u0026#34;editor.tabSize\u0026#34;: 2, \u0026#34;prettier.singleQuote\u0026#34;: false, \u0026#34;prettier.semi\u0026#34;: true, // typescript \u0026#34;typescript.updateImportsOnFileMove.enabled\u0026#34;: \u0026#34;always\u0026#34;, // emmet \u0026#34;emmet.includeLanguages\u0026#34;: { \u0026#34;javascript\u0026#34;: \u0026#34;javascriptreact\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;typescriptreact\u0026#34; }, \u0026#34;emmet.triggerExpansionOnTab\u0026#34;: true, // 装饰器 \u0026#34;javascript.implicitProjectConfig.experimentalDecorators\u0026#34;: true, // stylus \u0026#34;stylusSupremacy.insertColons\u0026#34;: false, // 是否插入冒号 \u0026#34;stylusSupremacy.insertSemicolons\u0026#34;: false, // 是否插入分好 \u0026#34;stylusSupremacy.","title":"vscode"}]