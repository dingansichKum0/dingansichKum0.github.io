[{"content":"不做市场预测 产品对公司净利润的影响有多大 爆款产品虽然贡献高额利润，但可能占公司营收比例很小，对总利润影响甚微。\n公司越大涨幅越小 6种类型公司股票  缓慢增长型 稳定增长型 快速增长型 周期型 困境反转型 隐蔽资产型  选股准则  公司名字枯燥乏味甚至可笑 公司业务枯燥乏味 公司业务令人厌恶 公司从母公司分拆出来 机构没有持股，分析师不追踪 公司被谣言缠身 公司业务让人感到压抑 公司处于一个零增长行业（竞争更小，扩张更容易） 公司有一个利基（被忽略的细分领域、排他性独家经营） 人们要不断购买公司的产品 公司是高科技产品用户 公司内部人士买入自家公司股票 公司回购  避开热门行业的热门股 增长快但竞争大，技术迭代快\n小心那些被吹捧成下一个“xxx”的公司 当前xxx可能就是顶点，后面的都不会好过。\n避免通过并购导致“多元恶化”的公司 从多元恶化到瘦身重组则是不错的投资机会。多元优化，协同作用（1+1\u0026gt;2），业务之间相互关联，不并购完全无关的业务。 回购股票则是最纯粹的协同作用。\n小心过于依赖大客户的供应商公司 比如果链，收入不稳定，大客户压价具有谈判优势。\n投资的价值：资产+收益 收益最为重要。判断股价是否高估的快捷方式：比较股价走势图与收益图是否相符。\n关注股市整体市盈率 是否整体高估。可能面料走熊风险。\n利率水平影响 利率较低时，债券的投资吸引力降低，投资者更愿意购买股票时支付更高的价格。\n关注公司未来收益 措施：\n 削减成本 提高价格 开拓新市场 原市场销售更多产品 重整亏损业务  下单之前  对这只股票感兴趣的原因是什么 需要具备哪些条件这家公司才能取得成功 这家公司未来发展面临哪些障碍  财报  现金及现金等价物越来越、长期债务越来越少，是企业兴旺的明确信号。 某种产品在总销售额中的占比。 市盈率与收益增长率相等。如果市盈率小于收益增长率则股价低估；反之高估。 现金头寸/总股本=每股现金扣除负债后的净现金价值。  负债  负债/股东权益项目=负债权益比率。权益占比越大财务实力越雄厚。长期负债优于短期负债。短期负债可能立即归还造成挤兑破产。 负债很大而资产账面价值又被高估，这类公司的股票非常危险。账面价值可能远低于实际价值。  隐蔽资产 早年购入的自然资源、品牌价值、专利、特许经营权、收购导致的商誉均摊、所得税减免。\n现金流量 现金流入超过现金流出的净流入数。\n存货 存货增长速度大于销售增长速度是一个十分危险的信号。\n增长率 唯一能够影响股价的增长率是收益增长率。增长率和市盈率较高的股票比增长率和市盈率较低更值得买入。\n税后利润 行业景气阶段买入利润率高的更好，但行业复苏阶段则利润率低的更好。因为利润基数小，增长率更高。\n基本面分析 所有公司  市盈率； 机构投资者占总股本越低越好； 公司回购，高管增持； 公司收益持续稳定增长； 资产负债情况（负债与股东权益比率）； 现金头寸、每股净现金；  缓慢增长型 不考虑不做记录。\n稳定增长型 买入时机，低估买入；是否进行不相关的多元化经营；检查长期收益增长率；在经济衰退或市场大跌时期表现是否稳定。\n周期型  密切关注公司存货变化及市场供需平衡； 新的竞争对手出现； 高市盈率买入，低市盈率卖出； 所在行业的周期型，例如汽车行业三四年一个周期；  快速增长型  爆款产品所在该公司收入比例； 近几年增长率是否处于20-25%（更高的增长率虽好但担心能否保持）； 公司已经在一定规模证明了经营模式的成功； 公司业务是否还有很大增长空间； 市盈率是否等于或接近收益增长率； 公司扩张速度是否加快； 只有很少机构投资者持有该公司股票；  困境反转型  现金与债务比是否安全； 债务结构，是否通过大量增发筹资； 重振措施（削减成本，提高价格，开拓新市场，原市场销售更多产品，重整亏损业务）  隐蔽资产型  隐蔽资产规模； 公司债务是否会抵消隐蔽资产  投资组合：3-10只股票 卖出上涨，补仓下跌都不是明智之举，应该根据公司情况看空或看多。 卖出上涨是因为增速是否见顶不足以支撑目前股价，补仓下跌是否因为公司迎来转机或者前景良好。\n坚持持有“当我的股票下跌25%我就追加买入”；戒除“当我的股票下跌25%我就卖出” 不设止损止盈，坚持持有“只要公司发展前景继续保持不变或变得更好”的股票 在市场消极大跌中寻找买入时机 小心煽动效应 担心过度上涨或下跌（降准降息，m1m2等消息）\n何时卖出：  周期型：市盈率大幅下降；存货不断增加；大宗商品下跌； 快速增长型：增速放缓；竞争激烈 逆境反转型：公司转危为安；市盈率增长到达较高水平； 隐蔽资产型：公司债务导致资产下降；并购出现或资产得到曝光  增长缓慢型  公司市场份额流失； 研发削减，没有开发新产品； 多元化经营；高价收购负债恶化  稳定增长型  同行业对比市盈率； 增长放缓；  周期型  市盈率大幅下降； 存货不断增加； 大宗商品下跌；  快速增长型  增速放缓； 竞争激烈；  逆境反转型  公司转危为安； 市盈率增长到达较高水平；  隐蔽资产型  公司债务导致资产下降； 并购出现或资产得到曝光；  错过不是亏损 但因为错过导致执行一些错误的操作是会付出真金白银的亏损（比如因为错过xx而买入可能成为下一个xx的公司）。\n谬论  股价出现上涨，所以选择一定是对的； 股价出现下跌，所以选择一定是错的  ","permalink":"https://zakudriver.github.io/posts/%E5%BD%BC%E5%BE%97%E6%9E%97%E5%A5%87%E7%9A%84%E6%88%90%E5%8A%9F%E6%8A%95%E8%B5%84/","summary":"不做市场预测 产品对公司净利润的影响有多大 爆款产品虽然贡献高额利润，但可能占公司营收比例很小，对总利润影响甚微。\n公司越大涨幅越小 6种类型公司股票  缓慢增长型 稳定增长型 快速增长型 周期型 困境反转型 隐蔽资产型  选股准则  公司名字枯燥乏味甚至可笑 公司业务枯燥乏味 公司业务令人厌恶 公司从母公司分拆出来 机构没有持股，分析师不追踪 公司被谣言缠身 公司业务让人感到压抑 公司处于一个零增长行业（竞争更小，扩张更容易） 公司有一个利基（被忽略的细分领域、排他性独家经营） 人们要不断购买公司的产品 公司是高科技产品用户 公司内部人士买入自家公司股票 公司回购  避开热门行业的热门股 增长快但竞争大，技术迭代快\n小心那些被吹捧成下一个“xxx”的公司 当前xxx可能就是顶点，后面的都不会好过。\n避免通过并购导致“多元恶化”的公司 从多元恶化到瘦身重组则是不错的投资机会。多元优化，协同作用（1+1\u0026gt;2），业务之间相互关联，不并购完全无关的业务。 回购股票则是最纯粹的协同作用。\n小心过于依赖大客户的供应商公司 比如果链，收入不稳定，大客户压价具有谈判优势。\n投资的价值：资产+收益 收益最为重要。判断股价是否高估的快捷方式：比较股价走势图与收益图是否相符。\n关注股市整体市盈率 是否整体高估。可能面料走熊风险。\n利率水平影响 利率较低时，债券的投资吸引力降低，投资者更愿意购买股票时支付更高的价格。\n关注公司未来收益 措施：\n 削减成本 提高价格 开拓新市场 原市场销售更多产品 重整亏损业务  下单之前  对这只股票感兴趣的原因是什么 需要具备哪些条件这家公司才能取得成功 这家公司未来发展面临哪些障碍  财报  现金及现金等价物越来越、长期债务越来越少，是企业兴旺的明确信号。 某种产品在总销售额中的占比。 市盈率与收益增长率相等。如果市盈率小于收益增长率则股价低估；反之高估。 现金头寸/总股本=每股现金扣除负债后的净现金价值。  负债  负债/股东权益项目=负债权益比率。权益占比越大财务实力越雄厚。长期负债优于短期负债。短期负债可能立即归还造成挤兑破产。 负债很大而资产账面价值又被高估，这类公司的股票非常危险。账面价值可能远低于实际价值。  隐蔽资产 早年购入的自然资源、品牌价值、专利、特许经营权、收购导致的商誉均摊、所得税减免。","title":"彼得·林奇的成功投资"},{"content":"重载允许函数（方法）接收不同类型或数量的参数时，做出不同的处理。\njs本身作为动态脚本语言是支持重载的，typescript的重载更多的是类型系统的补全。\n 函数 function func(arg: number): number; function func(arg: string): string; function func(arg: number | string): number | string { if (typeof arg === \u0026#34;number\u0026#34;) { return 0; } return \u0026#34;0\u0026#34;; } lambda lambda的重载需要通过定义 type 实现。\ntype TFunc = { (x: number): number; (x: number, y: string): string; }; export const func: TFunc = (x: number, y = \u0026#34;\u0026#34;): any =\u0026gt; { if (y) { return `optional: ${y}`; } return x; }; 方法 静态方法 class C { static method(arg: string): string; static method(): void; static method(arg?: string) { return arg; } } 实例方法 class C { public handle(arg: string): string; public handle(arg: boolean): void; public handle(arg: string | boolean) { if (typeof arg === \u0026#34;string\u0026#34;) { return arg; } return; } } React组件 普通函数 interface IInputSelectProps\u0026lt;T\u0026gt; { options: T[]; getOptionsLabel?: (arg: T) =\u0026gt; string; getOptionsValue?: (arg: T) =\u0026gt; string; } export function InputSelect\u0026lt;T\u0026gt;(props: IInputSelectProps\u0026lt;T\u0026gt;): ReactElement; export function InputSelect({ options, getOptionsLabel = (arg) =\u0026gt; arg, getOptionsValue = (arg) =\u0026gt; arg, }: IInputSelectProps\u0026lt;string\u0026gt;): ReactElement { return \u0026lt;div /\u0026gt;; } \u0026lt;InputSelect options={[{ label: \u0026#34;1\u0026#34;, value: \u0026#34;2\u0026#34; }]} getOptionsLabel={(arg) =\u0026gt; arg.label} getOptionsValue={(arg) =\u0026gt; arg.value} /\u0026gt; lambda interface IInputSelectProps\u0026lt;T\u0026gt; { options: T[]; getOptionsLabel?: (arg: T) =\u0026gt; string; getOptionsValue?: (arg: T) =\u0026gt; string; } type TInputSelect = { (props: IInputSelectProps\u0026lt;string\u0026gt;): ReactElement; \u0026lt;T\u0026gt;(props: IInputSelectProps\u0026lt;T\u0026gt;): ReactElement; }; export const InputSelect: TInputSelect = ({ options, getOptionsLabel = (arg) =\u0026gt; arg, getOptionsValue = (arg) =\u0026gt; arg, }: IInputSelectProps\u0026lt;string\u0026gt;): ReactElement =\u0026gt; { return \u0026lt;div /\u0026gt;; }; \u0026lt;InputSelect options={[{ label: \u0026#34;1\u0026#34;, value: \u0026#34;2\u0026#34; }]} getOptionsLabel={(arg) =\u0026gt; arg.label} getOptionsValue={(arg) =\u0026gt; arg.value} /\u0026gt;; ","permalink":"https://zakudriver.github.io/posts/typescript%E7%9A%84%E9%87%8D%E8%BD%BDoverload/","summary":"重载允许函数（方法）接收不同类型或数量的参数时，做出不同的处理。\njs本身作为动态脚本语言是支持重载的，typescript的重载更多的是类型系统的补全。\n 函数 function func(arg: number): number; function func(arg: string): string; function func(arg: number | string): number | string { if (typeof arg === \u0026#34;number\u0026#34;) { return 0; } return \u0026#34;0\u0026#34;; } lambda lambda的重载需要通过定义 type 实现。\ntype TFunc = { (x: number): number; (x: number, y: string): string; }; export const func: TFunc = (x: number, y = \u0026#34;\u0026#34;): any =\u0026gt; { if (y) { return `optional: ${y}`; } return x; }; 方法 静态方法 class C { static method(arg: string): string; static method(): void; static method(arg?","title":"typescript的重载(Overload)"},{"content":"有三种方式可以加载文件：  load autoload require  使用eval-after-load可以推迟一段代码的执行 (eval-after-load \u0026ldquo;触发条件的文件\u0026rdquo; 待执行的代码) 这里，第一个参数的值必须跟上面三种方式加载文件时的值一模一样\nemacs中的变量作用域 buffer-local变量 声明buffer-local变量  make-variable-buffer-local  各个缓冲区都有各自的buffer-local变量\n make-local-variable  当前缓冲区产生一个局部变量,其他缓冲区仍然使用全局变量(推荐使用)\nbuffer相关函数    with-current-buffer\n;使其中的body表达式在指定的缓冲区里执行(使用指定buffer的配置信息执行body表达式) (with-current-buffer buffer body)      get-buffer\n;得到缓冲区名字的对应缓冲区对象,如果没有这个名字的缓冲区,返回nil (get-buffer buffer-name)      default-value\n;访问符号的全局变量的值 (default-value symbol)      setq-default\n;修改符号作为全局变量的值 (setq-default symbol-name)      local-variable-p\n;测试变量是不是buffer-local的 (local-variable-p symbol [buffer对象])      buffer-local-value\n;得到其他缓冲区内的buffer-local变量值 (buffer-local-value 符号 buffer对象)      default-boundp\n;判断符号是否有全局值 (default-boundp 符号)      makunbound\n;使一个变量的值重新为空 (makunbound 符号)      kill-local-variable\n;清除一个buffer-local变量 (kill-local-variable 符号)      kill-all-local-variables\n;清除所有的buffer-local变量,但是带有属性permanent-local的不会清除,带有这些标记的变量一般都是和缓冲区模式无关的 (kill-all-local-variables)   文件中的本地变量列表  \u0026ldquo;本地变量列表\u0026quot;可以位于任何文件的结尾位置,它的形式如下所示   Local variables: var1 : value1 var2 : value2 ... eval : form1 eval : form2 ... End: 这里定义的var自动是buffer-local的,类似宏一样,value被认为是被引用的 这里的form则会自动执行.\n 可以通过在.emacs中加入   (setq enable-local-variables \u0026#39;query) 来阻止\u0026quot;本地变量列表\u0026quot;生效\n变量本地化  普通变量通过make-localvariable或make-variable-buffer-local变为buffer－local的 make-variable-buffer-local使指定的变量在每个buffer中都是独立的 make-local-variable使变量在当前buffer是独立的，而其他buffer依然共享全局变量 hook变量智能通过make-local-hook变为buffer-local的  elisp中的数据类型 Number Integer 根据机器的不同,Integer有不同的区间(分别由变量most-positive-fixnum和most-negative-fixnum来指示). 但elisp规定最少的范围是从-536870912到536870911.\n任何超过Integer范围的值都认为是Float型\n默认,Integer用10进制来表示数,但也可以用\n #bNNNN表示二进制数 #oNNNN表示八进制数 #xNNNN表示十六进制数 #MrNNNN表示M进制的数  Float Elisp中Float的取值范围与C中的double型一样.\nFloat使用INF表示无穷大. Float还有一个特殊值名为NaN. 当数学函数计算非法表达式时会返回该值.\n(/ 0 0.0) ;-0.0e+NaN (/ -0 0.0) ;-0.0e+NaN (/ 1 0.0) ;1.0e+INF (/ -1 0.0) ;-1.0e+INF    相关函数\n  判断是否为NAN\n(isnan x)\n  (frexp x)\n返回一个元组(S . E),使得S*2^E == x,S的值在[0.5 1)\n  (ldexp S E)\n返回Float值x 使得x == S*2^E\n  (copysign x1 x2)\n假设x1 = S1*2^E1, x2 = S2*2^E2,则返回S1*2^E2的值\n  (logb x)\n返回log2(x)的值,向下取整. 例如(logb 10) =\u0026gt; 3\n    Sequence   获取sequence的长度\n(length mySequence)\n  需要注意的是length不能对点列表和环形列表求长度,但是可以用safe-length代替\nArray 除了char-table之外,创建其他类型的Array都需要指定一个固定长度.\nchar-table的长度是由character code的范围所决定的,不能人工指定\n   vector\nvecotr是sequence的一个子类型\n  如何创建一个vector\n 使用字面量语法:[val1 val2 val3\u0026hellip;]    使用函数(vector val1 val2 val3\u0026hellip;)\n  获取vector的长度\n  (length myVector)\n 获取element  (elt mySeq index) # index从0开始\n 设置element  (aset mySeq index value)\n 将多个Sequence组合成一个vector  (voncat seq1 seq2 \u0026hellip;)\n 将vector转换成list  (append myVector nil)\n     bool-vector\n bool-vector只能存放nil或t bool-vector的输出格式与字符串类似,但在前面加上`#\u0026amp;长度`作为标识: #\u0026amp;长度\u0026#34;内容\u0026#34; ;这里的长度表示bool-vector的长度,内容的二进制为vector的内容,内容的现实方式为字符串 (make-bool-vector 3 t) ; =\u0026gt; #\u0026amp;3\u0026#34;^G\u0026#34; ?\\C-g == 7 (make-bool-vector 3 nil) ; =\u0026gt; #\u0026amp;3\u0026#34;^@\u0026#34; ?\\C-@ == 0 (equal #\u0026amp;3\u0026#34;\\377\u0026#34; #\u0026amp;3\u0026#34;\\007\u0026#34;) ; =\u0026gt; t        char-tables\n 类似vector,但它使用Character作为索引. char-tables的输出格式与vector类似,但前面加上`#^`作为标示 每个char-table对象都有一个symbol类型的\u0026quot;subtype\u0026rdquo;,可以用于标识char-table的用处, 使用函数char-table-subtyple来查询该subtype char-table的subtype中的属性`char-table-extra-slots`决定了该char-table的扩展slot的个数(0-10之间) 每个char-table都可以有一个父char-table,子char-table从父char-table中继承索引的值. char-table还能够设定一个默认值.若发现char-table指定index的值为nil,则返回该默认值.       string\n  elisp中的string是不可变的.\n  string中不能包含?\\H-N ?\\A-N ?\\s-N 这些字符\n  string中可以包含文本属性,包含文本属性的输出格式为:\n#(\u0026#34;characters\u0026#34; property-data...)  Emacs中,对字符串作比较的函数只有string=,string\u0026lt;函数,没有string\u0026gt;函数      List list是sequence的一个子类型\n  创建一个list\n  使用list函数:(list v1 v2\u0026hellip;)\n  使用字面表达式'(v1 v2\u0026hellip;)\n  获取element\n   Function Purpose     (car ℓ) first element   (nth n ℓ) nth element (start from 0)   (car (last ℓ)) last element   (cdr ℓ) 2nd to last elements   (nthcdr n ℓ) nth to last elements   (butlast ℓ n) without the last n elements      获取list的长度\n  (length mySeq)\n 在list头添加element  (cons x myList)\n 合并两个list  (append list1 list2)\n由此可以得出,在list尾部添加element的方法为\n(append myList (list myVal))\n 修改list的函数    Function Purpose     (pop ℓ) Remove first element from the variable. Returns the removed element.   (nbutlast ℓ n) Remove last n elements from the variable. Returns the new value of the variable.   (setcar ℓ x) replaces the first element in ℓ with x. Returns x.   (setcdr ℓ x) replaces the rest of elements in ℓ with x. Returns x.         association list / alist\nalist中的item是顺序的,且可以有重复键值\n在elisp中,alist中可以存在某些element不是cons cell的情况,alist查询函数会自动略过这些异常的element association list类似于C语言中的map,它的结构为\n(defvar *alist-example* \u0026#39;((key1 value1) (key2 value2)))      Property list / plist\nplist的作用类似alist,也是用list表示一组键值对.\nplist的key为symbol,它的结构为\n(key1 value1 key2 (value2) key3 \u0026#34;value3\u0026#34;) ;=\u0026gt;键值对的对应关系为key1-\u0026gt;value1;key2-\u0026gt;\u0026#39;(value2);key3-\u0026gt;\u0026#34;value3\u0026#34; 每一个symbol都可以attach一个plist\n需要注意的是,plist中的 key必须是唯一的 ,相比来说alist就没有这个限制了.\n  hashtable hash table类似alist一样提供了键值配对的功能. 但比起alist来说,有如下三个方面的不同\n 在搜索大量的键值对集合时,使用hash table的搜索速度比alist快得多 hash table中的的item是非排序的,不能有重复键值 两个hash table对象无法共享同一个结构体,而两个alist对象之间有可能使用共同的tail  hash table的输出格式以#s开头后接hash table的属性和内容\n#s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8 data ()) symbol  Lisp中symbol类似于其他语言中的变量,但是它不仅仅只存储一个值. 列表的第一个表达式如果是一个符号,解释器会查找这个表达式的函数值.如果函数值是另一个符号,则会继续查找这个符号的函数值 symbol中,\\失去了转义的功能,因此'\\t就是\u0026rsquo;t而不时'\u0026lt;TAB\u0026gt; 一个符号既可以有value,也可以有function,即一个symbol可以同时求值和当作函数用  符号的组成   符号名称:使用函数symbol-name获取\n  符号值: 使用函数symbol-value获取\n  使用boundp测试符号是否有值\n  以`:`开头的符号的值不能变\n  函数: 使用symobl-function获取\n  使用fboundp测试符号是否设置了函数\n  其实function slot不仅仅可以存放function,还可以存放macro,symbol,keyboard marcro,keympa和autoload object\n  属性列表:使用symbol-plist获取\n  使用get/put来访问/修改某个属性值\n  使用plist-get/plist-put来访问/设置属性列表中的属性\n  属性列表是一个形如(prop1 value1 prop2 value2)的关联列表,但无法删除一个属性\n  可用使用属性列表来存储function的状态\n  符号的形成 当elisp读取到一个symbol时,它会先在一个名为`obarray`的vector中检查是否已经存在这个symbol, 若不存在,则elisp reader创建新的symbol并添加到obarray中(创建并添加symbol的过程被成为\u0026quot;interning\u0026quot;,而该symbol被成为是\u0026quot;interned symbol\u0026quot;).\n如果想避免intern一个symbol,可以在符号名前加上`#::`,这些符号被称为`uninterned symbols`\n(intern-soft \u0026#34;abc\u0026#34;) ; =\u0026gt; nil \u0026#39;abc ; =\u0026gt; abc (intern-soft \u0026#34;abc\u0026#34;) ; =\u0026gt; abc (intern-soft \u0026#34;abcd\u0026#34;) ; =\u0026gt; nil \u0026#39;#:abcd ; =\u0026gt; abcd (intern-soft \u0026#34;abcd\u0026#34;) ; =\u0026gt; nil obarray也是一种类型名称\n由于在elisp中,obarray就是一个vector,因此可以使用(make-vecotr LENGTH 0)来创建一个空的obarray, 而要把symbol插入一个obarray,则必须使用如下的intern系列函数来进行.\n intern intern-soft unintern mapatoms  Char 类似C,Elisp中的Char其实就是integer(值从0到(max-char)的范围都可以认为是character). Char类型的字面量结构为`?字母`,例如\n(message \u0026#34;%d\u0026#34; ?A) ;65 (message \u0026#34;%d\u0026#34; ?\\.) ;46 标点一般在前面加\\ (message \u0026#34;%d\u0026#34; ?我) ;25105 ?\\a ;=\u0026gt; 7 ; control-g, `C-g\u0026#39; ?\\b ;=\u0026gt; 8 ; backspace, \u0026lt;BS\u0026gt;, `C-h\u0026#39; ?\\t ;=\u0026gt; 9 ; tab, \u0026lt;TAB\u0026gt;, `C-i\u0026#39; ?\\n ;=\u0026gt; 10 ; newline, `C-j\u0026#39; ?\\v ;=\u0026gt; 11 ; vertical tab, `C-k\u0026#39; ?\\f ;=\u0026gt; 12 ; formfeed character, `C-l\u0026#39; ?\\r ;=\u0026gt; 13 ; carriage return, \u0026lt;RET\u0026gt;, `C-m\u0026#39; ?\\e ;=\u0026gt; 27 ; escape character, \u0026lt;ESC\u0026gt;, `C-[\u0026#39; ?\\s ;=\u0026gt; 32 ; space character, \u0026lt;SPC\u0026gt; ?\\\\ ;=\u0026gt; 92 ; backslash character, `\\\u0026#39; ?\\d ;=\u0026gt; 127 ; delete character, \u0026lt;DEL\u0026gt; ?\\uNNNN ;这里N为16进制数,表示U+NNNN的Unicode字符 ?\\U00NNNNNN ; ?\\x十六进制代码 ; ?\\x41 = \\?A ?\\三个八进制代码 ; ?\\001 = `C-a`  没有charp,因为字符就是整数,但是有char-or-string-p函数 使用char-equal比较字符时,需要注意case-fold-search变量的值,t表示忽略大小写  Control characters Ctrl-N的字面表达式为`?\\^字母`(这里的字母不区分大小写)\n?\\^I ; == ?\\^i == C-i == 9 还可以表示为`?\\C-字母`\n?\\C-g ;== ?\\^g == C-g 需要注意的是,?\\C-G不时?\\C-S-g的意思,它跟?\\C-g的意义一样 由于历史的原因,Emacs把\u0026lt;DEL\u0026gt;看成是C-?\nMeta Character M-N的字面表示方式为`?\\M-字母`\nShift Character ?§-N\nAlt Character ?\\A-N\nHyper Character ?\\H-N\nSuper Character ?\\s-N\n其他类型  Buffer Marker Window Frame Terminal Window Configuration Frame Configuration Process Stream nil指`standard-input`和`standard-output` t指代`从minibuffer输入`或输出到`echo area` Keymap Overlay  Overlay用来給buffer的一部分内容加上不同的显示风格\n Font  循环结构 需要使用`#N=`和`#N#`来定义循环点和引用循环点,这里N为数字\n\u0026#39;(#1=(a) b #1#) #1=\u0026#39;(a #1#) 数据类型之间的转换  number-to-string / string-to-number concat可以将序列转换成字符串   (concat \u0026#39;(?a ?b ?c ?d ?e)) ; =\u0026gt; \u0026#34;abcde\u0026#34; (concat [?a ?b ?c ?d ?e]) ; =\u0026gt; \u0026#34;abcde\u0026#34;  vconcat可以把字符串转换成向量   (vconcat \u0026#34;abdef\u0026#34;) ; =\u0026gt; [97 98 100 101 102]  append可以把字符串转换成一个列表   (append \u0026#34;abcdef\u0026#34; nil) ; =\u0026gt; (97 98 99 100 101 102)  (byte-to-string BYTE) 大小写转换  elisp通过case table来确定大小写的对应关系,每个buffer都可以设置自己的case table.\n  (downcase string-or-char)\n  (upcase string-or-char)\n  (capitalize string-or-char)\nstring中的所有单词都被格式化为capitalize的格式\n若参数为char类型,则效果跟upcase一样\n  (upcase-initials string-or-char)\n对string中的每个单词的第一个字母转化了大写字母,其他字母不变.\n  转换数字为Float型\n  (float number)\n 转换数字为Integer型  有8个函数可以用来转换Float到Integer型. 有些函数都带有一个可选参数DIVISOR, 若传入了DIVISOR则返回NUMBER/DIVISOR的整数化的值. 若DIVISOR为0,则Elisp报arith-error\n(truncate number \u0026amp;optional divisor) / (ftruncate float)\n截断小数位\n(floor number \u0026amp;optional divisor) / (ffloor float)\n截断成一个更小的整数\n(ceiling number \u0026amp;optional divisor) / (fceiling float)\n截断成一个更大的整数\n(round number \u0026amp;optional divisor) / (fround float)\n转换成最近的整数,若小数为为0.5,则转换为偶数,例如(round 1.5)=\u0026gt;2 (round 2.5)=\u0026gt;2\n 字符串与数字之间的相互转换  (string-to-number \u0026ldquo;N\u0026rdquo; \u0026amp;optional base)\n(number-to-string N)\n(format \u0026ldquo;%d\u0026rdquo; N)\n Object转换为String  (format \u0026ldquo;%s\u0026rdquo; object)\n(prin1-to-string object)\n String转换为Object  (read-from-string string)\n symbol转换为string  (symbol-name symbol)\n string转换为symbol  (intern string)\n类型判断  (cl-typep object type)  检查object是否为type类型.\n参数type为common lisp形式\n (type-of object)  返回object的 基本 类型\nelisp中的等于 eq eq用于判断两个Object是否为同一个Object\nequal equal用于判断两个Object是否有相同的内部结构(这通常意味着两个Object的类型是一样的,即0 不equal 0.0).\nequal在比较两个string时,不会比较他们的属性,需要比较属性的话,使用equal-including-properties来代替\n即使两个buffer的内容一样,equal这两个buffer时也不相等\n由于equal会对两个Object的各个组成部分递归调用equal,因此在处理循环结构时,可能会陷入死循环.\n= =一般用于数字之间的比较,且0=0.0\n/= 数字间的不等于\neql eql类似eq,但在处理数字是,会同时比较数字的类型和值.因此(eql 1.0 1)=\u0026gt;nil;(eql 1.0 1.0)=\u0026gt;t\nchar-equal 比较两个character是否相等,默认忽略大小写差异,若变量`case-fold-search`nil(默认为t),则比较时区分大小写\n(char-equal ?x ?x) ; =\u0026gt; t (let ((case-fold-search nil)) (char-equal ?x ?X)) ; =\u0026gt; nil string= string=接收string或symbol的参数. 使用string=的时候一定会区分大小写,而跟变量`case-fold-search`无关. 而且在比较时,string的text properties不参与比较.\n(string= \u0026#34;abc\u0026#34; \u0026#39;abc) ;=\u0026gt;t string-equal string=的别名\nequal-includeing-properties 变量名命名习惯  -hook 一个在特定情况下调用的函数列表，比如关闭缓冲«时，进入某个模式时。 -function值为一个函数 -functions 值为一个函数列表 -flag 值为nil或non-nil -predicate 值是一个作判断的函数，返回nil或non-nil -program 或-command 一个程序或shell名令名 -form 一个表达式 -forms 一个表达式列表。 -map 一个按键映射（keymap） 命名以空格开头的缓冲区是临时的,用户不需要关系的缓冲区  获取参数的几种方法 变量`current-prefix-arg`获取universal-argument emacs命令可以使用C-u传递universal-argument.\n   Key Input Value of current-prefix-arg     No universal arg called. nil   【Ctrl+u -】 Symbol -   【Ctrl+u - 2】 Number -2   【Ctrl+u 1】 Number 1   【Ctrl+u 4】 Number 4   【Ctrl+u】 List \u0026lsquo;(4)   【Ctrl+u Ctrl+u】 List \u0026lsquo;(16)    interactive   若interactive的参数以*开头，则意义是，如果当前buffer是只读的，则不执行该函数\n  interactive可以后接字符串,表示获得参数的方式\n  p 接收C-u的数字参数\n也可以不用P参数,直接在代码中判断current-prefix-arg的值\n  r region的开始/结束位置\n  n 提示用户输入数字参数,n后面可用接着提示符\n  s 提示用户输入字符串参数\n  若函数接收多个input,需要用\\n来分隔\n  interactive可以后接一个form,form的求值结果应该是一个list,这个list的值作为参数的实参\n  在form中一般会用到如下几个函数用于获取用户输入\n read-string read-file-name read-directory-name read-regexp y-or-n-p read-from-minibuffer 使用变量`current-prefix-arg`来判断是否有universal-argument  光标位置 函数  获取光标当前位置  (point)\n 获取region的开始和结束位置  (region-beginning) / (region-end)\n 当前行的开始/结束位置  (line-beginning-position) / (line-end-position)\n 获取当前buffer的开始/结束位置  (point-min) / (point-max)\n  得到行号\nline-number-at-pos\n  测试是否在buffer头/尾\nbobp(beginning of buffer predicate)和eobp(end of buffer predicate)\n  测试是否在行首/尾\nbolp(beginning of line predicate)和eolp(end of line predicate)\n  光标移动 函数   按单个字符移动\ngoto-char /forward-char /backward-char\n  跳转到指定字符串的位置\n(search-forward myStr) ;光标位于myStr的尾部\n(search-backward myStr) ;光标位于myStr的头部\n  正则查询\n  (re-search-forward myRegex) / (search-forward-regexp myRegex)\n(re-search-backward myRegex) / (search-backward-regexp myRegex)\n 跳到第一个不是\u0026quot;a\u0026quot;-\u0026ldquo;z\u0026quot;的位置  (skip-chars-forward \u0026ldquo;a-z\u0026rdquo;)\n(skip-chars-backward \u0026ldquo;a-z\u0026rdquo;)\n  跳到buffer的开头/末尾\nbeginning-of-buffer / end-of-buffer\n  按词移动\nforward-word /backward-word\n  按行移动\n没有backward-line,而且每次移动都是移动到行首的,所以(forward-line 0)可以移动到当前行的行首\n(forward-line N) N可以为负数,表示backward-line\n  移动到行首/尾\n  (beginning-of-line)\n(end-of-line)\n控制结构 顺序结构  (progn bodys)  顺序执行bodys,bodys中的最后一个form的返回值为progn的返回值\n (prog1 form1 bodys)  类似progn,但form1的返回值为prog1的返回值\n (prog2 form1 form2 bodys)  类似progn,但form2的返回值为prog2的返回值\n条件表达式  (if condition then-form else-bodys)  注意,then-form只能是一句form,而else-bodys可以为多个form,事实上它包含了一个隐含的progn\n  (when condition then-bodys)\n  (unless condition else-bodys)\n  (cond clauses)\n  一个clause的格式为(condition bodys)\nclause的格式也可以为(condition),这样的话,cond的返回值为非nil的condition的返回值\n (pcase EXP BRANCH1 BRANCH2 BRANCH3 \u0026hellip;)  一个BRANCH的格式为(UPATTERN BODYS)\npcase先计算EXP的值,并将值与各个BRANCH中的UPATTERN相比较,若相等,则执行相应的BODYS\n(pcase (get-return-code x) (\u0026#39;success (message \u0026#34;Done!\u0026#34;)) (\u0026#39;would-block (message \u0026#34;Sorry, can\u0026#39;t do it now\u0026#34;)) (\u0026#39;read-only (message \u0026#34;The shmliblick is read-only\u0026#34;)) (\u0026#39;access-denied (message \u0026#34;You do not have the needed rights\u0026#34;)) (code (message \u0026#34;Unknown return code %S\u0026#34; code))) UPATTERN可以是下面几种格式\n `(QPATTERN1 . QPATTERN2) 该模式匹配一个cons cell,它的car匹配QPATTERN1,而cdr匹配QPATTERN2 (setq form \u0026#39;(1 . 2)) (pcase form (`(,x . ,y) (message \u0026#34;%s + %s = %s\u0026#34; x y (+ x y)))) ;这里x绑定为值1,y绑定为值2 ;=\u0026gt;\u0026#34;1 + 2 = 3\u0026#34;  `ATOM 该模式匹配任何`equal` ATOM的atom (pcase (get-return-code x) (`success (message \u0026#34;Done!\u0026#34;)) (`would-block (message \u0026#34;Sorry, can\u0026#39;t do it now\u0026#34;)) (`read-only (message \u0026#34;The shmliblick is read-only\u0026#34;)) ;注意,symbol前需要用反引号引起来 (`access-denied (message \u0026#34;You do not have the needed rights\u0026#34;))) ;这里access-denied为atom,使用equal来进行匹配  `,UPATTERN 该模式匹配任何符合UPATTERN的object,并会绑定object到UPATTERN中的变量中 (setq form \u0026#39;(add 1 2)) (pcase form (`(add ,x ,y) (message \u0026#34;%s + %s = %s\u0026#34; x y (+ x y)))) ;这里x绑定为值1,y绑定为值2 ;=\u0026gt;\u0026#34;1 + 2 = 3\u0026#34;  SYMBOL 该模式匹配任何object,并且将该symbol绑定到object上. (pcase (get-code x) (code (message \u0026#34;code is %s\u0026#34; code))) ;这里code为一个symbol,它的值为(get-code x)的结果      该模式匹配任何object,但与SYMBOL不同在于不会将object绑定到任何symbol上 (pred PRED) 返回(PRED object)的值 (pcase x ((pred numberp) (message \u0026#34;x is number\u0026#34;)) ((pred stringp) (message \u0026#34;x is string\u0026#34;)))  (or UPATTERN1 UPATTERN2 \u0026hellip;) 任何一个UPATTERN匹配都行 (and UPATTERN1 UPATTERN2 \u0026hellip;) 所有UPATTERN都必须匹配 (guard EXP) 若EXP的计算结果为非nil,则匹配,否则不匹配  组合条件   (not condition)\n  (and conditions)\n  (or conditions)\n  循环  (while condition bodys)  while先判断condition的值,只要condition为非nil,则循环执行bodys,bodys可以为空.\n要模拟repeat bodys until condition,可以使用如下的结构\n(while (bodys (not condition)))  (dolist (var list [result]]) bodys)  对list的每个element,绑定到变量var中,然后执行bodys中的语句,最后返回result的计算结果(默认为nil).\n(defun reverse (list) (let (value) (dolist (elt list value) (setq value (cons elt value)))))  (dotimes (var count [result]) bodys)  类似dolist,但var的值的范围为[0,count)\n (do (var initial [step-form]) (end-test [RESULT-FORM] bodys\u0026hellip;))  类似for(var=initial;end-test;var=step-form){bodys\u0026hellip;}\n使用catch/throw模拟goto语句 可以在catch中使用throw来跳出循环,throw语句会跳转到catch处,例如\n;; (catch tag bodys) (defun foo-outer () (catch \u0026#39;foo (foo-inner))) ;; (throw tag value) (defun foo-inner () ... (if x (throw \u0026#39;foo t)) ;这里第一个参数必须与catch的第一个参数匹配. 第二个参数t,作为catch的返回值 ...) ;; 从这个例子中可以看出,throw可以跨函数间捕获 throw会根据其第一个参数来查询匹配的catch,匹配的catch它的第一个参数需要eq throw的第一个参数.\ncatch语句的返回值由throw的第二个参数决定\n若有多个catch可供匹配,则最内层那个catch被匹配.\nthrow操作退出多个lisp结构时,就好像正常退出这些lisp结构一样. 具体来说,throw操作会这些lisp结构中使解绑用let绑定的变量,退出了save-excursion语句后,会还原buffer和postion. 退出save-restriction语句后,会还原narrowing状态. 它还会调用unwind-protect语句定义的清理动作.\n若一个throw的tag没有相应的catch tag来匹配,则会抛出`no-catch`错误. 错误内容为throw语句中的`(tag value)`\nElisp中的异常机制 使用singal/error/condition-case模拟try catch语句 elisp中也提供了类似C++中的异常机制,在elisp中,其被称为error.\n大多数的error会在调用primitive function时自动抛出. 当然你也可以使用函数`error`和`signal`手工抛出error.\n需要注意的是,C-g触发的quitting,它的处理方式跟error类似,但并不是error\n每个error都需要一个错误说明信息,来说明抛出error的原因.\nerror类型 就好像C++有各种不同类型的异常一样,elisp也有不同类型的error. error的类型使用error symbol来标识. 每个error有且仅有一个error symbol\n同样的,跟C++类似,error处于一种被称为error-condition的继承体系内,每个error-condition由condition-name来标识,一个error可以属于多个error-condition.\n理论上,`\u0026lsquo;error`处于error-condition的最顶端,但quit是个例外,quit属于一种error-condition但它不是一种error,它的父类就是quit自己\n若要定义自己的error,可以使用define-error函数.\n  (define-error symbol message \u0026amp;optional parent)\n定义一个新error,它的error-symbol为参数symbol. 它继承于参数parent所表示的error-condition(默认为error),\n参数message需要是一个字符串,当该error被抛出,而没有handler捕获时,elisp使用该字符串作为error message.\n下面是一个定义error的例子\n(define-error \u0026#39;new-error \u0026#34;A new error\u0026#34; \u0026#39;my-own-errors) ;error message一般第一个字母是大写的   抛出error   (error format-string \u0026amp;rest args)\n抛出一个error,该error的错误说明信息为(format format-string args)\n  (signal error-symbol data)\nsignal函数抛出一个名为error-symbol的error.\n参数error-symbol必须是由`define-error`定义的symbol. data参数则是与error环境相关的一系列lisp object,其lisp object中的个数和意义,对不同的error-symbol有不同的要求\n若抛出的error没有被处理,则error-symbol和data这两个参数被用来输出出错信息.\n一般情况下,出错信息由error-symbol的error-message property来提供. data则一般用来提供产生error的上下文环境. 但若error-symbol为error,则错误信息为(car data),且(car data)必须为string型. file-error类则有其特殊的处理模式.\n(signal \u0026#39;error \u0026#39;(\u0026#34;asdbs\u0026#34; (car 1) (cas 1))) ;error--\u0026gt; asdbs: (car 1), (cas 1) (signal \u0026#39;wrong-number-of-arguments \u0026#39;(x y)) ; error--\u0026gt; Wrong number of arguments: x, y (signal \u0026#39;no-such-error \u0026#39;(\u0026#34;My unknown error condition\u0026#34;)) ; error--\u0026gt; peculiar error: \u0026#34;My unknown error condition\u0026#34;   (user-error format-string \u0026amp;rest args)\nuser-error跟error函数类似,但是它使用user-error作为error-symbol而不是error.\n如名称所示,一般用该函数抛出用户级的error,而不是代码级的error,即它不会进入debug模式(即使debug-on-error为非nil)\n  处理Error 类似C++中的异常机制,elisp中的error也可以定义多个error-handler来捕获它,但只有最靠近error发源地的error-handler会用来处理该error.\n若抛出的error,没有对应的error handler来处理它,则根据变量`debug-on-error`来决定是调用debug来处理该error(t),还是直接终止程序输出error(nil).\n  (condition-case var protected-form error-handler-bodys)\n可以使用condition-case来定义error handler.例如\n(condition-case nil (delete-file filename) (error nil)) condition-case的第一个参数var是一个变量,当参数protected-form正常执行时,该变量只能在error-handler的代码中才能被使用,这时该变量的值为\u0026rsquo;(error-symbol . data)\u0026rsquo;. error-handler可以根据该变量中所描述的错误信息来进行操作. var参数也可以是nil,表示没有这样一个描述error信息的变量. 就像写C++代码一样,有时候,需要重新抛出error,以便让外面的代码捕获到该error,则可以这样做:\n(signal (car var) (cdr var)) 我们称呼condition-case的第二个参数为\u0026quot;protected form\u0026rdquo;(在上例中,就是(delete-file filename))\n\u0026ldquo;protected form\u0026quot;后面的参数则为定义的error handlers. 每个error-handler的格式为(condition-names handler-bodys). 这里,conditon-names可以是一个error-condition名称或一个由error-condition名称组成成列表. 在上面的例子中,`error`为conditon-name表示所有类型的error.\n捕获到error后,condition-case的返回值为error-handler的执行结果. 若没有error发生,则返回protectd-form的计算结果. 下面是一些error-handler的例子\n(error nil) (arith-error (message \u0026#34;Division by zero\u0026#34;)) ((arith-error file-error) (message \u0026#34;Either division by zero or failure to open a file\u0026#34;))   一般情况下,若抛出的error被error-handler所捕获,则不会进入debug模式,但若希望调试那些被condition-case捕获的error,可以设置变量`debug-on-signal`为非nil. 你也可以设置某些特定的error在捕获前,先进入debug模式,方法是在error-handler的conditon-name前加上`debug`,例如:\n(condition-case nil (delete-file filename) ((debug error) nil)) 需要注意的是,这里condition-name前的debug并不意味着一定会进入debug模式,还需要将`debug-on-error`设置为非nil才行.\n  (condition-case-unless-debug var protected-form error-handler-bodys)\n类似condition-case,但只在不启用debug的情况下才其作用(即`debug-on-error`为nil)\n  (error-message-string error-descriptor)\n输出error-descriptor(即condition-case中的第一个参数var)所表示的字符串.\n  (ignore-errors body)\n执行body语句,并忽略任何抛出的error. 若body执行时不抛error,则返回body的计算结果,否则返回nil\n  (with-demoted-errors format bodys)\n该宏就像是ignore-error的温和版本. 它不会直接忽略掉error的发生,相反,它会使用format来将error转换为一条message输出.\n参数format必须为格式字符串,且必须有且仅有一个\u0026rdquo;%S\u0026quot;作为占位符.\n需要注意的是,在with-demoted-errors宏中,它是使用conditon-case-unless-debug来捕获error,而不是conditon-case. 因此需要在关闭debug-on-error,才能起作用.\n  使用unwind-protect模拟finally语句 类似java中的finally语句,elisp也提供了unwind-protect来保证清理动作一定会执行.\n (unwind-protect body-form cleanup-forms\u0026hellip;)  unwind-protect保证执行完body-form后,无论执行过程中是否直接调用throw跳出body-form,还是抛出error,还是正常执行,都会执行cleanup-forms中的语句.\n与finally类似,unwind-protect语句只保证body-form执行失败后会执行cleanup-forms中的语句,而不能保证cleanup-forms中如果出了问题,还会执行后面的语句.\n与finally不同的是,若body-form正常结束,则unwind-protect的返回值为 body-form 的计算结果,而若body-form非正常退出,则不返回任何值(??),而不是返回cleanup-forms的值.\nElisp中的变量 在Elisp中,一个变量就是一个lisp symbol. 变量名为该symbol的名称,变量值为该symbol的value cell中存储的值.\n与C++中的变量不同的是,Elisp中的变量可以指向任何类型的数据,而且可以为变量设置一个doc-string,用于说明该变量的用处.\n全局变量 可以使用defvar,defconst,defcustom来定义全局变量.\n (defvar symbol \u0026amp;optional value doc-string)  定义名为symbol-name的变量,并初始化值为value.\n(defvar project-root \u0026#34;~/project/\u0026#34; \u0026#34;项目根目录\u0026#34;) 若省略value的值,则定义出来的变量为空变量.不能直接被访问.\n(defvar void-var) void-var ;Lisp error: (void-variable void-var) 需要注意的是: 若symbol已经有值,则defvar并不会更改symbol的值.\n(defvar var \u0026#39;some-value) var ;some-value (defvar var \u0026#39;other-value) var ;some-value 另外,defvar绑定的是symbol在动态域下的默认值,它并不会影响symbol的buffer-local值,也不改变symbol的静态绑定值.\n (defconst symbol value \u0026amp;optional doc-string)  与defvardefconst也定义一个名为symbol-name的变量,它的值为value.\n另外,defconst绑定的也是symbol在动态域下的默认值,它并不会影响symbol的buffer-local值,也不改变symbol的静态绑定值.\n它跟defvar不一样的地方在与,它总是使symbol赋值为value,而不管是否已经有值.\n但正如名称所表示的,它表示定义的变量通常应该是一个常量. 不 建议 修改它的值(但不是强制性的)\n常量 在Elisp中,nil,t和任何以`:`开头的symbol(我们常常称呼这种symbol为keyword)都是系统的保留常量.\n任何对这些系统的保留常量的值进行修改的动作,都会抛出`setting-constant` error.\n还有一类是用户使用defconst来自定义的常量,对这类常量的值进行修改,并不会抛出error,而且修改行为也能成功\n局部变量 与C++一样,函数中的参数,天生就是局部变量,它的作用范围就是整个函数内部.\n而要实现类似C++的代码块内的局部变量({}内定义的局部变量),需要使用let*语句.\n (let* (bings\u0026hellip;) forms\u0026hellip;)  这里,bingding为定义局部变量的语句,在这里定义的局部变量,只能在后面的bodys中访问.\n每个bingding可以是一个symbol,这表示定义一个局部变量,并且该局部变量的值为nil. 也可以是一个(symbol value-form)格式的list,表示定义一个局部变量,并且该局部变量的值为value-form的计算结果. 当然value-form也可以省略,表示nil.\n下面是一个例子\n(setq y 2) ; =\u0026gt; 2 (let* ((y 1) (z y)) (list y z)) ; =\u0026gt; (1 1)  (let (bindings\u0026hellip;) bodys\u0026hellip;)  类似let*语句, 但是需要注意的是: let语句中,在整个(bingings)没有完成之前,所有的局部变量都是不生效的. 举个例子\n(setq y 2) ; =\u0026gt; 2 ;; 这里在执行(z y)时,局部变量y还未生效,这时的y是全局变量y,即它的值为2 (let ((y 1) (z y)) (list y z)) ; =\u0026gt; (1 2) Buffer-Local变量 Buffer-Local变量应该说是Elisp所特有的一种变量类型了. 这种变量的作用域仅限于某个buffer.\n换句话说,一个变量它在不同作用域下有不同的绑定值. 若它处于buffer作用域下,则该变量的值根据buffer的不同而不同. 而之前提到的与buffer无关的动态作用域的值,我们称它为变量的默认值.\n需要注意: 即使一个变量被标记为buffer-local变量,当使用defvar和defconst时,改变的依然是它的默认值.而不是buffer作用域下的值.\n  (make-local-variable symbol)\n可以使用命令`make-local-variable`来标注一个变量为Buffer-Local变量. 这时,该变量在当前buffer中的值变得跟其他buffer独立开来. 在当前buffer中,该变量处于buffer作用域中,而在其他buffer中则共享该变量的默认值.\n  该变量在buffer作用域下的值,在创建时与该buffer的默认值是一样的.\n若一个变量是terminal-local变量,则该函数会抛出error. terminal-local变量不能有buffer作用域下的值.\n注意: 不要用该函数来将hook变量设置为buffer-local变量,而应该在使用add-hook和remove-hook时将local参数设为t\n (setq-local symbol-name value)  将symbol变量标注为buffer-local变量,同时赋值为value. 它等于是先调用make-local-variable后再用setq进行赋值.\n  (make-variable-buffer-local symbol)\n也可以使用命令`make-variable-buffer-local`来标注一个变量在所有的buffer中都处于buffer-local作用域下,包括那些还未被创建的buffer. 我们称呼这种变量为automatically buffer-local变量\n所有buffer中的值一开始时默认就是该变量的默认值.\n  当symbol变量的默认值为空时,该语句会自动为变量在buffer作用域下的值赋值为nil.\n (defvar-local symbol-name value \u0026amp;optional docstring)  定义以symbol-name为名称的变量,并赋初值为value,并把该变量标注为自动的buffer-local变量.\n该红等价于先执行make-variable-buffer-local,然后再执行defvar\n (local-variable-p symbol \u0026amp;optional buffer)  判断symbol所表示的变量在buffer中是否为buffer-local变量,若省略buffer参数则指的当前buffer.\n注意:该函数在判断automatically buffer-local变量时返回nil\n(defvar-local a 1) ;这时a为automatically buffer-local变量 (local-variable-p \u0026#39;a) ;=\u0026gt;nil  (local-variable-if-set-p symbol \u0026amp;optional buffer)  跟local-variable-p类似,但当symbol为automatically buffer-local变量时,该函数也返回t\n(defvar-local a 1) ;这时a为automatically buffer-local变量 (local-variable-if-set-p \u0026#39;a) ;=\u0026gt; t  (buffer-local-value symbol buffer)  返回symbol变量在指定buffer中的buffer作用域中的值, 若symbol变量在指定buffer中没有buffer-local绑定值,则返回它的默认值.\n (buffer-local-variables \u0026amp;optional buffer)  以list的方式返回当前buffer中的所有buffer-local变量. 若buffer参数被省略,则表示当前buffer.\n返回的list中的每个元素的格式为\u0026rsquo;(symbol . value), 但若symbol变量在buffer作用域下的值为空(不是nil),则元素的格式只是单个的symbol\n(make-local-variable \u0026#39;foobar) (makunbound \u0026#39;foobar) (make-local-variable \u0026#39;bind-me) (setq bind-me 69) (setq lcl (buffer-local-variables)) ;; =\u0026gt; (foobar ;foobar为void变量,格式为单个的symbol (bind-me . 69)) ;bind-me变量有值,因此格式为(symbol . value)  (kill-local-variable symbol)  删除symbol变量在当前buffer中的buffer-local标识,使之在当前buffer中作为一个普通变量来处理.\n要注意的是: 若对一个automatical buffer-local变量执行该函数,则该变量在当前buffer中访问时会作为一个普通变量来处理,然而, 一旦对这个变量再次赋值,该变量又变成为buffer-local变量\n (kill-all-local-variables)  删除当前buffer中所有buffer-local变量(包括函数)的buffer-local标识,但那些标注为\u0026quot;permanent\u0026quot;的变量和\u0026quot;permanent-local-hook\u0026quot;属性为非nil的函数除外.\n该函数返回nil\n该函数执行的第一件事就会执行change-major-mode-hook,因为它会把当前buffer的major mode先改为fundamental mode\n所谓标注为permanent的变量,指的是symbol的permanent-local属性为非nil\n当在某buffer中标注某变量问buffer-local变量后,再使用setq来更改变量值时只会更改该变量在该buffer作用域下的值了,要想更改它的默认值,需要使用语句set-default / setq-default了\n  (setq-default symbol1-name value1 symbol2-name value2 \u0026hellip;)\n设置每个变量的默认值\n  (set-default symbol value)\n设置symbol变量的默认值\n  同样的,使用let对一个buffer-local变量进行局部绑定时,修改的也是该变量在buffer作用域下的值.\nFile-Local变量 在文件中指定了某个变量为File-local变量后,当某个buffer访问该文件后,相关变量自动成为buffer-local变量.\n处于安全考虑,若某个File-local变量为函数或S表达式,则只有那些明确标记为safe的file-local变量才会自动生效,其他的file-local变量需要用于认可才回生效.\n你可以通过修改一个变量的safe-local-variable属性来决定哪些值对于该参数来说是有效的,该属性接收该参数的值,返回非nil则表示该参数safe(有效),nil表示unsafe(无效).\n此外,当Emacs读取file-local变量时,`read-circle`变量会临时设为nil.\n 变量enable-local-variables  该变量控制了是否让file-local变量生效.\n该变量有可以设置为:\n  t (默认)\n表示自动生效那些标记为safe的变量,而那些unsafe的变量需要提示用户确认后才生效\n  :safe\n只有标记为safe的变量才生效,其他的unsafe变量不生效\n  :all\n所有的变量,不管safe或unsafe,都生效\n  nil\n所有的变量,不管safe或unsafe,都不生效\n  其他\n素有变量,不管safe或unsafe,都需要用户确认过之后才生效\n  变量inhibit-local-variables-regexps\n  该变量是一个由正则表达式组成的list. 如果某个文件名符合list中某元素的个正则表达式,则该文件中的file-loca变量不生效\n (hack-local-variables \u0026amp;optional mode-only)  启用该buffer所访问file中的file-local变量.\n注意: 执行该函数时,会按照变量`enable-local-variables`的不同值,而有不同的生效方式.\n该函数执行前会触发`before-hack-local-variables-hook`,执行后会触发`hack-local-variables-hook`\n若mode-only参数为非nil,则之后名为\u0026quot;mode:\u0026ldquo;的file-local变量会生效,若文件中指明了\u0026quot;mode:\u0026quot;,则该函数返回该函数值,否则返回nil\n 变量file-local-variables-alist  该变量一定为buffer-local变量,它是一个存储了file-local变量信息的alist.\n每个file-local-variables-alist中元素的格式为`(VAR . VALUE)`,这里VAR为file-local变量,value为变量的值.\n当Emacs访问一个文件时,它其实是先将所有的file-local变量收集了起来存入file-local-variables-alist变量中,然后再调用hack-local-variables函数来让他们生效.\n 配置项safe-local-variable-values  该变量是一个由`(VAR . VALUE)`组成的list. 这里VAR为变量名,而VALUE为VAR的值,并且该值被认为是safe的.\n (safe-local-variable-p symbol value)  判断給symbol变量设置为value是否safe\n (risky-local-variable-p symbol)  该函数判断symbol变量是否认为是risky\nrisky的变量在生效前,除非明确被设置到`safe-local-variable-value`中,佛则一定需要经过用户的确认.\n所谓risky变量,指的是它的属性`risky-local-variable`为non-nil的变量.\n此外,任何以`-command`,`-frame-alist`,`-function`,`functions`,`-hook`,`-hooks`,`-form`,`-forms`,`-map`,`map-alist`,`-mode-alist`,`-program`和`-predicate`结尾的变量都自动认为是risky的.\n 变量ignored-local-variables  该变量的值为由变量组成的list, 该list中的对应变量不能被设置为file-local变量,即使在文件中将它设置为file-local变量,也无效果.\n 配置型enable-local-eval  `:Eval`是一个明显的潜在漏洞,因此Emacs通常在处理该函数时都要经过用户的确认.\n通过设置enable-local-eval值,可以改变这一行为. 该变量可以有三个值:\n  t\n表示无条件执行\n  nil\n表示无条件不执行\n  其他(默认为\u0026rsquo;mayb)\n表示询问用户.\n  配置型safe-local-eval-forms\n  该变量为一个由正则表达式组成的list. 当`Eval:`参数的值能够匹配上其中一个正则的S表达式,则认为是安全的.\n如果`Eval:`参数的值为一个调用函数的S表达式,且调用的函数拥有`safe-local-eval-function`属性,则该属性所表示的函数被用来判断该S表达式是否为安全的. `safe-local-eval-function`函数得值,可以是一个函数列表,表示其中任何一个函数返回t即为安全,也可以是t,表示所有的S表达式都安全.\n由于Text属性值也可能包含要被调用的函数,因此它也认为是一个潜在的漏洞, 因此,若一个变量的值为带有Text属性的String,则该string的Text属性被忽略.\nDirectory-Local变量 在目录中指定了某个变量为Directory-local变量后,当某个buffer访问该目录(极其子目录)下的文件后,相关变量自动成为buffer-local变量.\n有两种方式来定义directory-local变量:\n  把他们放到特定的文件中,该文件名由常量`dir-locals-file`决定,默认为`.dir-locals.el/_dir-locals`\n基于速度的考虑,一般在访问远程文件时,会禁用该特性,但通过设置变量`enable-remote-dir-locals`为t,可以为远程文件也打开该特性.\ndir-locals-file文件的格式为一个list,其中每个元素的格式可以是:\n (major-mode . directory-local-variable-value-alist)  表示当指定major-mode开启时,对应的directory-local变量生效\n (nil. directory-local-variable-value-alist)  表示对所有major-mode,对应的directory-local变量生效\n (subdirectory-name-string . dir-locals-file-format-list)  表示对于指定子目录下的所有文件,directory-local变量生效.\n下面是一个例子:\n((nil . ((indent-tabs-mode . t) (fill-column . 80))) (c-mode . ((c-file-style . \u0026#34;BSD\u0026#34;) (subdirs . nil))) ; =\u0026gt;这里subdirs不是变量名,而是一个关键字,表示该设置,只对当前目录下的文件有效,而对子目录下的文件无效. (\u0026#34;src/imported\u0026#34; . ((nil . ((change-log-default-name . \u0026#34;ChangeLog.local\u0026#34;)))))) 由于手工修改该文件格式会比较容易出错,因此Emacs提供了命令add-dir-local-variable/delete-dir-local-variable/copy-file-locals-to-dir-locals命令来维护directory-locale变量\n  为目录定义\u0026quot;project class\u0026rdquo;\n首先使用函数dir-locals-set-class-variables定义一组变量/值的键值对的集合.\n(dir-locals-set-class-variables \u0026#39;unwritable-directory \u0026#39;((nil . ((some-useful-setting . value))))) 然后使用函数dir-locals-set-directory-class函数为目录分配这组键值对的集合\n(dir-locals-set-directory-class \u0026#34;/usr/include/\u0026#34; \u0026#39;unwritable-directory)   相关函数   (hack-dir-local-variables)\n为访问当前目录(及子目录)下文件的所有buffer开启directory-local变量\n该函数通过调用函数dir-locals-set-class-variables和dir-locals-set-directory-class来完成此操作.\n  (hack-dir-local-variables-non-file-buffer)\n为当前buffer启用directory-local变量,一般用于那些non-file buffer中.\n对这些non-file buffer开启directory-local变量时会从`default-directory`和它的父目录中查找directory-local变量的定义\n  (dir-locals-set-class-variables project-class dir-locals-file-format-list)\n该函数定义一组directory-local变量及其值,并分配改组变量为project-class\n(dir-locals-set-class-variables \u0026#39;unwritable-directory \u0026#39;((nil . ((some-useful-setting . value)))))   (dir-locals-set-directory-class directory project-class \u0026amp;optioinal mtime)\n为directory(及其子目录下)下的所有文件分配project-class所表示的directory-local变量.\n当Emacs从`.dir-locals.el`文件中读取directory-local变量时,也是通过调用该函数来实现的,这是会带上mtime参数.\nmtime参数存储的是`.dir-locals.el`的modification time. Emacs使用该时间来检查已有的directory-local变量是否依然有效.\n  变量dir-locals-class-alist\n该变量是一个alist,它维护了project-class及对应directory-local变量的对应关系.\n  变量dir-locals-directory-cache\n该变量是一个alist,它维护了目录名称,对应的project-class和对应`.dir-locals.el`的modification time\n  变量enable-dir-local-variables\n是否启用directory-locall变量特性.\n  Terminal-Lock变量 空变量 前面说到,变量的值其实就是取得symbol中的value cell中存储的对象. 当symbol中的value cell没有存储任何对象时(nil也是一个对象),这时访问该变量会抛出`void-variable` error. 我们称这种变量为空变量. (NOTE: 上述的情况在Emacs默认的动态作用域下是成立的,若明确指定了静态作用域,则另当别论了,但这种情况比较少用到)\n那么创建这种空变量呢? 这就需要用到makeunbound函数了.\n (makeunbound symbol)  将当前作用域下的局部变量symbol中的value cell清空,使之成为空变量.\n若要判断某个变量是否为空变量,则可以使用boundp函数\n (boundp symbol)  该函数检查symbol的value cell是否有值,若有值则返回t,否则返回nil. 因此我们也可以定义函数\n(defun void-variable-p (variable) (null (boundp variable))) 下面是一些boundp的例子\n(boundp \u0026#39;abracadabra) ; Starts out void. ;; =\u0026gt; nil (let ((abracadabra 5)) ; Locally bind it. (boundp \u0026#39;abracadabra)) ;; =\u0026gt; t (boundp \u0026#39;abracadabra) ; Still globally void. ;; =\u0026gt; nil (setq abracadabra 5) ; Make it globally nonvoid. ;; =\u0026gt; 5 (boundp \u0026#39;abracadabra) ;; =\u0026gt; t 变量别名 变量及其别名公用同一个值,修改其中一个也会同时更改另一个值.\n (defvaralias new-alias base-variable \u0026amp;optional docstring)  为base-variable定义一个名为new-alias的变量别名,可以为这个别名分配一个新的docstring\n该函数返回base-variable\n (indirect-variable alias-variable)  返回别名链中最末端的那个非别名变量\n若出现了循环定义的别名,则该函数抛出`cyclic-variable-indirection` error\n废弃变量  (make-obsolete-variable obsolete-variable current-variable when \u0026amp;optional access-type)  在编译时警告一个变量即将废弃不用了,其中:\n参数obsolete-variable为即将不用的变量\n参数current-variable若为symbol,则会提示用新的变量current-variable代替老的变量obsolete-variable. 若current-name为string,则直接警告该string.\n参数when指明了obsolete-variable从什么时候开始废弃,通常为一个表示版本号的字符串.\n参数access-type指明了对obsolete-variable的哪种操作会触发警告,可以使\u0026rsquo;get或\u0026rsquo;set\n (define-obsolete-variable-alias obsolete-variable current-variable \u0026amp;optional when docstring)  该宏创建obsolete-variable为current-variable的别名,并标记obsolete-variable为即将废弃的变量.\n该宏其实等价于:\n(defvaralias OBSOLETE-NAME CURRENT-NAME DOCSTRING) (make-obsolete-variable OBSOLETE-NAME CURRENT-NAME WHEN) 受限的变量 默认情况下,一个Lisp变量的值可以是任何的Lisp object. 但有些变量不是用Lisp来定义的,而是用C来定义. 这些用C定义的变量有可能只能存储特定类型的值. 如果变量类型为:\n DEFVAR_LISP  该变量跟在lisp中定义的变量一样,它的值可以是任意的.\n DEFVAR_INT  该变量的值只能是整型\n DEFVAR_BOOL  该变量的值只能为t或者nil\n其中变量`byte-boolean-vars`中列出了所有类型的DEFVAR_BOOL的变量\n变量的作用域 与C++不同的是,Elisp中的变量默认情况下是处于动态作用域中. 当然,Elisp也支持静态作用域.\n动态作用域 当一个变量处于动态作用域中时,这就意味着,这个变量的值是受到运行环境的影响的. 举个例子:\n(setq foo \u0026#39;outer) ;outer (defun say-foo() foo) (say-foo) ;=\u0026gt;outer (let ((foo \u0026#39;inner)) (say-foo)) ;=\u0026gt;inner,在调用say-foo的运行环境中,foo的值为局部定义的\u0026#39;inner,因此say-foo的返回值为\u0026#39;inner (say-foo) ;=\u0026gt;outer, 在调用say-foo的运行环境中,foo的值为全局值\u0026#39;outer,因此say-foo的返回值为\u0026#39;outer 拥有动态作用域值的变量被成为special-variable,可以使用函数special-variable-p来判断一个symbol是否为special variable.\n  (special-variable-p symbol)\n判断symbol所表示的变量是否为special-variable. (由defvar,defconst和defcustom定义的变量都是special variable)\n   elisp实现动态作用域的方法很简单,每个symbol都由一个value cell,这个value cell所持有的值就是该变量在当前动态作用域下的值. 当为该变量创建一个动态局部作用域时,elisp将当前value cell的值压入一个栈中,并将该symbol的value cell存上新值. 当退出该动态局部作用域时,Elisp从栈中弹出以前的值,并重新存入symbol的value cell中.\n静态作用域 当一个变量处于静态作用域下时,该变量的值在定义该变量处就已经被确定了,即它的值为定义环境的值. 例如\n事实上,Elisp使用一个alist来存储静态作用域中各变量与值的关系. 这种alist的结构为`'((symbol1 value1)(symbol2 value2)\u0026hellip; t)`. 这种alist可以作为eval函数的第二个参数用来指明eval执行语句的静态作用域环境.\n可以使用lexical-let和lexical-let*来创建静态作用域. 这两个语句的语法跟let和let*一样,但BODY中的lambda函数会创建闭包.\n泛化变量(Generalized Variables) 泛化变量(Generalized Variables)或称位置列表(place form)其实就是变量值所被存储的内存地址.\n泛化变量可能是: 一个普通的lisp变量或者aref,car,caar,cadr,cdr,cdar,cddr,elt,get,gethash,nth,nthcdr,symbol-function,symbol-plist,symbol-value,default-value,frame-parameter,terminal-parameter,keymap-parent,match-data,overlay-get,overlay-start,overlay-end,process-buffer,process-filter,process-get,process-sentinel,window-buffer,window-display-table,window-dedicated-p,window-hscroll,window-parameter,window-point,window-start函数的返回值.\n  (setf place-form1 value1 place-form2 value2\u0026hellip;)\n可以使用setf宏来操作泛化变量. 它的作用类似setq,但setq只能为symbol赋值,而setf可以为任何泛化变量赋值. 例如\n   (setq a \u0026#39;(1 2 3)) ;(1 2 3) (setf (cadr a) \u0026#39;two) ;将a中的第二个元素的值改为two a ;(1 two 3)   (gv-define-simple-setter name setter-function \u0026amp;optional fix-return)\n  (gv-define-setter name arglist \u0026amp;rest body)\n  取变量值 当在静态作用域下,Elisp取变量值时,它会先查看该变量是否存在静态作用域下的绑定值. 然后再查看该变量的动态作用域下的绑定值(即该symbol的value cell所存储的值)\n除了直接引用变量可以取得变量值外,还可以使用symbol-value函数来获取变量的动态作用域下的值\n (symbol-value symbol)   (defvar num 123) (symbol-value \u0026#39;num) ;123 需要注意的是: 该函数只能用来获取symbol动态绑定的值,而不能用在静态环境下获取它静态绑定的值\n(lexical-let ((num 234)) (symbol-value \u0026#39;num) ;123 num) ;234  (buffer-local-value symbol buffer)  返回symbol变量在指定buffer中的buffer作用域中的值, 若symbol变量在指定buffer中没有buffer-local绑定值,则返回它的默认值.\n  (default-value symbol)\n取symbol变量的默认值\n  (default-boundp symbol)\n判断symbol变量的默认值是否为不为空\n   Customization emacs中可以使用`defcustom`定义customizable variables, 使用defface定义customizable face,使用defgroup定义cutomization group.\nCommon Item Keywords defcustom,defgroup,defface这些定义配置项的函数/宏,都接收keyword参数.\n所有这些keyword参数,除了`:tag`之外,都可以联合使用. 下面是一些通用的参数说明.\n :tag LABEL  LABEL为一个字符串类型. 该参数表示使用LABEL取代被定义item的名称作为该item的标签.\n :group GROUP  定义item所属的组别. 一个item可以同时属于多个组别,因此你可以多次使用该参数\n :link LINK-DATA  在该item的说明文档后面增加一个外部链接. 其中LINK-DATA可以以下格式:\n你还可以在LINK_DATA的第一个元素后面加上`:tag NAME`用来表示链接显示为NAME. 例如`(info-link :tag \u0026ldquo;foo\u0026rdquo; \u0026ldquo;(emacs)Top\u0026rdquo;)\u0026lsquo;会创建一个链接连接到Emacs手册,但是显示为foo\n  (custom-manual INFO-NODE)\n链接到Info node. INFO-NODE为Info文档中某node的名称,像\u0026quot;(emacs)Top\u0026quot;这样的.\n该链接显示为[manual]\n  (info-link INFO-NODE)\n类似custom-manual,只是链接的显示为Info node的名称\n  (url-link URL)\n链接到web页面, 点击它会使用变量`browse-url-browser-function`定义的Web浏览器打开\n  (emacs-library-link LIBRARY)\n连接到Emacs Lisp library文件.\n  (file-link FILE)\n连接到某个文件,Emacs会用find-file函数打开它\n  (function-link FUNCTION)\n链接到某个函数的说明文档,当点击它,会使用describe-function来获取函数说明\n  (variable-link VARIABLE)\n连接到某个变量的说明文档\n  (custom-group-link GROUP)\n链接到其他的group\n  :load FILE\n  在显示item前先加载FILE\n :require FEATURE  当保存item的值时,执行(require \u0026lsquo;FEATURE)\n :version VERSION  表示该item第一次出现在版本为VERSION的Emacs中,或该item的默认值或意义在版本为VERSION的Emacs中更改了.\nVERSION为字符串类型\n :package-version \u0026lsquo;(PACKAGE . VERSION)  表示该item第一次出现在版本为VERSION的PACKAGE中,或该item的默认值或意义在版本为VERSION的PACKAGE中更改了.\nPACKAGE应该是一个符号,为package的正式名称. 而VERSION应该为字符串类型.\n若PACKAGE为Emacs自带的,则PACKAGE和VERSION需要在变量`customize-package-emacs-version-alist`中\ncustomization groups  (defgroup group members doc [keyword value]\u0026hellip;)  定义新的名为group的客户化组. 该客户化组中包含members为内容.\n参数group为一个不被quote的symbol.\n参数members为由cusomiztion items组成的list,表示这些items属于某个group. 然而实际上一般该参数都为nil,而是定义item时使用:group关键字来标识该item所属的group\nmembers的元素格式为(NAME WIDGET). 这里NAME为表示item的symbol. 而WIDGET为item的类型(custom-variable,custom-face,custom-group)\n当对group设置了:version参数,则所有属于该group的其他item,默认继承该参数值\ndefgroup可以使用:prefix关键字参数\n:prefix PREFIX\n表示若该group中的item以PREFIX为前缀,而变量`custom-unlispify-remove-prefixes`为非nil, 则该item的tag在显示时会忽略掉该PREFIX.\n一个group可以设置忽略任意数量的prefix\ncustomizable variable defcusomter的语法与defvar有点类似,但是它还可以接收很多keyword参数.\n (defcustom var standard-value doc [keyword value]\u0026hellip;)  参数var为不被quote的symbol. 它表示定义的可配置变量.\n参数standard-value为一个表达式,它的计算值作为var的默认值\n参数doc为对该变量的说明.\n若在defcustom中没有通过:group关键字设置所属的group,则在相同文件中最后defgroup的组会自动作为该item的所属组.\ndefcustom支持的keyword参数有:\n  :type TYPE\n标注该客户化变量的类型,它指定了哪些值是合理的,如何显示这些值.\n也可以在defcustomer后使用函数(custom-add-frequent-value customization-item value)来增加选值范围\n  :options VALUE-LIST\n指定可选值的范围,该可选值的范围并不具有约束性.\n该keyword只有在type为hook,plist和alist时才有效\n  :set SETFUNCTION\n当使用Customize更改该配置项时,实际上调用的是SETFUNCTION函数,该函数接收两个参数:配置项和新值. 默认SETFUNCTION函数为set-default\n  :get GETFUNCTION\n当获取该配置项的值时,实际上是调用了GETFUNCTION函数. 该函数接收一个参数:配置项, 并返回某个值. 默认GETFUNCTION为`default-value\u0026rsquo;\n  :initialize FUNCTION\n当defcustom语句被执行时,实际上是调用了FUNCTION函数. 该函数接收两个参数:配置项和默认值.\nelisp预定义了一些可选的FUNCTION:\n  `custom-initialize-set\u0026rsquo;\n  `custom-initialize-default\u0026rsquo;\n  `custom-initialize-reset'\n  `custom-initialize-changed'\n  `custom-initialize-safe-set'\n  `custom-initialize-safe-default'\n    :risky VALUE\n设置该配置项变量的`risky-local-variable\u0026rsquo;属性为VALUE\n  :safe FUNCTION\n设置该配置项变量的`safe-local-variable\u0026rsquo;属性为FUNCTION\n  :set-after VARIABLES\n  (custom-reevaluate-setting customizable-arg)\n  可以用该函数在defcustom外,重新对customizablen-arg进行赋值\n (custom-variable-p arg)  判断arg是否为可配置变量, 这意味着这个变量是带有`standard-value\u0026rsquo;属性的symbol或者带有`custom-autoload\u0026rsquo;属性的symbol,或者由其他可配置变量组成的alist\n (custom-set-variables \u0026amp;rest args)  根据arg中的说明,更改配置项\n每个arg的格式为'(配置项 配置项的值表达式 [is-NOW [REQUEST-features-list [doc-string]]])\nCustomization Type 所有的customization type都实现为widget. customization widget可以通过`C-M-i\u0026rsquo;或`M-\u0026lt;TAB\u0026gt;\u0026lsquo;来补全\n   Simple Types\n  \u0026lsquo;sexp\n任意lisp object\n  \u0026lsquo;integer\n  \u0026lsquo;number\n  \u0026lsquo;float\n  \u0026lsquo;string\n  \u0026lsquo;regexp\n  \u0026lsquo;character\n  \u0026lsquo;file\n配置项必须是一个文件名称\n  \u0026lsquo;(file :must-match t)\n配置项必须是一个已存在的文件名称\n  \u0026lsquo;directory\n配置项必须是目录\n  \u0026lsquo;hook\n该配置项必须是一个函数列表\n  \u0026lsquo;symbol\n  \u0026lsquo;function\n该配置项必须是一个lambda表达式或函数名\n  \u0026lsquo;variable\n该配置必须是一个变量名称\n  \u0026lsquo;face\n  \u0026lsquo;boolean\n  \u0026lsquo;key-sequence\n  \u0026lsquo;coding-system\n  \u0026lsquo;color\n       Composite Types\n  \u0026lsquo;(cons CAR-TYPE CDR-TYPE)\n该配置项必须是cons cell. 并且它的car必须为CAR-TYPE,cdr必须为CDR-TYPE\n  \u0026lsquo;(list ELEMENAT1-TYPE ELEMENT2-TYPE \u0026hellip; ELEMENTn-TYPE)\n该配置项为由n个元素组成的list,每个元素都需要跟相应的ELEMENT-TYPE相匹配\n  \u0026lsquo;(group ELEMENAT1-TYPE ELEMENT2-TYPE \u0026hellip; ELEMENTn-TYPE)\n类似\u0026rsquo;(list ELEMENAT1-TYPE ELEMENT2-TYPE \u0026hellip; ELEMENTn-TYPE),区别在于list使用element的tag来作为element value的标签,而group不作标签\n  \u0026lsquo;(vector ELEMENAT1-TYPE ELEMENT2-TYPE \u0026hellip; ELEMENTn-TYPE)\n类似\u0026rsquo;(list ELEMENAT1-TYPE ELEMENT2-TYPE \u0026hellip; ELEMENTn-TYPE)\n区别在于配置项的类型必须是vector\n  \u0026lsquo;(alist :key-type KEY-TYPE :value-type VALUE-TYPE)\n配置项为alist类型,且每个cons ceil元素的car必须是KEY-TYPE的,cons ceil的cdr必须是VALUE-TYPE\n:key-type参数与:value-type可以省略,默认为\u0026rsquo;sexp\n  \u0026lsquo;(plist :key-type KEY-TYPE :value-type VALUE-TYPE)\n类似\u0026rsquo;(alist :key-type KEY-TYPE :value-type VALUE-TYPE),只是配置项为plist类型,且KEY-TYPE默认为symbol类型而不是sexp\n  \u0026lsquo;(choice CUSTOMIZE-TYPE1 CUSTOMIZE-TYPE2 \u0026hellip; CUSTOMIZE-TYPEn)\n配置项可以是CUSTOMIZE-TYPES中的任意一种.\n可以在CUSTOMIZE-TYPE中通过:tag关键字来指明配置项为某种TYPE时的label.例如\n(choice (integer :tag \u0026#34;Number of spaces\u0026#34;) (string :tag \u0026#34;Literal text\u0026#34;))   \u0026lsquo;(radio CUSTOMIZE-TYPE1 CUSTOMIZE-TYPE2 \u0026hellip; CUSTOMIZE-TYPEn)\n类似\u0026rsquo;(choice CUSTOMIZE-TYPE1 CUSTOMIZE-TYPE2 \u0026hellip; CUSTOMIZE-TYPEn),只是显示时使用radio button的方式显示而不是用菜单显示\n  \u0026lsquo;(const VALUE)\n该配置项的值必须为VALUE. 常与choice搭配\n  \u0026lsquo;(other VALUE)\n表示配置项可以接收任意的lisp值,但是该配置项实际上总是被赋值为VALUE.\nother主要用在choice中作为最后一个元素使用. 例如:\n(choice (const :tag \u0026#34;Yes\u0026#34; t) (const :tag \u0026#34;No\u0026#34; nil) (other :tag \u0026#34;Ask\u0026#34; foo)   \u0026lsquo;(function-item FUNCTION)\n类似const,但是它的值必须是function.\n  \u0026lsquo;(variable-item VARIABLE)\n类似const,但是它的值必须是表示某个变量的symbol\n  \u0026lsquo;(set TYPE1 TYPE2 \u0026hellip; TYPEn)\n该配置项必须是一个list,且每个list中元素类型必须匹配TYPES中的其中一种\n  \u0026lsquo;(repeat ELEMENT-TYPE)\n该配置项必须是一个list,并且每个元素都是ELEMENT-TYPE的\n  \u0026lsquo;(restricted-sexp :match-alternatives CRITERIA)\n该配置项的值可以是任一的lisp对象,但是必须匹配CRITERIA中的任一条件.\nCRITERIA是一个list,其中每个元素可以是:一个predicate function或者A quoted constant\n;; allows integers, `t\u0026#39; and `nil\u0026#39; as legitimate values. (restricted-sexp :match-alternatives (integerp \u0026#39;t \u0026#39;nil))        Type Keywords\n在定义配置项的:type时,可以在customizaton type name symbol后指定以下的keyword-argument对:\n  :value DEFAULT\n提供默认值. 当某种类型不能包含nil时,特别有用.\n  :format FORMAT-STRING\n显示配置项值时的格式.\n   占位符 说明     %[BUTTON%] 以按钮的样式显示文本BUTTON,其:action属性说明了当该按钮被点击时作什么操作   %{SAMPLE} 以`:sample-face\u0026rsquo;的样式显示文本SAMPLE   %v 显示为该配置项的value   %d 显示为该配置项的documentation string   %h 类似%d,但当配置项的doc-string超过一行时,会提供一个按钮隐藏/显示剩下的行   %t 显示为该配置项的tag   %% 显示为%      :action ACTION\n当点击button时执行的操作. 这里ACTION为一个函数,它会接收两个参数:点击的按钮所在widget和点击事件\n  :button-face FACE\n提供:button-face的显示样式,它会用于显示FORMAT-STRING中的%[\u0026hellip;%]中的内容\n  :button-prefix PREFIX / :button-suffix SUFFIX\n指明在显示button的前后文本. 他们的值可以是:\nnil: 不显示多于的文本\nstring: 显示文本\nsymbol: 显示symbol的值\n  :tag TAG\n指定TAG(字符串类型)作为配置项为该类型时的tag\n  :doc DOC\n指定DOC作为配置项为该类型时的doc-string\n  :help-echo MOTION-DOC\n  :match FUNCTION\n使用FUNCTION判断配置项的值是否匹配该类型,FUNCTION为一个函数,它接收两个参数:表示CUSTOMIZATION TYPE的widget和配置项的值\n  :validate FUNCTION\n使用FUNCTION校验配置项的值是否有效. FUNCTION函数接收一个参数:表示CUSTOMIZATION TYPE的widget. 若该函数判断widget是当前值是有效的,则返回 nil ,否则返回包含无效数据的widget,并设置该widget的`:error\u0026rsquo;属性为出错描述.\n       Defining New Types\n定义新Type就是为一个Composite Types命一个名字. 由于一个type就是一个widget,因此使用define-widget来实现\n(define-widget \u0026#39;binary-tree-of-string \u0026#39;lazy \u0026#34;A binary tree made of cons-cells and strings.\u0026#34; :offset 4 :tag \u0026#34;Node\u0026#34; :type \u0026#39;(choice (string :tag \u0026#34;Leaf\u0026#34; :value \u0026#34;\u0026#34;) (cons :tag \u0026#34;Interior\u0026#34; :value (\u0026#34;\u0026#34; . \u0026#34;\u0026#34;) binary-tree-of-string binary-tree-of-string))) 这里define-widget的第一个参数为表示新widget type的symbol.\n第二个参数为一个已经存在的widget,表示新widget type的类别,一般用\u0026rsquo;lazy\n第三个参数为doc-string\n:type参数描述了所代表的composite type说明\n  customizable face  (custom-set-faces \u0026amp;rest args)  根据arg,更改face配置项.\n一个arg的格式为\u0026rsquo;(FACE SPEC [is-Now [doc-string]])\nLoading Load命令  (load filename \u0026amp;optional missing-ok nomessage nosuffix must-suffix)  load先查找filename.elc文件,再查找filename.el文件,再查找filename文件\n若开启了Auto-Compression-mode(默认开启),则load在查找后一个文件前还会查找前一个文件的压缩版本(参见变量`jka-compr-load-suffixes\u0026rsquo;).\n若nosuffix参数为非nil,则load不会查找filename.elc和filename.el,但不影响auto-compression-mode的作用\n若must-suffix参数为非nil,则load认为加载的文件名后缀必须为.el和.elc(或他们的压缩版本),除非filename中包含了明确的目录名称.\n若参数missing-ok,则在找不到要加载的文件时,不抛出错误,只是返回nil\n若`load-prefer-newer\u0026rsquo;配置项为非nil,则load会挑选filename.elc和filename.el中最近较新的那个来加载\n若filename为相对路径,则load会在变量`load-path\u0026rsquo;中定义的路径中查询,查询到的第一个存在文件作为要加载的文件. 需要注意的是:需要在`load-path\u0026rsquo;中添加nil才回在当前路径搜索要load的文件\nload在加载文件时,会同时设置变量`load-file-name\u0026rsquo;的值为加载文件的文件名.\n若load顺利加载文件,则返回t\n (load-file filename)  加载filename所明确指定的文件,并不会为它添加.el会.elc后缀(但不影响Auto Compression Mode的作用)\n若filename为相对路径,则认为是相对于当前路径来说的. (该函数并不涉及到load-path变量)\n (load-library library)  类似load\n 变量`load-file-name\u0026rsquo;  存储的是load时实际加载的文件名称.\n 变量`load-in-progress\u0026rsquo;  若Emacs正在加载某个文件,则该值为非nil,否则为nil\n 变量`load-read-functioin\u0026rsquo;  该变量指明的函数,用于替代`load\u0026rsquo;和`eval-region\u0026rsquo;中的`read\u0026rsquo;函数\n该变量默认为nil,表示`read\u0026rsquo;\n 变量`load-suffixes\u0026rsquo;  load在搜索文件时,会根据该变量中设置的后缀,添加到filename参数后面来寻找文件.\n默认为\u0026rsquo;(\u0026quot;.elc\u0026quot; \u0026ldquo;.el\u0026rdquo;)\n 变量`load-file-rep-suffixes\u0026rsquo;  This is a list of suffixes that indicate representations of the same file.\n该变量一般以\u0026quot;\u0026ldquo;开头,若开了Auto Compression Mode则会把`jka-compr-load-suffixes\u0026rsquo;的内容也加进去.\n (get-load-suffixes)  返回load函数尝试添加的文件后缀. 它的值一般是`load-suffixes\u0026rsquo;与`load-file-rep-suffixes\u0026rsquo;的集合.\n 配置项load-prefer-newer  若该配置项为非nil,则load会检测所有可能的加载文件,并挑选最新的那个来加载\n 变量load-path  load函数搜索加载文件的路径列表,nil表示当前工作目录\n可以在运行emacs时用-L选项指定load-path的值\n对于每个load-path中的目录,emacs都会去检查是否有subdirs.el这个文件,若存在该文件,则加载它. 由emacs自动生成的subdirs.el会自动将该目录下的所有以 字母与数字结尾 的子目录路径添加到load-path中.\n 命令(locate-library library \u0026amp;optional nosuffix path interactive-call)  找到指定library所表示的精确文件名. 它的搜索方式与load一致.\n参数nosuffix与load参数中的一样. 非nil表示不添加.elc和.el后缀\n若PATH为非nil,则表示用参数PATH的值代替load-path的值\n当作为命令运行locate-library时,参数interactive-call的值为t,则会在echo area中显示file name,否则函数直接返回文件名称\n 命令(list-load-path-shadows \u0026amp;optional stringp)  该命令列出隐藏的Emacs Lisp文件的列表.\n所谓隐藏文件指的是这样一些文件,虽然在load-path中有定义其目录,但是由于在搜索到其目录之前已经发现了符合条件的加载文件,因此load命令无法加载到这些文件.\n参数stringp指定是以字符串的形式返回文件列表,还是显示在buffer中.\nAutoload autoload让你在一开始只是记录函数/宏所对应的加载文件路径. 当第一次用到该函数/宏(或查看其帮助文档)时才开始加载对应的文件.\n有两种方法设置一个autoload函数:使用autoload函数和在源代码中使用特定的注释\n (autoload function-or-macro filename \u0026amp;optional docstring interactive type)  该函数指定function-or-macro为autoload函数/宏. 其源代码定义在filename中.\n若filename中不包含目录名称或.el/.elc的后缀,该函数会自动在加载时添加后缀,并且该函数不会加载不带后缀的文件.\n参数doc-string使得在不加载实际文件前,也能够查看function-or-macro的对应说明.\n参数interactive为非nil,则表示function-or-macro为命令. 这使得Emacs能够为M-x提供该命令的补全而不用加载function-or-macro的真实定义.\n当参数function-or-macro为macro/keymap时,可以将type参数设置为\u0026rsquo;macro或\u0026rsquo;keymap\n若function-or-macro已经有一个非autoload的非空函数,则autoload什么也不做,只是返回nil\n (autoloadp object)  判断object是否为autoload类型的对象\n 使用特殊注释定义autoload对象  在定义真实的函数定义前,加上注释`;;;###autoload\u0026rsquo;(这种特殊的注释,被称为autoload cookie)\n随后执行M-x update-file-autoloads/update-directory-autoloads命令,会将autoload的调用命令写道生成的loaddefs.el中.\n 变量generate-autoload-cookie  该变量指定了定义autoload对象的特殊注释格式,默认为`;;;###autoload\u0026rsquo;\n 变量generate-autoload-file  该变量定义了将生成的autoload语句放到哪个文件中,默认为`loaddefs.el\u0026rsquo;\n (autoload-do-load autoload-object \u0026amp;optional name macro-only)  加载autoload-object所在的源代码文件.\n参数name若为非nil则需要时一个表示autoload-function的symbol. 这时它的返回值为该symbol的实际定义函数.\n若参数macro-only为\u0026rsquo;macro,则autoload-do-load不加载函数,只加载macro\nFeatures features是除autoload外推迟加载的另一种方式.\n一个feature是一个表示函数与变量的集合的symbol,可以在文件中用provide声明一个feature,同时使用require来加载一个feature\n需要注意的是: 不要在let内使用require,否则可能会产生不可预知的后果.\nAlthough top-level calls to `require\u0026rsquo; are evaluated during byte compilation, `provide\u0026rsquo; calls are not. Therefore, you can ensure that a file of definitions is loaded before it is byte-compiled by including a `provide\u0026rsquo; followed by a `require\u0026rsquo; for the same feature, as in the following example.\n(provide \u0026#39;my-feature) ; Ignored by byte compiler, ; evaluated by `load\u0026#39;. (require \u0026#39;my-feature) ; Evaluated by byte compiler.  (provide feature \u0026amp;optional subfeatures)  该函数声明已经加载了feature,下次再require该feature时,不会去重新加载该feature所在的文件\n这里参数subfeatures应该而我一个由symbol组成的list,表示该版本的feature,提供了一系列的subfeatures\n (require feature \u0026amp;optional filename noerror)  该函数检查该Emacs Session是否已经加载了feature,若没有,则使用load加载filename.\n若参数filename为nil,则使用feature的字符串表示作为load的参数. 但要注意的是,这种情况下,require只会加载带有.el/.elc为后缀的文件(auto comression mode也有效果). 一个名为feature而不带任何后缀的文件不会被加载.\n若noerror参数为非nil,则当load文件失败时,只返回nil,而不抛出error.否则返回参数feature.\n若加载filename成功,而该文件没有provide feature,则require抛出error:`Required feature FEATURE was not provided\u0026rsquo;\nrequire语句会在编译阶段得到执行.\n (featurep feature \u0026amp;optional subfeature)  若feature已经加载到该Emacs Session(即feature是否为`features\u0026rsquo;中的member)则返回t.\n若subfeature为非nil,则只有在subfeature也被provided了的情况下才返回t\n 变量features  该变量为一个由symbol组成的list,每个symbol都是加载到该Emacs Session中的feature\n查找定义所在的文件  (symbol-file symbol \u0026amp;optional type)  查找定义symbol的文件路径.\n参数type指定了symbol的类型,可以是nil,\u0026lsquo;defun,defvar或defface\nsymbol-file实际是从`load-history\u0026rsquo;变量中查找symbol所在的文件的.\nUnloading  (unload-feature feature \u0026amp;optional force)  回收feature所定义的函数/变量,恢复之前的symbol定义.\n若变量`FEATURE-unload-function\u0026rsquo;的值为某个函数,则unload-feature会在执行清理前执行该函数. 若该函数返回nil,则unload-feature接着执行正常的清理过程,否则,unload-feature不再进行下一步的清理.\n默认情况下,unload-feature不会unload被其他库依赖的feature, 但若force参数为非nil,则unload-feature不会检查依赖关系.\nunload-feature函数也是根据变量`load-history\u0026rsquo;的内容来行动的.\n 变量unload-feature-special-hooks  该变量为一个hooks列表,在执行unload操作前,会先删除这些hooks中的定义在library中的函数.\nHooks  after-load-functions  load完某个文件后,会执行该hook,每个hook函数会接收一个参数:刚加载文件的绝对路径\n 宏(with-eval-after-load library-or-feature bodys\u0026hellip;)  若library-or-feature为library,则在每次加载完library文件后,都执行一次bodys代码\n若在执行该宏的时候,library已经被加载过了,则该宏会立刻执行一次bodys\n(with-eval-after-load \u0026#34;edebug\u0026#34; (def-edebug-spec c-point t) 若library-or-feature为feature,则在执行(provide feature)之后才回执行bodys的内容\n若执行bodys时抛出error,不会unload已加载的文件,但是会阻止bodys中的下面语句的执行.\n一般该宏没什么用.\nByte Compilation Elisp的Byte Compilation为伪编译,它将lisp编译为字节码格式,由特定的字节码解释器解释,而不是编译为与硬件相关的代码. 这使得它的速度会稍微慢点,但同时也保证了不同硬件平台之间的可移植性\n若希望某个lisp file不被编译,设置file-local变量no-byte-compile的值为t 格式为:`;; --no-byte-compile: t; --\u0026rsquo;\n当编译的文件中包含宏时要特别注意,因为在编译阶段,宏会被展开,这时可能宏的定义还未加载到Emacs中. 为了应付这种情况,一般使用require语句指定包含所需宏的文件(require在编译阶段会被执行). 为了防止用户在执行编译后程序时依然执行require语句,可以使用`eval-when-compile\u0026rsquo;包含`require\u0026rsquo;语句\n相关函数  (byte-compile symbol)  编译symbol的函数定义成字节码格式.\n参数symbol的函数定义必须是函数的真实代码,而不能是引用函数.\n参数symbol也可以是lambda表达式,但这种情况下,byte-compile只是返回对应的编译后代码,而并不存储它\n若symbol的函数定义是一个已经编译为字节码格式的函数,则该函数什么也不做,只是返回nil\n 命令(copmile-defun \u0026amp;optional arg)  编译并执行当前top-level form,并将结果输出到echo area中.\n若参数arg为非nil,则将结果插入到当前buffer中,执行的form位置后\n 命令(byte-compile-file filename \u0026amp;optional load)  该命令将lisp格式的filename编译为字节码格式的文件,生成的文件名称是原filename的.el后缀改为.elc后缀,若filename不带.el后缀,则生成的文件名为filename.elc\n若load参数为非nil,则在编译完filename后,还是加载编译后的文件.\n若byte-compile-file作为命令执行时,会提示输入要编译的文件,这时参数load额值为prefix argument\n 命令(byte-recompile-directory directory \u0026amp;optional flag force)  该命令重新编译directory及其子目录中的所有需要重新编译的.el文件(存在.elc文件比.el文件旧的.el文件)\n若存在没有对应.elc文件的.el文件,则由参数flag来说明该如何处理,nil表示不编译这些文件,0表示编译他们,其他值表示询问用户\n若参数force为非nil,则命令在重编译所有有对应.elc文件的.el文件.\n (batch-byte-compile \u0026amp;optional noforce)  该函数调用`byte-compile-file\u0026rsquo;编译命令行中指定的文件.\n该函数必须当Emacs处于batch状态时才能使用,因为当编译完成后,它会关闭Emacs.\nemacs -batch -f batch-byte-compile *.el 编译一个文件出错,不会妨碍其编译下一个文件,但这时,Emacs退出时会设置非0的状态码.\n若参数noforce为非nil,则,该函数不会编译那些已经有更新版本的.elc文件的.el文件\n 配置项byte-compile-dynamic-docstrings  默认情况下,Emacs从字节码文件中加载函数和变量时不会加载 他们的doc-string,当需要时才动态的从字节码文件中加载进来. 这就产生了一个后果:若此时字节码文件被更新了,那么原来的doc-string就被覆盖了.\n设置该配置项为nil,可以静止Emacs动态加载doc-string的行为.\n可以在lisp文件中添加一行\u0026rdquo;--byte-compile-dynamic-docstrings: nil;-\u0026quot;\n 变量byte-compile-dynamic  若为非nil,则表示开启\u0026quot;dynamic function loading\u0026quot;功能. 这时加载该文件并不会读取其中函数的真实定义,只有在正在调用该函数时采取临时读取该函数的定义.\n (fetch-bytecode function)  若function为byte-code function object,则立即从字节码文件中加载function的字节码.\n返回参数function\n编译期执行语句  (eval-and-compile bodys\u0026hellip;)  在编译期间和执行期间都执行bodys\n想过类似于将bodys放入file中,然后(require file)\nautoload和require在编译期和执行期都会执行.\n (eval-when-compile bodys\u0026hellip;)  只在编译期才计算bodys的值. 这时bodys的值被作为常量存储起来,当正常执行该段代码时,直接返回该常量\n(defvar my-regexp (eval-when-compile (regexp-opt \u0026#39;(\u0026#34;aaa\u0026#34; \u0026#34;aba\u0026#34; \u0026#34;abb\u0026#34;)))) Compiler Errors  (with-no-warning bodys\u0026hellip;)  执行bodys时,不出现warnning警告\n 变量`byte-compile-warnings\u0026rsquo;  控制编译时什么样的警告会被抛出\nDisassembly  (disassemble object \u0026amp;optional buffer-or-name)  显示object的反编译代码\nReading and Printing Lisp Objects Reading是将文本转换为lisp object的过程\nPrinting是将lisp object转换为文本的过程\nInput Stream 输入流可以是以下几种类型\n Buffer  从buffer中光标所处位置开始读取\n Maker  从buffer中指定Maker处开始读取\n string  从string的第一个字母开始读取\n function  由function产生要读取的字符. 这种函数必须支持两种调用模式:\n  当无参数调用时,返回下一个要读取的字符\n  当带一个参数(通常是一个字符)调用时,保存该参数,并在下一次无参数调用时返回它,及实现unreading功能.\n  t\n  表示从minibuffer中读取,若Emacs运行在batch mode状态下,则使用stdin\n nil  表示使用`standard-input\u0026rsquo;的值作为输入流\n symbol  表示使用symbol的函数定义作为输入,类似function\nInput Functions   (read \u0026amp;optional stream)\n从stream中读取一个S表达式,并转换为Lisp Object返回\n  (read-from-string string \u0026amp;optional start end)\n从string中读取一个S表达式,并返回\u0026rsquo;(lisp-object . postion)\n其中lisp-object为S读到的表达式,postion是string中剩余字符的位置(第一个未读字符的位置)\n(read-from-string \u0026#34;(setq x 55) (setq y 5)\u0026#34;) ; =\u0026gt; ((setq x 55) . 11) (read-from-string \u0026#34;\\\u0026#34;A short string\\\u0026#34;\u0026#34;) ; =\u0026gt; (\u0026#34;A short string\u0026#34; . 16) ;; Read starting at the first character. (read-from-string \u0026#34;(list 112)\u0026#34; 0) ; =\u0026gt; ((list 112) . 10) ;; Read starting at the second character. (read-from-string \u0026#34;(list 112)\u0026#34; 1) ; =\u0026gt; (list . 5) ;; Read starting at the seventh character, and stopping at the ninth. (read-from-string \u0026#34;(list 112)\u0026#34; 6 8) ; =\u0026gt; (11 . 8)   变量standard-input\n当stream参数为nil时,使用该变量的值作为steam参数的实参\n  变量read-circle\n若为非nil,则允许读取循环结果的S表达式,默认为t\n  Output Stream 输出流参数可以是以下类型:\n buffer  输出字符插入到Buffer中的光标处,光标会随着字符的插入而向前移动.\n Maker  输出字符插入Buffer中Maker处\n Function  Elisp使用输出字符作为参数调用function,该function应该存储这些输出字符\n t  输出结果到echo area\n nil  使用`standard-output\u0026rsquo;的变量值\n symbol  使用symbol的function定义\nOutput Functions   (print object \u0026amp;optional stream)\n输出object的文本表示到stream中.\n输出时,在object的前后都会增加一个回车. 并且会输出引用字符\n(progn (print \u0026#39;The\\ cat\\ in) (print \u0026#34;the hat\u0026#34;) (print \u0026#34; came back\u0026#34;)) ;; -| ;; -| The\\ cat\\ in ;; -| ;; -| \u0026#34;the hat\u0026#34; ;; -| ;; -| \u0026#34; came back\u0026#34; ;; =\u0026gt; \u0026#34; came back\u0026#34; 该函数返回object的文本表示字符串\n  (prin1 object \u0026amp;optional stream)\n类似print,但是不会在object的文本表示前后添加回车\n(progn (prin1 \u0026#39;The\\ cat\\ in) (prin1 \u0026#34;the hat\u0026#34;) (prin1 \u0026#34; came back\u0026#34;)) ;; -| The\\ cat\\ in\u0026#34;the hat\u0026#34;\u0026#34; came back\u0026#34; ;; =\u0026gt; \u0026#34; came back\u0026#34;   (princ object \u0026amp;optional stream)\n该函数输出object的文本表示到stream中,并返回参数object.\n该函数一般用来输出对人可读的信息(而不是对read函数可以读),因此该函数并不会插入引用字符,也不会在字符串两边加上双引号,更不会自动插入空格分隔两次调用间的内容\n(progn (princ \u0026#39;The\\ cat) (princ \u0026#34; in the \\\u0026#34;hat\\\u0026#34;\u0026#34;)) ;; -| The cat in the \u0026#34;hat\u0026#34; ;; =\u0026gt; \u0026#34; in the \\\u0026#34;hat\\\u0026#34;\u0026#34;   (terpri \u0026amp;optional stream)\n输出newline到stream中\n  (write-char char \u0026amp;optional stream)\n输出char到stream中,返回参数char\n  (prin1-to-string object \u0026amp;optional noescape)\n该函数返回一个字符串,该字符串的内容就是(prin1 object)的输出\n(prin1-to-string \u0026#39;foo) ;; =\u0026gt; \u0026#34;foo\u0026#34; (prin1-to-string (mark-marker)) ;; =\u0026gt; \u0026#34;#\u0026lt;marker at 2773 in strings.texi\u0026gt;\u0026#34; 若参数noescape为非nil,则输出时不使用引用字符\n(prin1-to-string \u0026#34;foo\u0026#34;) ; =\u0026gt; \u0026#34;\\\u0026#34;foo\\\u0026#34;\u0026#34; (prin1-to-string \u0026#34;foo\u0026#34; t) ; =\u0026gt; \u0026#34;foo\u0026#34; 也可以使用format函数实现该功能\n  宏(with-output-to-string bodys\u0026hellip;)\n该宏在将`standard-output\u0026rsquo;设置为一个字符串的环境下执行bodys,然后返回该字符串\n(with-output-to-string (princ \u0026#34;The buffer is \u0026#34;) (princ (buffer-name))) ;=\u0026gt;\u0026#34;The buffer is foo\u0026#34;   (pp object \u0026amp;optional stream)\n类似prin1,但是输出的格式更方便阅读.\n  Output Variables   standard-output\n当参数stream为nil时,使用该变量的值\n  print-quoted\n若该值为非nil,表示使用简写形式输出quoted forms.例如 (quote foo)输出为\u0026rsquo;foo, (function foo)输出为#\u0026lsquo;foo\n  print-escape-newlines\n若该值为非nil,则表示字符串中的newline字符,会被输出为\\n,formfeed符会被输出为\\f\n该参数影响prin1和print函数的输出方式,但是不能影响prnc的输出\n(prin1 \u0026#34;a\\nb\u0026#34;) -| \u0026#34;a -| b\u0026#34; =\u0026gt; \u0026#34;a b\u0026#34; (let ((print-escape-newlines t)) (prin1 \u0026#34;a\\nb\u0026#34;)) -| \u0026#34;a\\nb\u0026#34; =\u0026gt; \u0026#34;a b\u0026#34;   print-escape-nonascii\n若该变量值为非nil,则字符串中的unibyte格式非ascii字符输出为\\XXX的格式.\n该参数影响prin1和print函数\n  print-escape-multibyte\n若该变量值为非nil,则字符串中的mutibyte格式非ascii字符输出为\\XXX的格式.\n该参数影响prin1和print函数\n  print-length\n该变量指明了输出list,vector或bool-vector时,能输出最多多少个元素. 若超过这么多个元素,则使用引号缩写\n(setq print-length 2) ; =\u0026gt; 2 (print \u0026#39;(1 2 3 4 5)) ; =\u0026gt; (1 2 ...) -| (1 2 ...) nil表示无限制\n  print-level\n该变量值指明了输出时()和[]能够嵌套的最大深度,超过这个深度会用省略号代替,nil表示无限制\n  配置项eval-expression-print-length/eval-expression-print-level\neval-expression中使用的print-length/print-level版本\n  print-circle\n若该值为非nil,则在输出时开启探测object是否有循环结构\n  print-gensym\n若该值为非nil,则输出时开启探测symbol是否是uninterned.\n这时,uninterned symbol输出时会带有前缀#:\n  print-continuous-numbering\nIf non-`nil\u0026rsquo;, that means number continuously across print calls. This affects the numbers printed for `#N=\u0026rsquo; labels and `#M#\u0026rsquo; references. Don\u0026rsquo;t set this variable with `setq\u0026rsquo;; you should only bind it temporarily to `t\u0026rsquo; with `let\u0026rsquo;. When you do that, you should also bind `print-number-table\u0026rsquo; to `nil\u0026rsquo;\n  print-number-table\nThis variable holds a vector used internally by printing to implement the `print-circle\u0026rsquo; feature. You should not use it except to bind it to `nil\u0026rsquo; when you bind `print-continuous-numbering\u0026rsquo;.\n  float-output-format\n该变量指明了输出float类型数字时的格式. 默认为nil,表示在不丢失精度的情况下,使用最短的格式输出.\n  Documentation 获取doc-string  (documentation-property symbol property \u0026amp;optional verbatim)  查看symbol的property属性中存储的doc-string,它会自动从DOC文件中或编译的字节码代码中抽取出对应的doc-string\n若参数verbatim为nil,则,找到的doc-string会传入函数`substitute-command-keys\u0026rsquo;进行键绑定说明的转换\n(documentation-property \u0026#39;command-line-processed \u0026#39;variable-documentation) ; =\u0026gt; \u0026#34;Non-nil once command line has been processed\u0026#34; (symbol-plist \u0026#39;command-line-processed) ; =\u0026gt; (variable-documentation 188902) (documentation-property \u0026#39;emacs \u0026#39;group-documentation) ; =\u0026gt; \u0026#34;Customization of the One True Editor.\u0026#34;  (documentation function \u0026amp;optional verbatim)  该函数返回function的doc-string,其中function可以是macro,named keyboard macro,special forms,oridnary function\n若参数verbatim为nil,则,找到的doc-string会传入函数`substitute-command-keys\u0026rsquo;进行键绑定说明的转换\n若function没有函数定义,则抛出`void-function\u0026rsquo;错误,若函数定义没有doc-string,则返回nil\n (face-documentation face)  返回face的doc-string\n doc-directory  DOC文件的存放路径,Emacs可能要从DOC文件中读取doc-string\n替换doc-string中的key binding 当doc-string中要引用绑定的键序列时,使用特殊的引用形式可以通过函数`substitute-command-keys\u0026rsquo;转换为指定命令真实的绑定键序列.\n `\\[COMMAND]\u0026rsquo;  显示调用COMMAND时的键序列,若COMMAND没有绑定键序列,则显示为M-x COMMAND\n `\\{MAPVAR}\u0026rsquo;  使用函数`describe-bindings\u0026rsquo;显示MAPVAR所表示的keymap中的summary\n `\\\u0026lt;MAPVAR\u0026gt;'  转换为空值,该形式的说明会产生一个副作用:it specifies MAPVAR\u0026rsquo;s value as the keymap for any following `\\[COMMAND]' sequences in this documentation string.\n `\\='  引用接下来的那个字符;例如`\\=\\[\u0026lsquo;在显示时显示为`\\[',而`\\=\\=\u0026lsquo;显示为`\\=\u0026rsquo;\n将键序列输出为文本格式  (key-description sequence \u0026amp;optional prefix)  将sequence中的input event转换为文本格式\n(key-description [?\\M-3 delete]) ; =\u0026gt; \u0026#34;M-3 \u0026lt;delete\u0026gt;\u0026#34; (key-description [delete] \u0026#34;\\M-3\u0026#34;) ; =\u0026gt; \u0026#34;M-3 \u0026lt;delete\u0026gt;\u0026#34;  (single-key-description event \u0026amp;optinal no-angles)  将input event转换为文本形式字符串.\n若参数no-angle为非nil,则在包围在function keys和event symols的尖括号会被忽略,这是为了与旧版本的Emacs兼容.\n(single-key-description ?\\C-x) ; =\u0026gt; \u0026#34;C-x\u0026#34; (key-description \u0026#34;\\C-x \\M-y \\n \\t \\r \\f123\u0026#34;) ; =\u0026gt; \u0026#34;C-x SPC M-y SPC C-j SPC TAB SPC RET SPC C-l 1 2 3\u0026#34; (single-key-description \u0026#39;delete) ; =\u0026gt; \u0026#34;\u0026lt;delete\u0026gt;\u0026#34; (single-key-description \u0026#39;C-mouse-1) ; =\u0026gt; \u0026#34;\u0026lt;C-mouse-1\u0026gt;\u0026#34; (single-key-description \u0026#39;C-mouse-1 t) ; =\u0026gt; \u0026#34;C-mouse-1\u0026#34;  (text-char-description character)  返回描述character的字符串,类似`single-key-description\u0026rsquo;的作用\n(text-char-description ?\\C-c) ; =\u0026gt; \u0026#34;^C\u0026#34; (text-char-description ?\\M-m) ; =\u0026gt; \u0026#34;\\xed\u0026#34; (text-char-description ?\\C-\\M-m) ; =\u0026gt; \u0026#34;\\x8d\u0026#34; (text-char-description (+ 128 ?m)) ; =\u0026gt; \u0026#34;M-m\u0026#34; (text-char-description (+ 128 ?\\C-m)) ; =\u0026gt; \u0026#34;M-^M\u0026#34;  命令(read-kbd-macro string \u0026amp;optional need-vector)  `key-description\u0026rsquo;的逆操作\n参数string中包含了用空格分隔的key descriptions,该函数会返回一个string或vector,包含了对应的events.\n若参数need-vector,则总是返回vector\nElisp中的函数 Elisp中的函数,是跟C++不同的. C++中的函数必须有一个函数名,然而Elisp中的函数没有函数名,只是你可以把它与一个symbol相连接,这样这个symbol的名字就暂时作为该函数的函数名了.\n此外,Elisp中的函数可以通过与多个symbol相关连的方式而为同一个函数提供多个名称,而C++中的函数只有一个函数名称.\nElisp中函数的分类 函数的特性在与能够接收参数,然后返回计算结果,并可能产生一定的副作用. 在Elisp中符合这些特性的类函数对象有以下几种类型:\n lambda expression  匿名函数\n primitive  使用C语言编写的内置类函数对象,special form都认为是primitive的一种.\n special form  类似C语言中的固定语法的语句\n macro  宏,跟function类似,但它并不对参数进行预运算且返回的结果必须是一段S表达式.\n command  可以通过`command-execute`这个primitive调用的对象,通常是一个带了interactive声明的函数(也可能是keyboard macro).\n closure  闭包,带有静态作用域下变量的函数.\n byte-code function  编译为字节码的函数\n autoload object  它指向一个真实的函数的位置. 当真正调用到autoload object时,Emacs载入包含真正函数定义的那个文件,并且调用那个真正的函数.\n获取函数信息  (functionp object)  判断object是否为函数. 若为函数则返回t,但macro和special form会返回nil\nobject也可以为symbol类型,会自动判断它所指向的function.\n(functionp \u0026#39;goto-line) ;=\u0026gt;t  (subrp object)  判断object是否为primtive.\n注意: 与functionp不同.object为symbol的话,会返回nil.\n(subrp \u0026#39;message) ; `message\u0026#39; is a symbol, =\u0026gt; nil ; not a subr object. (subrp (symbol-function \u0026#39;message)) =\u0026gt; t  (byte-code-function-p object)  判断object是否为byte-code function. object为symbol类型则返回nil\n(byte-code-function-p \u0026#39;next-line) ; =\u0026gt; nil (byte-code-function-p (symbol-function \u0026#39;next-line)) ; =\u0026gt; t  (subr-arity subr)  这里subr需要为一个primitive对象(不能为symbol),该函数返回subr的最少参数个数和最大参数个数.\n返回格式为\u0026rsquo;(MIN . MAX).\n若参数有\u0026amp;rest,则MAX为many.\n若subr为special form,则该函数返回\u0026rsquo;unevalled\n (interactive-form function)  获取function的interactive信息\n匿名函数 获取匿名函数 获取匿名函数,主要有三种方法:\n  使用lambda宏\n(lambda (参数列表...) [函数描述字符串] [交互模式声明] 函数体...)   使用function函数\n(function function-object)\n类似quote函数,它直接返回 未计算 的参数function-object.\n(function 3) ;=\u0026gt;3,function的参数可以不为lambda表达式 (function (lambda add-1(x) (1+ x))) ;=\u0026gt;(lambda add-1(x) (1+ x)),但一般function的参数都是lambda表达式 所不同的是,该函数告诉Emacs evaluator和byte-compiler,function-object为函数.\n具体来说,若function-object为lambda表达式,则有两个附加效果:\n  When the code is byte-compiled, FUNCTION-OBJECT is compiled into a byte-code function object\n  When lexical binding is enabled, FUNCTION-OBJECT is converted into a closure\n    使用`#'`标识\n#\u0026lsquo;f是(function f)的缩写形式\n;; 一下三种写法是等价的 (lambda (x) (* x x)) (function (lambda (x) (* x x))) #\u0026#39;(lambda (x) (* x x))   参数列表 参数列表的格式为:(必须参数列表\u0026hellip;[\u0026amp;optional 可选参数列表] [\u0026amp;rest 剩余参数])\n使用\u0026amp;optional表示之后的参数是可选的.\n使用\u0026amp;rest表示之后的参数为不定参数. 它是实际参数的一个列表.\n若在实际调用函数时,没有为可选参数和剩余参数提供实际参数值,则这些参数值为nil.\n命名函数 使用fset/defalias将匿名函数与一个symbol想结合,就为这个匿名函数分配了一个名称.\n (fset symbol lambda函数)   (fset \u0026#39;plus-one (lambda (x) (+ x 1))) (plus-one 10) ;11  (defalias alias-name lambda-function-or-symbol \u0026amp;optional doc-string)  为函数设定名字或别名,一般很少用到\n(defalias \u0026#39;add-one \u0026#39;1+) (add-one 11) ;12 (defalias \u0026#39;add-two (lambda (x) (+ x 2))) (add-two 11) ;13 实际上,更常见的定义命名函数的方法是使用defun宏\n (defun 函数名 (参数列表) [函数说明字符串] [declare-form] [交互模式声明] 函数体\u0026hellip;)  定义一个带名字的函数.\n(defun add-one (x) \u0026#34;return value after plus one\u0026#34; (+ x 1)) (add-one 10) ;11 注意: 它可以比lambda函数多一个declare-form部分,这个declare-form通常用于提供Elisp编译器一些函数的信息,以便进行优化.\n (fboundp symbol)  判断symbol是否可以作为函数使用\n (fmakunbound symbol)  删除函数,使symbol不再作为函数使用.\ndeclare form declare form常用来为函数或宏添加一些关于属性的元标签. 它的语法是:\n  (declare specs\u0026hellip;)\n其中spec的格式为(PROPERTY ARGS\u0026hellip;),spec可以是以下几种说明\n (advertised-call-convention new-arg-list when)  new-arg-list为正确的调用函数的方法,其他的调用方法都被认为是废弃的.\nwhen为一个表示什么时候废弃的字符串.\n (debug EDEBUG-FORM-SPEC)  只能在定义宏时使用. 当用Edebug来调试该宏时,使用EDEBUG-FORM-SPEC\n (doc-string N)  This is used when defining a function or macro which itself will be used to define entities like functions, macros, or variables\n它表示,第N个参数作为doc-string来看待\n (ident indent-spec)  Indent calls to this function or macro according to INDENT-SPEC.\n虽然可以用在函数上,但一般还是用在宏定义中\n (obsolete current-name when)  类似(make-obsolete),表示该函数被废弃了\n (compiler-macro EXPANDER)  只能用在函数定义时,告诉编译器在编译时,使用EXPANDER代替该函数.\n这样的话,所有的(function args\u0026hellip;)都实际上调用的是(EXPANDER args\u0026hellip;)\n (gv-expander EXPANDER)  Declare EXPANDER to be the function to handle calls to the macro (or function) as a generalized variable, similarly to `gv-define-expander\u0026rsquo;.\nEXPANDER can be a symbol or it can be of the form `(lambda (ARG) BODY)' in which case that function will additionally have access to the macro (or function)\u0026rsquo;s arguments.\n (gv-setter SETTER)  Declare SETTER to be the function to handle calls to the macro (or function) as a generalized variable. SETTER can be a symbol in which case it will be passed to `gv-define-simple-setter', or it can be of the form `(lambda (ARG) BODY)' in which case that function will additionally have access to the macro (or function)\u0026rsquo;s arguments and it will passed to `gv-define-setter'.\n  调用函数 最常用的调用函数的方式是将函数作为一个list的第一个参数. 这样当计算这个list时,会把地一个元素作为函数,其他作为参数来调用.\n但是有的时候,需要在运行期间决定要执行的函数,这时候就需要使用以下函数的帮助:\n (funcall function \u0026amp;rest arguments\u0026hellip;)  使用参数arguments调用函数function.\n(setq f \u0026#39;list) ; =\u0026gt; list (funcall f \u0026#39;x \u0026#39;y \u0026#39;z) ; =\u0026gt; (x y z) (funcall f \u0026#39;x \u0026#39;y \u0026#39;(z)) ; =\u0026gt; (x y (z)) 参数function必须是一个lisp function或primitive function,而不能是macro或special form\n (apply function \u0026amp;rest arguments\u0026hellip;)  类似funcall函数,但apply的arguments中,最后一个参数 必须 是list. 而这个list中的元素会被打散为独立的参数来作为function的实参.\n(setq f \u0026#39;list) ; =\u0026gt; list (apply f \u0026#39;x \u0026#39;y \u0026#39;z) ; error--\u0026gt; 最后一个参数z不是list类型 (apply \u0026#39;+ 1 2 \u0026#39;(3 4)) ; =\u0026gt; 10 (apply \u0026#39;+ \u0026#39;(1 2 3 4)) ; =\u0026gt; 10 (apply \u0026#39;append \u0026#39;((a b c) nil (x y z) nil)) ; =\u0026gt; (a b c x y z)  (apply-partially func \u0026amp;rest args)  apply-partially使用参数args绑定func中的前(length args)个参数,并由此产生一个新的函数.\n返回的新函数接受剩余的参数,并在内部调用原func函数.\n(defalias \u0026#39;add-1 (apply-partially \u0026#39;+ 1) \u0026#34;Increment argument by one.\u0026#34;) (add-1 10) ; =\u0026gt; 11  (identity arg)  该函数返回参数arg,没有任何其他处理\n (ignore \u0026amp;rest args)  该函数忽略args,直接返回nil\n若要对某个集合(包括list)中的每个元素都调用某个函数(注意,不能是宏和special form),需要使用到map系列的函数.\n需要注意的是,char-table比较特殊,只能用map-char-table函数调用.\n (mapcar function sequence)  mapcar将sequence中的每个元素都调用一次function方法,并将结果组成一个list返回.\n(mapcar \u0026#39;car \u0026#39;((a b) (c d) (e f))) ; =\u0026gt; (a c e) (mapcar \u0026#39;1+ [1 2 3]) ; =\u0026gt; (2 3 4) (mapcar \u0026#39;string \u0026#34;abc\u0026#34;) ; =\u0026gt; (\u0026#34;a\u0026#34; \u0026#34;b\u0026#34; \u0026#34;c\u0026#34;)  (mapc function sequence)  类似mapcar,但不收集个函数的运算结构. mapc的返回值为参数sequence\n (mapconcat function sequence separator)  对sequence中的每个元素都调用function方法,其function方法计算的结果必须为string类型. 然后将这个string类型的结果用separator结合起来.\n(mapconcat \u0026#39;symbol-name \u0026#39;(The cat in the hat) \u0026#34; \u0026#34;) ; =\u0026gt; \u0026#34;The cat in the hat\u0026#34; (mapconcat (function (lambda (x) (format \u0026#34;%c\u0026#34; (1+ x)))) \u0026#34;HAL-8000\u0026#34; \u0026#34;\u0026#34;) ; =\u0026gt; \u0026#34;IBM.9111\u0026#34;  (cl-maplist function list\u0026hellip;)  类似mapcar,但调用function的参数为(cdr list)\n(maplist #\u0026#39;(lambda (x) x) \u0026#39;(a b c)) ;; ((a b c) (b c) (c)) 废弃函数 类似变量一样,函数也可以被标注为废弃的.\n (make-obsolete obsolete-name current-name \u0026amp;optional when)  该函数标注obsolete-name为废弃的. 其中\nobsolete-name可以为表示函数或宏的symbol,也可以为函数或宏的别名.\ncurrent-name可以是一个symbol,表示使用current-name代替obsolete-name. 也可以是一个字符串表示废弃的警告说明. 也可是nil.\nwhen应该是一个日期或版本号的字符串,用于表示什么时候开始废弃该函数.\n (define-obsolete-function-alias obsolete-name current-name \u0026amp;optional when doc)  该宏定义obsolete-name为函数current-name的别名,同时标注obsolet-name为废弃的函数.\n该宏等价于:\n(defalias OBSOLETE-NAME CURRENT-NAME DOC) (make-obsolete OBSOLETE-NAME CURRENT-NAME WHEN)  (set-advertised-calling-convention function new-arg-list when)  该函数与上面两个函数不同点在于,它不是标注某个函数为废弃的,它只标注某个函数的某种用法为废弃的.\n任何不使用new-arg-list表示的实参调用function函数都会被警告为废弃的.\nwhen表示什么时候开始废弃function的原用法,一般为表示版本号的字符串.\n;; 在老版本中sit-for函数可以接受三个参数 (sit-for seconds milliseconds nodisp) ;; 然而用这种调用方法在Emacs22.1版本之后就被废弃掉了,因此可以这样设置 (set-advertised-calling-convention \u0026#39;sit-for \u0026#39;(seconds \u0026amp;optional nodisp) \u0026#34;22.1\u0026#34;) ;表示新的sit-for函数签名为(defun sit-for (seconds \u0026amp;optional nodisp)) 内联函数 要定义内联函数,只需要将定义函数的defun,换成defsubst即可\n(defsubst name (arg-list) [doc-string] [declare-form] [interactive] bodys) 注意:虽然内联函数会加快函数的执行速度,但它会增加文件和内存的消耗量,而且对debugging,tracing和asdising支持不够好,因此除非速度真的很重,否则不要用内联函数.\n函数声明  (declare-function function file \u0026amp;optional arglist fileonly)  该宏告诉编译器,function函数在文件file中定义,且参数签名为arglist.\n编译器会检查文件file中是否包含了function函数,且参数签名是否为arglist,若想让编译器不检查函数的参数签名,需要将arglist设置为t\n若参数fileony为非nil,表示只检查file存在,而不检查文件中是否定义了function.\n函数描述字符串(docstring)  一般来说,函数描述字符串的第一行为对该函数作用的总结.  docstring的第一行最好独立的,因为apropos命令只显示第一行的文档 docstring中参数最好用大些字母 docstring以*开头的defvar变量被认为是用户选项（user option） 用户选项可以通过命令set-variable交互设置 可以使用edit-options命令编辑*scratch* `符号名\u0026rsquo;生成一个链接 \\\\{major-mode-map}可以显示扩展成按键的说明 docstring最后那个的\\[ command ]会被command的绑定键所代替 如果不想要这种代替，需要用\\=转义，当然，在Emacs的docstring中，真正的写法应该是 \u0026#34;\\\\=\\\\{major-mode-map}\u0026#34; \u0026#34;\\\\=\\\\[command]\u0026#34;    将`\\n(fn ARGLIST)`放在最后一行,会自动扩展为该函数的实际参数列表.  交互模式声明 若一个函数带了交互模式声明,则它也就是一个命令了,即可以通过M-x(execute-command)来调用了.\n交互模式声明的格式为(interactive code-string),其中:\n  若interactive的参数以*开头，则意义是，如果当前buffer是只读的，则不执行该函数\n  interactive可以后接字符串,表示获得参数的方式\n  p 接收C-u的数字参数\n也可以不用P参数,直接在代码中判断current-prefix-arg的值\n  r region的开始/结束位置\n  n 提示用户输入数字参数,n后面可用接着提示符\n  s 提示用户输入字符串参数\n  若函数接收多个input,需要用\\n来分隔\n  interactive可以后接一个form,form的求值结果应该是一个list,这个list的值作为参数的实参\n  在form中一般会用到如下几个函数用于获取用户输入\n read-string read-file-name read-directory-name read-regexp y-or-n-p read-from-minibuffer 使用变量`current-prefix-arg`来判断是否有universal-argument  declare-form 使用`declare\u0026rsquo;宏能够为函数或宏增加元属性. 它的语法为:\n(declare specs...) 其中spec的格式为`(property args\u0026hellip;)'. 目前支持以下几种spec\n  (advertised-calling-convention SIGNATURE WHEN)\n该spec的功能类似调用`set-advertised-calling-convention\u0026rsquo;函数\n其中,SIGNATURE为参数列表,指定了调用函数或宏的正确用法. WHEN为一个字符串指明了什么时候开始废除原函数用法.\n  (debug edebug-form-spec) 该spec只对宏有效. 当使用edebug调试宏时,使用edebug-form-spec. 参见Instrumenting Macro Calls\n  (doc-string n) 指明第n个参数为documentation string\n  (indent indent-spec) 对当前函数或宏缩进时,根据indent-spec来缩进. 该功能通常用在宏中,但也对函数生效. 参见Indenting Macros\nindent-spec可以是:\n  nil 使用标准缩进模式\n  defun 将该宏看成是一个`def\u0026rsquo;结构: 这种结构中会将第二行看成是body的起始行\n  an integer,number The firstnumberarguments of the function aredistinguishedarguments; the rest are considered the body of the expression. A line in the expression is indented according to whether the first argument on it is distinguished or not. If the argument is part of the body, the line is indented lisp-body-indent more columns than the open-parenthesis starting the containing expression. If the argument is distinguished and is either the first or second argument, it is indented twice that many extra columns. If the argument is distinguished and not the first or second argument, the line uses the standard pattern.\n  表示函数名称的symbol 该函数接收两个参数`pos\u0026rsquo;和`state',并且应该返回一个表示应该缩进到多少列的数字,或一个car表示缩进列的list. 其中\n  pos: 光标当前行缩进的起始位置(The position at which the line being indented begins.)\n  state: 函数`parse-partial-sexp\u0026rsquo;解析从光标当前位置到当前行行首之间内容的返回结果\nThe difference between returning a number and returning a list is that a number says that all following lines at the same nesting level should be indented just like this one; a list says that following lines might call for different indentations. This makes a difference when the indentation is being computed byC-M-q; if the value is a number, C-M-qneed not recalculate indentation for the following lines until the end of the list\n         (obsolete current-name when) 该spec功能类似调用`make-obolete\u0026rsquo;函数\ncurrent-name为一个symbol,或string,或nil\nwhen为一个字符串用来指定什么时候开始废弃该函数/宏\n  判断function是否安全 使用unsafep来判断一个form是否是安全的\n (unsafep form \u0026amp;optional unsafep-vars)  若判断form为安全的可以执行,则返回nil. 否则返回一个list描述为什么form是不安全的.\nThe argument UNSAFEP-VARS is a list of symbols known to have temporary bindings at this point;\nThe current buffer is an implicit argument, which provides a list of buffer-local bindings.\nAdvising Emacs Lisp Functions Emacs\u0026rsquo;s advice system provides two sets of primitives for that: the core set, for function values held in variables and object fields (with the corresponding primitives being `add-function' and `remove-function') and another set layered on top of it for named functions (with the main primitives being `advice-add' and `advice-remove').\nCore Advising Primitives  (add-function where function-place advise-function \u0026amp;optional props)  为存储function的place(泛化变量)加上advise-function,使之称为一个组合了原始函数和advise函数的组合函数.\n  where参数指明了advise-function与function-place处函数的整合方式.\n  :before\n  在调用原function(function-place所存放的function)前调用advise-function.\n原function与advise-function接收同样的参数调用,并以原function的返回结果为组合函数的返回结果\n(add-function :before \u0026#39;old-function \u0026#39;advise-function) ;; 等价于 (lambda (r) (advise-function r) (old-function r))  :after  在原function调用之后调用advise-function.\n原function与advise-function接收同样的参数调用,并以原function的返回结果为组合函数的返回结果\n(add-function :after \u0026#39;old-function \u0026#39;advise-function) ;; 等价于 (lambda (r) (prog1(advise-function r) (old-function r)))  :override  用advise-function代替原function\n :around  使用advise-function代替原function,但原function会作为第一个参数传递給advise-function. 这样advise-function内可以调用原函数.\n(add-function :around \u0026#39;old-function \u0026#39;advise-function) ;; 等价于 (lambda (r) (apply \u0026#39;advise-function \u0026#39;old-function r))  :before-while  先执行advise-function,若advise-function返回nil,则不再调用原function.\nadvise-function与原function公用一样的参数,使用原function的结果作为组合函数的返回值\n(add-function :before-while \u0026#39;old-function \u0026#39;advise-function) ;; 等价于 (lambda (r) (and (apply \u0026#39;old-function r) (appy \u0026#39;advise-function r)))  :before-until  先执行advise-function, 只有当advise-function返回nil,才调用原function.\nadvise-function与原function共用一样的参数,使用原function的结果作为组合函数的返回值\n(add-function :before-while \u0026#39;old-function \u0026#39;advise-function) ;; 等价于 (lambda (r) (or (apply \u0026#39;old-function r) (appy \u0026#39;advise-function r)))  :after-while  先调用原function,若function返回nil,则不调用advise-function.\n原function和advise-function共用同样的参数. 组合函数的返回结果为 advise-function 的返回结果\n(add-function :after-while \u0026#39;old-function \u0026#39;advise-function) ;; 等价于 (lambda (rest r) (and (apply \u0026#39;old-function r) (apply advise-function r)))  :after-until  先调用原function,只有当function返回nil时,才调用advise-function.\n原function和advise-function共用同样的参数. 组合函数的返回结果为 advise-function 的返回结果\n(add-function :after-while \u0026#39;old-function \u0026#39;advise-function) ;; 等价于 (lambda (rest r) (or (apply \u0026#39;old-function r) (apply advise-function r)))  :filter-args  先用原始参数调用advise-function,再将advise-function返回的结果(advise-function必须返回一个list)作为参数,来调用原function.\n(add-function :filter-args \u0026#39;old-function \u0026#39;advise-function) ;; 等价于 (lambda (reset\u0026amp; r) (apply \u0026#39;old-function (funcall \u0026#39;advise-function r)))  :filter-return  先调用old-function,将结果作为参数调用advise-function.\n(add-function :filter-return \u0026#39;old-function \u0026#39;advise-function) ;; 等价于 (lambda(rest\u0026amp; r) (funcall \u0026#39;advise-function (apply \u0026#39;old-function r)))   function-place为被添加advise-function的函数位置. 它同时也决定了该advise是全局都有用,还是只在当前buffer生效.\n若function-place是一个symbol,则该advise全局生效\n若function-place为'(local SYMBOL-expression),这里SYMBOL-experssion表示一个expression,它的计算结果为一个表示变量的symbol. 则该advise只在当前buffer生效\n若要对静态作用域下的变量提出advise,则function-place的格式应为(var VARIABLE)\n props参数为一个代表属性的alist,目前只支持两个属性:  name属性,表示该advice的名字,当remove-function时有用. 尤其是当advise-function为匿名函数时,特别有用.\ndepth属性,表示优先级,用于决定多个advise-function的执行顺序. 他的取值范围从-100(表示最接近原始函数的执行顺序)到100(表示里原始函数的执行顺序最远). 默认为0 当两个advise-function用了同一个优先级,则最后添加的advise-function会覆盖前面的.\n advise-function参数  若advise-function没有interactive声明,则advise后的组合函数会继承原始函数的interactive声明.\n若advise-function有interactive声明,则advise后的组合函数使用advise-function的interactive声明.\n上述关于advised后的组合函数的interactive声明,在某一种情况下不成立: if the interactive spec of FUNCTION is a function (rather than an expression or a string), then the interactive spec of the combined function will be a call to that function with as sole argument the interactive spec of the original function. To interpret the spec received as argument, use `advice-eval-interactive-spec'.\n  (remove-function function-place advise-function)\n  删除通过add-function添加到function-place的advise-function\n (advice-function-member-p advice-function function-def)  判断advice-function是否已经function-def的advice\n (advice-function-mapc f function-def)  用添加到function-def的每个advicse-function和对应的propos作为参数,都调用一次f函数.\n (advice-eval-interactive-spec interactive-spec)  根据interactive-spec所声明的interactive方式,返回对应的获取值.\nAdvising Named Functions advice的最常用法是給命名函数或宏添加advice\n这种方法会引入一些问题,最好在没有办法的时候,使用下面的方法添加advice\n  (advice-add function-symbol where advice-function \u0026amp;optional props)\n为function-symbol添加名为advice-function的advice. where和props参数与add-function一致\n  (advice-remove function-symbol advise-function)\n  删除function-symbol上的advise-function\n (advice-member-p advise-function function-symbol)  判断advise-function是否已经是function-symbol的advice了\n (advice-mapc f function-symbol)  使用function-symbol中的每个advise-function及其对应的props作为参数,用f来调用.\n宏 宏与函数的不同  宏的参数在传递給宏前并不会作计算处理,也就是说宏看到的是传递给它的原始参数. 而函数参数传递給函数时是已经经过计算的结果,也就是说函数看到的是参数的计算结果. 宏的计算结果需要是一个S表达式(这个过程被称为宏扩展),Elisp会再计算这个返回的S表达式以算出最终结果.  定义宏 定义宏的格式与定义函数的格式一样,只是用defmacro替代defun\n(defmacro macro-name (参数列表...) [函数描述字符串] [declare-form] [交互模式声明] 函数体...) destructuring-bind宏接受一个匹配模式,一个求值到列表的实参,以及一个表达式体，然后在求值表达式时将模式中的参数绑定到列表的对应元素上.例如\n(destructuring-bind (x (y) . z) \u0026#39;(a (b) c d) (list x y z)) (a b (c d))\ndefmacro宏允许任意列表结构作为参数列表.当宏调用被展开时,宏调用中的各部分将会以类似destructuring-bind的方式被赋值到宏的参数上面 例如,可以这样定义dolist宏\n(defmacro our-dolist ((var list \u0026amp;optional result) \u0026amp;body body) `(progn (mapc #\u0026#39;(lambda (,var) ,@body) ,list) (let ((,var nil)) ,result))) 宏扩展 调用宏会将传递給宏的参数扩展成一个S表达式,这个过程称为宏扩展过程.\n  (macroexpand macro-form \u0026amp;optional environment)\n递归扩展macro-form直到结果中不再为宏调用为止(不代表结果中就不包含宏了,只是第一个元素不为宏而已). 然后返回扩展结果.\n(defmacro inc (var) (list \u0026#39;setq var (list \u0026#39;1+ var))) (macroexpand \u0026#39;(inc r)) ; =\u0026gt; (setq r (1+ r)) (defmacro inc2 (var1 var2) (list \u0026#39;progn (list \u0026#39;inc var1) (list \u0026#39;inc var2))) (macroexpand \u0026#39;(inc2 r s)) ; =\u0026gt; (progn (inc r) (inc s)) ; `inc\u0026#39;并没有扩展 environment参数为一个包含宏定义的alist. macroexpand在扩展宏时会使用environment中的宏定义替代当前环境下的宏定义.\n  (macroexpand-all macro-form \u0026amp;optional environment)\n类似macroexpand,但会递归扩展直到结果中不再包含宏为止.\n(defmacro inc (var) (list \u0026#39;setq var (list \u0026#39;1+ var))) (macroexpand \u0026#39;(inc r)) ; =\u0026gt; (setq r (1+ r)) (defmacro inc2 (var1 var2) (list \u0026#39;progn (list \u0026#39;inc var1) (list \u0026#39;inc var2))) (macroexpand-all \u0026#39;(inc r s)) ; =\u0026gt; (progn (setq r (1+ r)) (setq s (1+ s))) inc也扩展了   当对程序进行编译时,编译器在遇到宏调用时,会对宏进行扩展,因此:\n  要注意分清哪些操作应该放在宏扩展的过程中完成,哪些操作放在宏扩展后的结果中进行. 例如\n(defmacro my-set-buffer-multibyte (arg) (if (fboundp \u0026#39;set-buffer-multibyte) (set-buffer-multibyte arg))) ;在编译期执行该操作其实是没有意义的,应该改为`(set-buffer-multibyte ,arg)   不要在宏中对宏参数进行eval操作. 因为这时候宏参数还并未绑定任何实际参数.\n  由于编译器只对宏进行一次扩展,在其他使用宏的地方不再进行扩展动作,而在解释执行时会在每次宏调用时都对宏进行扩展. 因此宏扩展的过程,不能产生副作用,否则就会发生编译和解释执行结果不一致的情况. 例如:\n(defmacro empty-object () (list \u0026#39;quote (cons nil nil))) ;; 上面的宏在解释执行时,每次都会生成一个新的(nil). ;; 但在编译执行时,会在编译器生成一个(nil),然后每次都使用它   如果我们在主调函数编译以后，重定义那个宏. 由于对最初的宏调用的无迹可寻，所以函数里的展开式无法更新。该函数的行为将继续反映出宏的原来的定义\n此外,如果在定义宏之前，就已经编译了宏的调用代码，也会发生类似的问题.\n为了避免这类问题,我们需要\n  在调用宏之前，先定义它。\n  一旦重定义一个宏，就重新编译所有直接(或通过宏间接)调用它的函数(或宏)。\n    宏的工作模式 下面是一个宏的模拟实现\n(defmacro our-expander (name) `(get ,name \u0026#39;expander)) (defmacro our-defmacro (name parms \u0026amp;body body) (let ((g (gensym))) `(progn (setf (our-expander \u0026#39;,name) #\u0026#39;(lambda (,g) (block ,name (destructuring-bind ,parms (cdr ,g) ,@body)))) \u0026#39;,name))) (defun our-macroexpand-1 (expr) (if (and (consp expr) (our-expander (car expr))) (funcall (our-expander (car expr)) expr) expr)) 调试ELisp程序 有以下几种调试Elisp程序的方法\n 若运行程序时抛出异常,可以使用Emacs内置的debugger或edebug 通过查看编译器定位问题. 使用ERT包来写回归测试 使用profile来定义性能关注点  debugger 配置何时进入debugger 当Elisp程序运行时,若发生error,则根据配置项`debug-on-error`决定是否进入debugger.\n 配置项debug-on-error  若值为t,则任何种类的error都会进入debugger.\n若值为nil,则任何种类的error都不会进入debugger\n若值为error conditon的列表,则只有指定种类的error会进入debugger\n 配置项debug-ignored-errors  该变量在debug-on-error的基础上,屏蔽指定种类的error不触发debugger.\n该变量的值为一个由error condition和正则表达式组成的list. 任何符合error condtion的error,和error message匹配指定正则表达式的error,都不会触发debugger\n 配置项eval-expression-debug-on-error  该配置项的值为t时,使用eval-expression命令时,会将debug-on-error的值临时改为t.\n若该配置项为nil,则不会修改debug-on-error的值.\n 变量debug-on-signal  默认情况下,若error被condition-case所捕获,则不会进入debugger,但若该变量为非nil,则会先进入debugger,再被condition-case所捕获.\n当然,是否进入debugger,还要看debug-on-error和debug-ignored-errors的值\n一般不会使用该变量,而使用condition-case-unless-debug代替.\n debug-on-event  当Emacs捕获到指定event发生时,进入debugger\n debug-on-message  该变量为一个正则表达式,当在echo area显示了符合该正则的message时,进入debugger.\n该变量常用于寻找引起特定message的原因.\n  配置项debug-on-quit\n当按下C-g时,会产生一个quit,quit和error不是一回事,因此quit默认是不进入debugger的.\n通过设置该值为非nil,则当quit发生时,进入debugger\n  命令(debug-on-entry function-symbol)\n该命令标注当指定的function被调用时,主动进入debugger(无论有没有error/quit发生)\n(defun fact (n) (if (zerop n) 1 (* n (fact (1- n))))) ; =\u0026gt; fact (debug-on-entry \u0026#39;fact) ; =\u0026gt; fact (fact 3) ; =\u0026gt; 进入debugger   命令(cancel-debug-on-entry \u0026amp;optional function-symbol)\n该函数取消debug-on-entry对指定function的操作.\n若function-symbol为nil,则表示debug-on-entry对所有函数的操作.\n  (debug \u0026amp;rest debugger-args)\n显式调用debugger. 程序执行到该语句,会立刻进入debugger.\n通常debugger只是把debugger-args的值显示在backtrace buffer的首部,以方便用户可以看到它.\n然而,有些debugger-arg有其特殊的意义:\n 第一个参数为lambda  当debugger是由于参数`debug-on-next-call`设置为非nil的情况下进入了函数而触发的,则该变量会显示为`Debugger entered\u0026ndash;entering a function:`\n 第一个参数为debug  当debugger是由于设置了参数`debug-on-entry`的情况下进入了函数而触发的,则该变量会显示为`Debugger entered\u0026ndash;entering a function`\n 第一个参数为t  当debugger是由于参数`debug-on-next-call`设置为非nil的情况下进入了函数而触发的,则该变量会显示为`Debugger entered\u0026ndash;beginning evaluation of function call form`\n 第一个参数为exit,第二个参数为debug  当debugger是由于之前被b标记过的stack frame退出而触发的情况下,会显示为`Debugger entered\u0026ndash;returning value:`加上返回的值\n 第一个参数为error  当debugger是由于error/quit未捕获而触发时,会显示为`Debugger entered\u0026ndash;Lisp error:`加上error的信息\n 当第一个参数为nil  TODO 不知道什么意思.\n  debugger使用说明 当进入debugger后,会有一个名为*Backtrace*的buffer出现.\n在该buffer的第一行显示了进入debugger的原因,下面是backtrace.\nbacktrace由一系列的stack frame组成,每行一个stack frame. 其中\n 光标所在的stack frame为当前frame,有些debugger命令会对当前frame进行操作 若某stack frame以*开头,表示离开这个stack frame会再次调用debugger. 若stack frame中的函数名带了下划线,表示debugger可以找到该函数的源代码.  当进入debugger后,会根据`eval-expression-debug-on-error`的值来临时更改`debug-on-error`的值.若`eval-expression-debug-on-error`的值为t,则会设置debug-on-error的值为t. 这意味着在debug中触发的任意error都会产生一个backtrace. 若不想这样,可以设置`eval-expression-debug-on-error`为nil,或在`debugger-mode-hook`中设置`debug-on-error`为nil\nDebugger中的命令:\n  c\ncontinue. 退出debugger,并且继续向下执行.\n  d\n步进一个S表达式,然后看步进的那个S表达式做了什么操作.\n  b\n为当前frame加上断点标记. 加了标志的frame,在行头会加上一个*\n  u\n取消b命令为frame加上的断点标志.\n  j\n像b命令一样为当前frame加上标记,然后像命令c一样继续执行程序,但是在执行时会临时屏蔽`debug-on-entry`标记\n  e\n执行输入的S表达式. 通过该命令,可以修改debugger的变量.\n  R\n类似e,但是会把执行S表达式的结果,保存到一个名为*Debugger-record*的buffer中.\n  q\n退出debugger,退出程序的执行过程\n  r\n读取一个S表达式,并将其计算结果作为当前frame的返回值.\n当debugger是由于捕获到异常而触发时,无法使用该命令.\n  l\n列出会debug-on-entry的函数列表. 该列表根据`debug-on-entry`的值来过滤函数.\n  v\n显示/不现实当前stack frame中的局部变量\n  debugger内部实现使用到的变量与函数   debugger\n该变量的值需要是一个函数,当触发debugger时,实际上是通过调用该函数来实现的.\n该变量默认值为`debug`\n  (backtrace)\nThis function prints a trace of Lisp function calls currently active.\n(defun show-back-trace() (backtrace)) (show-back-trace) ;; ==================\u0026gt; backtrace() show-back-trace() eval((show-back-trace) nil) eval-last-sexp-1(nil) eval-last-sexp(nil) call-interactively(eval-last-sexp nil nil) command-execute(eval-last-sexp)   变量debug-on-next-call\n若该值为nil,则在执行下一个eval,apply或funcall之前,先会调用debugger.\n进入debugger后,会将该值设置为nil,但debugger中的d命令会将该变量设置为t\n  (backtrace-debug level flag)\n  变量command-debug-status\n该变量记录了当前interctive command的debug状态.\n  (backtrace-frame frame-number)\n  edebug 使用Edebug的一般步骤   引入函数/宏到edebug中来调试\n将光标移动到要debug的函数/宏定义上,按下C-u C-M-x(eval-defun)\n一旦函数/宏被引入到edebug来调试,任何调用该函数/宏的操作都会触发edebug执行.\n  Edebug跳转到定义Elisp源代码的buffer,且该buffer暂时变为只读的.\n  使用Edebug命令开始调试,可以使用`?`来显示Edebug命令\n  若不需要在用Edebug调试了,需要将函数/宏引出Edebug,方法是再执行一边函数/宏的定义即可.\n  Edebug中的命令    Execution Mode\nEdebug在调试程序时,也支持各种execution modes. 但它并不是实际上的major-mode或minor-mode\nexecution mode决定了Edebug下一次在哪里暂停,以及在暂停时显示多少执行的信息.\n   命令 说明     S Stop:不再往下执行程序,等待用户输入更多的Edebug命令(edebug-stop)   \u0026lt;SPC\u0026gt; Step:步进下一个语句(edebug-step-mode)   n Next:跳到下一个Form(edebug-next-mode)   t Trace:每执行一个语句(会在echo area显示每个语句执行的结果)就暂停一段时间(默认为1s,由参数`edebug-sit-for-seconds`确定)   T Rapid trace:类似t,但并不暂停(edebug-Trace-fast-mode)   g Go:继续执行直到下一个端口(edebug-go-mode)   c Continue:继续执行,在每个断点处都停顿一下,然后继续执行(edebug-continue-mode)   C Rapid continue:类似c,但在断点处并不停顿(edebug-continue-fast-mode)   G Go non-stop:忽略断点的存在,继续执行程序.    在程序执行过程中,可以用S或其他命令暂停程序的执行\n     Jumping命令\nJumping系列命令告诉Edebug,让程序执行直到指定的位置\n   命令 说明     h 执行到光标所在位置(edebug-goto-here)   f 执行一个sexp(edebug-forward-sexp)   o 执行完(跳出)当前的sexp(edebug-step-out)   i 进入form所调用的函数/宏定义(edebug-step-in)             Breaks\n在三种情况下,Edebug会暂停程序的执行:\n  设置断点\n   命令 说明     b 设置断点(edebug-set-breakpoint),若带prefix argument,则该断点为临时断点   u 取消断点(edebug-unset-breakpoint)   x CONDITION-FORM \u0026lt;RET\u0026gt; 设置条件断点,当运行CONDITION-FORM的结果为非nil时,断点生效(edebug-set-conditional-breakpoint). 若带prefix argument,则断点为零时断点   B 光标跳转到下一个断点处(edebug-next-breakpoint)    re-evaluting/reinstrumenting函数定义会移除之前的所有断点\n设置条件断点时,CONDITION-FORM抛出的error会被忽略,当成返回nil来看待.\n一般情况下,Edebug会在断点处暂停程序的执行. 然而,当Edebug处于Go-nonstop mode下时,会完全忽略断点.\n  当某个条件(Global Condition)匹配时\n若变量`edebug-global-break-condtion`的计算结果为非nil则暂停程序的执行. 同样的,若计算过程中抛出error,则当返回nil处理.\n可以在edebug模式下使用X命令来设置该条件. 也可以在任何buffer的任何时候,通过C-x X X来调用(edebug-set-global-break-condition)设置该条件\n  插入断点代码\n使用(edebug)主动调用edebug,进入断点模式.\n若执行(eedbug)时,该函数并未引入到edebug中,则该函数其实调用的是(debug)\n      Evaluation    命令 说明     e EXP \u0026lt;RET\u0026gt; 在Edebug的外部上下文环境中计算EXP(edebug-eval-expression)   M-: EXP \u0026lt;RET\u0026gt; 在Edebug的上下文环境中计算EXP(eval-expression)   C-x C-e 在Edebug的外部上下文环境中计算光标前的expression(edebug-eval-last-sexp)         Evalution List Buffer\n在Edebug中可以按E命令,进入名为*edebug*的\u0026quot;evaluation list buffer\u0026quot;.\n在该buffer中可以交互式的运行SEXP,且在该buffer中计算的SEXP,处于Edebug外部的上下文环境中.\n可以在该buffer中使用Lisp Interaction mode中的命令. 还可以执行以下命令:\n  C-j (edebug-eval-print-last-sexp)\n在edebug的外部上下文环境中,计算光标前的expression,并将结果插入到当前buffer\n  C-x C-e (edebug-eval-last-sexp)\n在edebug的外部上下文环境中,计算光标前的expression\n  C-c C-u (edebug-update-eval-list)\n基于当前buffer的内容,创建新的evaluation list\nevalution list由多个evalutation list groups组成. 每个groups由多个Lisp expression组成,group之间使用注释行来区分.\n当edebug每次暂停程序执行时,每个evaluation list group中的地一个Lisp expression都会自动执行一遍.\n(current-buffer) #\u0026lt;buffer *scratch*\u0026gt; ;--------------------------------------------------------------- (selected-window) #\u0026lt;window 16 on *scratch*\u0026gt; ;--------------------------------------------------------------- (point) 196 ;--------------------------------------------------------------- bad-var \u0026#34;Symbol\u0026#39;s value as variable is void: bad-var\u0026#34; ;--------------------------------------------------------------- (recursion-depth) 0 ;--------------------------------------------------------------- this-command eval-last-sexp ;---------------------------------------------------------------   C-c C-d (edebug-delete-eval-list)\n从evalution list中删除光标所在的group\n  C-c C-w (edebug-where)\n切换回当前暂停点的原代码buffer处\n      其他命令    命令 说明     ? 显示Edebug的帮助信息(edebug-help)   C-] Abort one level back to the previous command level(`abort-recursive-edit')   q 终止程序运行并退出edebug,但`unwind-protect`和`condition-case`中的代码还是会执行   Q 类似q,但`unwind-protect`和`condition-case`中的代码不会执行(edebug-top-level-nonstop)   r 重新在echo area中显示上次expression的运算结果(edebug-previous-result)   d 显示backtrace(但是不显示Edebug自己的function,并且此时处于标准debugger模式下),(edebug-backtrace)             捕获Errors\n默认情况下,若某函数被引入edebug中,则当该函数抛出error时,会自动激活edebug.\n但可以通过配置变量`edebug-on-error`和`edebug-on-quit`来改变这一情况.\n    Edebug Views  Edebug中的输出格式 当Edebug输出循环list结构时,可能会出错,这时需要设置一下几个变量\n  配置项edebug-print-length\n  配置项edebug-print-level\n  配置项edebug-print-circle\n  Trace Buffer 通过设置变量`edebug-trace`的值为非nil,可以使得Edebug将每次执行的过程都记录下来.\n记录存储在名为`*edebug-trace*`的buffer中. 它记录了使用什么参数调用那个函数,返回值是什么.\ntest coverage 使用步骤 通过testcover库,能够对代码进行铺盖面测试. 方法是:\n  载入testcover库\n(require \u0026lsquo;testcover)\n  执行命令testcover-start\nM-x testcover-start \u0026lt;RET\u0026gt; FILE \u0026lt;RET\u0026gt;\n  然后对你的代码进行测试\n  测试完成后执行命令testcover-mark-all命令会高亮出覆盖面不完全的地方\nM-x testcover-mark-all\n  使用命令testcover-next-mark跳转到下一个高亮点\n  高亮说明 一般来说,红色的高亮表示这个地方从来没有测试过.\n棕色的高亮表示这个地方的计算结果每次都一样的,而这往往意味着测试得还不够充分.\ngive advice to the test coverage too 可以通过将代码包裹进一些宏(这些宏本身不会改变代码的执行结果)中,来告诉testcover一些信息.\n  (1value form)\n该宏告诉testcover,form的计算结果每次都应该一样的.\n  (noreturn form)\n该宏告诉testcover,form不应该返回. 若form返回了,会收到一个run-time error\n  Profiling   使用M-x profiler-start开启性能监控,然后选择监控cpu还是mem还是两者都监控.\n  执行操作,运行待测试的函数\n  执行M-x profiler-report显示性能检测结果.\n  在报告中\n 按j可以跳转到函数定义处.     按d可以显示函数的documentation\n  可以使用C-x C-w保存检测报告\n  使用=比较两个检测结果\n  执行M-x profiler-stop结束监控过程\n  Trace (trace-function FUNCTION \u0026amp;optional BUFFER CONTEXT) 可以追踪函数FUNCTION的执行过程. 当调用到FUNCTION函数时,会在trace buffer中输出FUNCTION的参数以及返回值.\n参数BUFFER,指明了在哪个buffer中输出trace信息. 默认buffer名由变量`trace-buffer\u0026rsquo;决定\n使用该函数追踪FUNCTION时,总会弹出`trace-buffer\u0026rsquo; buffer.因此不要用该函数追踪哪些会切换buffer的函数,对于这种函数使用`trace-function-background\u0026rsquo;代替\n使用`untrace-function\u0026rsquo;或`untrace-all\u0026rsquo;停止对FUNCTION的追踪.\n(trace-function-background FUNCTION \u0026amp;optional BUFFERCONTEXT) 类似`trace-function',但追踪函数FUNCTION时,不会弹出buffer也不会改变window configuration\n(untrace-function FUNCTION) 取消对FUNCTION的追踪\n(untrace-all) 取消对所有的函数的追踪\nCommand Loop 当进入Emacs后,Emacs会循环读取key sequences,读取对应的命令,并显示结果. 这个过程称为Command Loop.\nCommand Loop概述   command loop第一步是调用函数`read-key-sequence\u0026rsquo;来读取key sequence,并转换为一个command或keyboard macro.\n  在执行command前,调用`undo-boundary\u0026rsquo;来保存undo信息\n  执行`pre-command-hook\u0026rsquo;中的函数\n在执行command前,会触发`pre-command-hook',这时变量`this-command\u0026rsquo;的值为将要运行的command,而`last-command\u0026rsquo;的值为上一次运行的command\n执行该hook参数时,不抛出quitting,也不抛出error,但会把抛出error的函数移除该hook\n  Emacs通过调用`command-execute\u0026rsquo;来读取传递給command的参数列表\n  若command为keyboard macro,则Emacs通过`execute-kbd-macro\u0026rsquo;来执行command\n  若command为命令(interactively callable function),则通过`call-interactively\u0026rsquo;来读取参数并执行command\n    执行`post-command-hook\u0026rsquo;中的函数\n在执行command后,会触发`post-command-hook',这时变量`this-command\u0026rsquo;的值为刚运行的command,而`last-command\u0026rsquo;的值为再上一次运行的command\n执行该hook参数时,不抛出quitting,也不抛出error,但会把抛出error的函数移除该hook\n  Command 所谓Command,不仅仅指的带有top-level `interactive' form的函数. 还可以是声明为interactive的autoload object,某些primitive functions,以及strings和vectors(被当成是keyboard macro来看待),\n (commandp object \u0026amp;optional for-call-interactively)  判断object是否为command\n若参数for-call-interactively为非nil,则只有在object能被`call-interactively\u0026rsquo;调用时才返回t,这时keyboard macro返回nil\n (command-execute command \u0026amp;optional record-flag keys special)  执行command\n若command为string或vector,则被认为是keyboard macro,会使用`execute-kbd-macro\u0026rsquo;执行command. 否则连同参数keys和record-flag一起传递給`call-interactively\u0026rsquo;一起调用\n参数special,若为非nil,则表示忽略preifix argument但是不clear它. 常用来执行特殊event\n 命令(execute-extended-command prefix-argument)  该命令使用`completing-read\u0026rsquo;从minibuffer中读取命令,并用`command-execute\u0026rsquo;执行该命令,并返回执行结果\n若读取的命令需要prefix argument,则会将参数prefix-argument传递給它.\n当用interactively的方式运行该命令时,参数prefix-argument的值就是传递給`execute-extended-command\u0026rsquo;的prefix-argument\n默认情况下,M-x执行的就是该命令\nDisabling Commands \u0026ldquo;Disabling a Command\u0026quot;給一个command加上标记,运行command时实际上会调用`disabled-command-function\u0026rsquo;所指向的函数,默认的行为是会要求用户确认是否执行该函数.\n被disable的command,其symbol的`disabled\u0026rsquo;属性被设置为非nil,若`disabled\u0026rsquo;属性为一个string,则警告信息中会包含该string\n (enable-command command)  允许command(symbol格式)不经确认就执行该command\n该命令会同时修改init文件,使之在以后的session中也生效\n (disable-command command)  使得command在之前,需要经过确认.\n该命令会同时修改init文件,使之在以后的session中也生效\n 变量disabled-command-function  该变量的值为一个function. 当用户交互式的调用一个disabled command时,实际上调用的是该函数.\n在该function中可以使用`this-command-keys\u0026rsquo;来探测用户实际的输入的key sequence,并以此来找到需要执行的函数.\n若值为nil,则disabled function跟普通function一样执行.\nCommand History command loop会记录执行过的complex command的历史记录.\n所谓complex command指的是其 interactive argument 会从minibuffer中读取参数值的command.(在执行command的过程中明确使用到minibuffer的,不算)\n command-history  记录了最近执行过的complex command的list\n 命令(repeat-complex-command N)  编辑并重新执行最后执行过的/倒数第N个complex command\n 命令(list-command-history)  列出在minibuffer中输入过的command的历史\n如何分辨Command是否通过Interactive方式调用 一个比较好的方法是在interactive form中设置某个标识为非nil. 例如\n(defun foo (\u0026amp;optional print-message) (interactive \u0026#34;p\u0026#34;) (when print-message (message \u0026#34;foo\u0026#34;))) 另一种方法是使用函数`called-interactively-p'\n (called-interactively-p kind)  若正在执行的function是通过`call-interactively\u0026rsquo;调用的,则返回t\n参数kind只能是\u0026rsquo;interactive或\u0026rsquo;any\n若参数kind为\u0026rsquo;interactive,则只有当function是直接由用户调用的情况下,才返回t(例如if the user typed a key sequence bound to the calling function, but not if the user ran a keyboard macro that called the function)\n(defun foo () (interactive) (when (called-interactively-p \u0026#39;any) (message \u0026#34;Interactive!\u0026#34;) \u0026#39;foo-called-interactively)) ;; Type `M-x foo\u0026#39;. -| Interactive! (foo) =\u0026gt; ni 若参数kind为\u0026rsquo;any,则包括keyboard macro在内,也返回t\n(defun bar () (interactive) (message \u0026#34;%s\u0026#34; (list (foo) (called-interactively-p \u0026#39;any)))) ;; Type `M-x bar\u0026#39;. -| (nil t) generic command 第一次执行用M-x COMMAND\u0026lt;RET\u0026gt;来执行generic command,Emacs会提示你选择哪一种具体实现,并保存选择信息,下一次就不会询问了. 若执行时带了prefix argument,则又会重复该过程.\nCOMMAND的不同实现存储在变量`COMMAND-alternatives\u0026rsquo;中,只有在该变量存在时,才能使用宏`define-alternatives\u0026rsquo;定义COMMAND的另一个实现方式.\nIf CUSTOMIZATIONS is non-`nil', it should consist of alternating `defcustom' keywords (typically `:group' and `:version') and values to add to the declaration of `COMMAND-alternatives'.\n 宏(define-alternatvies comand \u0026amp;rest customizations)  定义新命令COMMAND,参数COMMAND为一个symbol\n获取Command Loop中的信息  last-command  上次运行的command名称\n当一个command从command loop中退出时,会从`this-command\u0026rsquo;中复制该值\n real-last-command  类似`last-command',但不会被Lisp程序所修改\n last-repeatable-command  类似`last-command\u0026rsquo;但不保存input event. 这里面保存的是`repeat\u0026rsquo;命令会重复执行的command\n this-command  正在执行的命令名称,但有些命令会在执行时人工修改该值\n this-original-command  类似this-command,但当command remapping发生时,`this-command\u0026rsquo;存储的是实际运行的command名称,而`this-original-command\u0026rsquo;存储的是触发的原始command的名称\n (this-command-keys)  返回调用command的key sequence,返回类型为string或vector\n但若command调用了`read-key-sequence',则返回的是最后读取到的key sequence\n(this-command-keys) ;; Now use `C-u C-x C-e\u0026#39; to evaluate that. =\u0026gt; \u0026#34;^U^X^E\u0026#34;  (this-command-keys-vector)  类似`this-command-keys',只是返回的值总是vector\n (clear-this-command-keys \u0026amp;optional keep-record)  This function empties out the table of events for `this-command-keys' to return.\nUnless KEEP-RECORD is non-`nil', it also empties the records that the function `recent-keys' will subsequently return.\n一般常用于读取一个密码后\n last-nomenu-event  该变量斥候最后发生的input event(不包括mouse menu event)\n使用该变量的一个场景是用来告诉`x-popup-menu\u0026rsquo;在哪里弹出一个menu. 在`y-or-n-p\u0026rsquo;内也用到了该变量值\n last-command-event  This variable is set to the last input event that was read by the command loop as part of a command\n在`self-insert-command\u0026rsquo;中用到该变量来决定插入哪个character\nlast-command-event ;; Now use `C-u C-x C-e\u0026#39; to evaluate that. =\u0026gt; 5 ;; The value is 5 because that is the ASCII code for `C-e\u0026#39;.  last-event-frame  该变量记录了最后的input event是在哪个frame中调用的.\nUsually this is the frame that was selected when the event was generated, but if that frame has redirected input focus to another frame, the value is the frame to which the event was redirected.\nCommand的prefix argument prefix argument有两种表现形式:\u0026ldquo;raw\u0026quot;和\u0026quot;numeric\u0026rdquo;. coomand loop内部,和lisp变量使用raw表现形式\nHere are the possible values of a raw prefix argument:\n  `nil', meaning there is no prefix argument. Its numeric value is 1, but numerous commands make a distinction between `nil' and the integer 1.\n  An integer, which stands for itself.\n  A list of one element, which is an integer. This form of prefix argument results from one or a succession of `C-u\u0026rsquo;s with no digits. The numeric value is the integer in the list, but some commands make a distinction between such a list and an integer alone.\n  The symbol `-'. This indicates that `M\u0026ndash;' or `C-u -' was typed, without following digits. The equivalent numeric value is -1, but some commands make a distinction between the integer -1 and the symbol `-'.\n  (prefix-numeric-value arg)\n  这里的arg为raw格式的prefix argument. 该函数将arg转换为对应的numeric格式.\n若arg为nil,则返回1\n若arg为-,则返回-1\n若arg为数字,则返回该数字\n若arg为list,则返回(car arg)\n current-prefix-arg  该变量存储的是当前命令的raw prefix argument.\ncommand可以直接检查该变量的值,但大多数是使用`(interactive \u0026ldquo;P\u0026rdquo;)\u0026lsquo;来获取该参数的值\n prefix-arg  下一个命令使用的raw prefix argument.\n类似`universal-argument\u0026rsquo;这样的函数,通过设置该变量来为接下来要执行的命令设置prefix argument\n last-prefix-arg  上一个command的raw prefix argument\n (universal-argument)  该命令读取用户的输入,并将用户的输入值设置为变量`prefix-arg\u0026rsquo;的值,这样就为下一个待执行的command设置了prefix argument\n小心使用该函数\n (digit-argument arg)  This command adds to the prefix argument for the following command. The argument ARG is the raw prefix argument as it was before this command; it is used to compute the updated prefix argument.\n (negative-argument arg)  This command adds to the numeric argument for the next command. The argument ARG is the raw prefix argument as it was before this command; its value is negated to form the new prefix argument\nQuitting 当Lisp函数正在运行时,可以按下`C-g\u0026rsquo;,让Emacs退出当前的工作.\n然而当command loop在等待keyboard input时,按下C-g并不会引发quitting,Emacs只是把它当成一个普通的input character.\nwhen `C-g' follows a prefix key, they combine to form an undefined key. The effect is to cancel the prefix key as well as any prefix argument.\n而当在minibuffer中输入时,`C-g\u0026rsquo;的意义又不一样,它中断并退出minibuffer\n`C-g\u0026rsquo;通过设置变量`quit-flag\u0026rsquo;为t来表示要quit,Emacs检查该变量的值并产生quitting\n若想在执行Lisp函数时阻止quitting的产生,只需要将变量`inhibit-quit\u0026rsquo;绑定为非nil值即可.这时,即使`quit-falg\u0026rsquo;设置为t,依然不会产生quitting\n quit-flag  该值为非nil,除非`inhibit-quit\u0026rsquo;被设置为非nil,否则Emacs立即退出当前执行的任务.\n inhibit-quit  当`quit-flag\u0026rsquo;设置为非nil时,该变量决定Emacs是否执行退出\n 宏(with-local-quit body\u0026hellip;)  该宏执行body,执行过程中,即使`inhibit-quit\u0026rsquo;设置为非nil,也运行产生quitting.\n若body运行过程中,被quitting中断,则返回nil,否则返回最后语句的执行结果.\n若进入`with-local-quit\u0026rsquo;时,`inhibit-quit\u0026rsquo;为nil,则执行body时若产生quitting,则Emacs设置`quit-flag\u0026rsquo;并产生一个普通quit.\n若进入`with-local-quit\u0026rsquo;是,`inhibit-quit\u0026rsquo;为非nil,这时普通的quitting被推迟. 非nil的`quit-flag\u0026rsquo;会触发一种特殊的quit\u0026ndash;local quit. 它会终止body的执行并退出`with-local-quit'. 退出`with-local-quit\u0026rsquo;后的`quit-flag\u0026rsquo;依然为非nil.\n (keyboard-quit)  该函数设置产生quit的条件,默认绑定到C-g\nKeyboard Macro 一个\u0026quot;keyboard macro\u0026quot;指的是一系列的input event,这一系列的input event可以认为是一个command.(A \u0026ldquo;keyboard macro\u0026rdquo; is a canned sequence of input events that can be considered a command and made the definition of a key)\nkeyboard macro的lisp表现形式为一个string或由event组成的vector\n (execute-kbd-macro kbdmacro \u0026amp;optional count loopfunc)  把kbdmacro当作一系列的event来执行.\n若kbdmacro为string或vector,则就好像用户直接输入一样. The sequence is not expected to be a single key sequence\n若kbdmacro为symbol,则执行该symbol的函数定义,若该symbol的函数定义还是一个symbol,则不断的递归下去. 最终,其函数定义应该是一个string或vector,否则会抛出error\n参数count表示重复执行多少次kdbmacro,若count为nil,则执行一次,若count为0,表示执行无穷多次\n若loopfunc为非nil,则配次循环都会不带参数调用该函数,或函数返回nil,则停止执行该macro\n executing-kbd-macro  当前正在执行的kbd-macro,nil表示没有在执行kbd-macro\n defining-kbd-macro  只有当正在定义的kbd-macro的情况下,该值才为非nil.\n该值为\u0026rsquo;append表示正在为现有的macro添加定义( The value is `append' while appending to the definition of an existing macro)\n命令`start-kbd-macro',`kmacro-start-macro\u0026rsquo;和`end-kbd-macro\u0026rsquo;会设置该值\u0026ndash;尽量不要自己去设置该值\nThe variable is always local to the current terminal and cannot be buffer-local\n last-kbd-macro  最近所定义的kbd-macro\n kbd-macro-termination-hook  当keyboard macro执行完成后触发该hook(不管是正常结束还是异常结束都触发)\nInputEvent Emacs Command Loop读取一系列的\u0026quot;input event\u0026quot;来表示键盘/鼠标的动作,或发送给Emacs的系统事件.\n表示键盘动作的event,用char或symbol的格式表示. 其他类型的event统一用list来表示.\n (eventp object)  若object为input event或event type,则返回非nil\n需要注意的是,任何symbol既可以用来作为event,也可以作为event type,因此eventp不能区分一个symbol是被用于作为event,还是event type.\nKeyboard Event 键盘输入可以分为两类:普通的按键和功能键.\n普通按键事件 普通按键产生的event,在lisp中用character来表示.\nThe event type of a character event is the character itself (an integer)\n一个input character event由\u0026quot;basic code\u0026rdquo;(取值范围从0到524287)加上\u0026quot;modifier bits\u0026quot;组成\nmodifier bits包括:\n   说明 值 说明     meta 2**27    control 2**26 C-a这样的已经定义在ASCII中的控制字符,由于已经有了特定的basic code了,因此Emacs不需要使用special bit来指示它   shift 2**25 对于字符,数字和标点来说,basic code中已经定义相关的shift key按下后的对应键值,对于这些按键,Emacs不使用special bit   hyper 2**24    super 2**23    alt 2**22     最好不要直接在程序中使用specific bit(因为这些bit的位置可能会改变)\n应该使用`event-modifiers\u0026rsquo;函数来测试specific bit是否被设置\n   简写形式 说明     A- alt   C- control   H hyper   M- meta   S- shift   s- super    功能键事件 功能键event在elisp中用symbol来表示. 一般来说,symbol的名称就是功能键的label(全小些形式). 例如\u0026lt;F1\u0026gt;产生的input event表示为符号\u0026rsquo;f1\nThe event type of a function key event is the event symbol itself\n还有一些功能键event的表示与功能键的label不一致的情况:\n  `backspace',`tab',`newline',`return',`delete'\n  `left',`up',`right',`down'\n光标箭头按键\n  `kp-add',`kp-decimal',`kp-divide',\u0026hellip;\n右边小键盘的加减乘除\n  `kp-0',`kp-1',\u0026hellip;\n右边小键盘的数字键\n  `kp-f1',`kp-f2'\u0026hellip;\n右边小键盘的fn\n  `kp-hoome',`kp-left',`kp-up',`kp-right',`kp-down'\n右边小键盘的对应功能键\n  `kp-prior',`kp-next',`kp-end',`kp-begin',`kp-insert',`kp-delete'\n右边小键盘的对应功能键\n  以字符串表示keyboard event 现在一般不建议使用string来表示keyboard event,最好使用vector代替.\n可以使用函数`listify-key-sequence\u0026rsquo;来讲string格式的keyboard event转换为list,方便解析出其中的内容.\n需要注意:当使用字符串来表示keyboard event时,只有Meta modifier才能以'\\M-\u0026lsquo;的格式表示在string中,其他modifier都无法表示.\n下面是一些转换规则:\n 若keyboard character的值范围为0到127,则可以直接写进string 若上面的keyboard character同时按下了meta键(即2**27 到 2**27+127),则需要转换为(2**7到2**7+127) 若是大于256的非ASCII字符,可以包含进multibyte string中 其他字符(128-255范围的字符)无法用string表示.  Mouse Events Emacs支持4种鼠标事件:click event,drag event,button-down event和motion event.\n所有的鼠标事件都用list来表示,且(car list)为event type(提供了按下的是哪个鼠标按键,同时有哪个modifier key被按下了,这些信息). (cdr list)则提供了位置与时间的信息\n需要注意的是,鼠标事件是由鼠标所在buffer的keymap来处理的,而不是光标所在的buffer的keymap来处理.\n点击事件 点击事件的结果为\u0026rsquo;(EVENT-TYPE PSITIION CLICK_COUNT)\n其中:\n  EVENT-TYPE\n该symbol标识鼠标的哪个按键被点击,可选值为\u0026rsquo;mouse-1,\u0026lsquo;mouse-2,\u0026lsquo;mouse-3\n当然,也可以通过添加前缀`A-\u0026rsquo;,`C-\u0026rsquo;,`H-',`M-',`S-\u0026lsquo;和`s-\u0026lsquo;来标识点击时同时按下了哪个modifier key\n该symbol同时也作来标识event的event type\n  POSTION\nPOSTION具体的格式,根据点击的位置而不同.\n当点击在text area,mode-line,header-line或area的边界时,POSTION的格式为:\n(WINDOW POS-OR-AREA (X . Y) TIMESTAMP OBJECT TEXT-POS (COL . ROW) IMAGE (DX . DY) (WIDTH . HEIGHT)) 其中:\n  WINDOW\n表示点击的那个window\n  POS-OR-AREA\n  若点击的位置在text area内,则表示点击处的buffer postion\n否则,它的值为表示window area的symbol:\u0026lsquo;mode-line,\u0026lsquo;header-line,\u0026lsquo;vertical-line,\u0026lsquo;left-margin,\u0026lsquo;right-margin,\u0026lsquo;left-fringe,\u0026lsquo;right-fringe\n X,Y  点击的位置相对text area左上角的坐标\n TIMESTAMP  事件发生的时间\n OBJECT  若点击的位置没有string类型的text property,则为nil.\n否则为\u0026rsquo;(点击位置的带属性string . string的位置)\n TEXT-POS  对于点击在marginal area或fringe上时,该值为对应行第一个字符的buffer postion.\n其他情况下,则就是当前buffer position\n COL,ROW  点击位置相对text area左上角的行列数\n IMAGE  若点击的位置是一个IMAGE,则该值为`find-image\u0026rsquo;返回的image object\n否则为nil\n DX,DY  若OBJECT为nil,为点击的位置相对点击到的字符左上角的坐标\n否则,为点击的位置相对OBJECT左上角的坐标\n WIDTH,HEIGTH  OBJECT的宽度与高度,若OBJECT为nil,则为点击处文本的宽度与高度\n若点击的地方为scroll bar,则POSTION的格式为\n(WINDOW AREA (PORTION . WHOLE) TIMESTAMP PART 其中:\n WINDOW  点击到的scroll bar所属的window\n AREA  为\u0026rsquo;vertical-scroll-bar\n PORTION  从scrollbar的最顶端到点击位置的长度,以像素为单位\nOn some toolkits, including GTK+, Emacs cannot extract this data, so the value is always `0\u0026rsquo;.\n WHOLE  scrollbar的整个长度,以像素为单位\nOn some toolkits, including GTK+, Emacs cannot extract this data, so the value is always `0\u0026rsquo;.\n TIMESTAMP  事件发生的时间\n PART  点击在了scrollbar的哪个位置,可以为\u0026rsquo;handle,\u0026lsquo;above-handle,\u0026lsquo;below-handle,\u0026lsquo;up,\u0026lsquo;down\n  CLICK-COUNT\n快速点击的次数\n  拖拽事件 拖拽事件的格式为:\n(EVENT-TYPE (WINDOW1 START-POSITION) (WINDOW2 END-POSITION)) EVENT-TYPE以`drag-\u0026lsquo;为前缀,例如`drag-mouse-1\u0026rsquo;表示按下mouse button 1来拖动\n根据是否按下了Modifier Key,还可以在`drag-\u0026lsquo;前添加`C-\u0026rsquo;,`M-\u0026rsquo;\u0026hellip;等前缀.\nWINDOW和POSTION的值,则跟点击事件定义一样\n若`read-key-sequence\u0026rsquo;接收到一个拖拽事件,但发现并没有相应的key binding绑定到这个事件上,而相应的点击事件有binding. 则会自动将拖拽事件转换为点击事件.\nButton-Down事件 Button-Down事件的格式与Click事件格式一样,都是\n(EVENT-TYPE PSITIION CLICK_COUNT) 不同点在于EVENT-TYPE是以`down-\u0026lsquo;作为前缀的,根据是否按下Modifier key,在`down-\u0026lsquo;前还有`C-\u0026lsquo;和`M-\u0026lsquo;前缀\n`read-key-sequence\u0026rsquo;忽略任何没有command binding的buton-down event.\nRepeat Event 若快速点击同一个mouse botton而不移动mouse位置的话,则Emacs产生\u0026quot;repeat event\u0026quot;\n最常见的\u0026quot;repeat event\u0026quot;就是\u0026quot;double-click\u0026quot; event(双击事件)\n双击事件的EVENT-TYPE以`double-\u0026lsquo;为前缀,根据modifier key是否按下,可能在`double-\u0026lsquo;前添加`M-\u0026rsquo;,`S-\u0026lsquo;等前缀\n当用户执行双击时,其实产生了两个事件,第一个是普通的单击事件,第二个为双击事件. 因此在处理双击事件前单击事件的相关命令已经执行了.\n同理,若点击一次鼠标之后立即按下鼠标并拖动鼠标,则产生了`double-drag\u0026rsquo; event.\n而,在`double-click\u0026rsquo; event和`double-drag\u0026rsquo; event产生前,Emacs还会产生`double-down\u0026rsquo; event.\n总结起来,一次双击动作会产生4个事件 :down event-\u0026gt;click event-\u0026gt;double-down event-\u0026gt;double-click event.\n一次double-drag动作也会产生4个事件 :down event-\u0026gt;click event-\u0026gt;double-down event-\u0026gt;double-drag event.\n同理,还有`triple-down\u0026rsquo;,`triple-click\u0026rsquo;和`triple-drag\u0026rsquo;\nEmacs最多只产生triple-click event.\n若想知道精确的点击几次button,使用函数`event-click-count\u0026rsquo;\n  (event-click-count event)\n获取event中鼠标点击的次数\n  配置项double-click-fuzz\n定义了两次双击之间,位置不能超过的像素数\n  配置项double-click-time\n定义了两次双击之间,不超过的时间,以毫秒为单位\nnil表示直接不探测multi-click\nt表示无限时间.\n  Motion Events 在运行`trace-mouse\u0026rsquo;的body时,不按mouse botton的情况下移动mouse,会产生\u0026quot;mouse motion\u0026quot; event,它的格式为:\n\u0026#39;(mouse-movement POSITION) 这里的POSITION跟点击事件中的POSITION一样\n在trace-mouse之外的情况下,emacs不产生mouse motion event\nFocus Events 当切换frame时,会产生Focus Event. 它的格式为:\n\u0026#39;(switch-frame NEW-FRAME) 这里NEW-FRAME为新切换到的frame\n由于在一系列按键序列中间产生一个focus event会扰乱原按键序列的执行,因此Emacs不会在key sequence中间产生focus event.\n若用户在key sequence中间更改了focus,则Emacs会重新排列event,将focus event放在multi-event key sequence的最前面或最后面.\n其他System Event 若用户在key sequence中间发生了下面的那些system event,则Emacs会重新排列event,将这些system event放在multi-event key sequence的最前面或最后面.\n  \u0026lsquo;(delete-frame (FRAME))\n表示用户对FRAME发送了关闭命令\n  \u0026lsquo;(iconify-frame (FRAME))\niconify某个FRAME,默认的定义为`ignore\u0026rsquo;\n  \u0026lsquo;(make-frame-visible (FRAME))\n表示用户deiconified FRAME,默认为`ignore\u0026rsquo;\n  \u0026lsquo;(wheel-up POSITION) / \u0026lsquo;(wheel-down POSITION)\n滚动鼠标wheel时产生的event.\nPOSITION的结构跟Click Event的POSITION一样,标识了event发生时的鼠标位置\n这种event只在某些操作系统上会产生,有些操作系统上产生的是`mouse-4\u0026rsquo;和`mouse-5\u0026rsquo; event.\n因此,为了可移植性,建议使用定义在`mwheel.el\u0026rsquo;中的变量`mouse-wheel-up-event\u0026rsquo;和`mouse-wheel-down-event\u0026rsquo;来代替\n  \u0026lsquo;(drag-n-drop POSITION FILES)\n当从Emacs外选择了一些文件,并拖到Emacs frame中时产生`drag-n-drop\u0026rsquo; event\n这里POSITION的格式跟click event中的POSITION一样.\nFILES为文件名称的列表.\n  \u0026lsquo;(help-echo FRAME HELP WINDOW OBJECT POS)\n但光标移动到buffer中带有`help-echo\u0026rsquo; text property的文本时,产生该event\n  \u0026lsquo;sigusr1 / \u0026lsquo;sigusr2\n当Emacs收到信号`SIGUSR1\u0026rsquo;和`SIGUSR2\u0026rsquo;时触发该event. 一般用于调试时使用\n要捕获user signal,绑定相应的event到`special-event-map\u0026rsquo;中的命令. 这时会不带参数地执行该命令,而signal event可以通过变量`last-input-event\u0026rsquo;来获得. 例如\n(defun sigusr-handler () (interactive) (message \u0026#34;Caught signal %S\u0026#34; last-input-event)) (define-key special-event-map [sigusr1] \u0026#39;sigusr-handler)   \u0026lsquo;(language-change FRAME CODEPAGE LANGUAGE-ID)\n在MS-Windows下才更改input language会产生该event.\n这里FRAME表示改变input language时的当前frame.\nCODEPAGE为更改为的新codepage number\nLANGUAGE-ID为新input language的数字id\n例如:\n;; Get the abbreviated language name, such as \u0026#34;ENU\u0026#34; for English (w32-get-locale-info language-id) ;; Get the full English name of the language, ;; such as \u0026#34;English (United States)\u0026#34; (w32-get-locale-info language-id 4097) ;; Get the full localized name of the language (w32-get-locale-info language-id t)   特殊Events 特殊Event在非常底层的地方被处理\u0026ndash;as soon as they are read.\n`read-event\u0026rsquo;函数内部就会消化掉这些event,而不会返回这种event. 事实上,`read-event\u0026rsquo;会一直等待并返回地一个非特殊event\n特殊event不会被显示出来,不会被纳入key sequence中,不会存入`last-command-event\u0026rsquo;和`(this-command-keys)\u0026rsquo;. 特殊event They do not discard a numeric argument, they cannot be unread with `unread-command-events\u0026rsquo;, they may not appear in a keyboard macro, and they are not recorded in a keyboard macro while you are defining one.\n然而在读取到特殊event时,会记录在`last-input-event\u0026rsquo;中,and this is the way for the event\u0026rsquo;s definition to find the actual event.\n常见的特殊event type有`iconify-frame\u0026rsquo;,`make-frame-visible\u0026rsquo;,`delete-frame\u0026rsquo;,`drag-n-drop\u0026rsquo;,`language-change\u0026rsquo;以及用户信号`sigusr1\u0026rsquo;,`sigusr2\u0026rsquo;\u0026hellip;\n定义如何处理特殊event的keymap为变量`special-event-map\u0026rsquo;\n区分Events 每个event都有一个\u0026quot;event type\u0026quot;,用于区分event.\n对于keyboard event,event type就是event value\n对于list格式的event,event type为(car list)\n相同的event type运行相同的命令. 键序列与event type绑定\n (event-modifiers event)  返回一个list,包含了该event中所有的modifiers,modifier的类型为symbol, 它的值可能是\u0026rsquo;shift,\u0026lsquo;control,\u0026lsquo;meta,\u0026lsquo;alt,\u0026lsquo;hyper和\u0026rsquo;super 对于mouse event来说,还可能包括\u0026rsquo;click,\u0026lsquo;drag,\u0026lsquo;down,\u0026lsquo;double,\u0026lsquo;triple\n参数event可以是一个event对象,也可以是个event type.\nIf EVENT is a symbol that has never been used in an event that has been read as input in the current Emacs session, then `event-modifiers\u0026rsquo; can return `nil\u0026rsquo;, even when EVENT actually has modifiers.\n(event-modifiers ?a) ; =\u0026gt; nil (event-modifiers ?A) ; =\u0026gt; (shift) (event-modifiers ?\\C-a) ; =\u0026gt; (control) (event-modifiers ?\\C-%) ; =\u0026gt; (control) (event-modifiers ?\\C-\\S-a) ; =\u0026gt; (control shift) (event-modifiers \u0026#39;f5) ; =\u0026gt; nil (event-modifiers \u0026#39;s-f5) ; =\u0026gt; (super) (event-modifiers \u0026#39;M-S-f5) ; =\u0026gt; (meta shift) (event-modifiers \u0026#39;mouse-1) ; =\u0026gt; (click) (event-modifiers \u0026#39;down-mouse-1) ; =\u0026gt; (down)  (event-basic-type event)  返回去掉modifier标志之后的event描述. 例如\n(event-basic-type ?a) ; =\u0026gt; 97 (event-basic-type ?A) ; =\u0026gt; 97 (event-basic-type ?\\C-a) ; =\u0026gt; 97 (event-basic-type ?\\C-\\S-a) ; =\u0026gt; 97 (event-basic-type \u0026#39;f5) ; =\u0026gt; f5 (event-basic-type \u0026#39;s-f5) ; =\u0026gt; f5 (event-basic-type \u0026#39;M-S-f5) ; =\u0026gt; f5 (event-basic-type \u0026#39;down-mouse-1) ; =\u0026gt; mouse-1   (mouse-movement-p object)\nobject是否为mouse movent event\n  (event-convert-list list)\nThis function converts a list of modifier names and a basic event type to an event type which specifies all of them. The basic event type must be the last element of the list. 例如:\n(event-convert-list \u0026#39;(control ?a)) ; =\u0026gt; 1,C-a (event-convert-list \u0026#39;(control meta ?a)) ; =\u0026gt; -134217727 (event-convert-list \u0026#39;(control super f1)) ; =\u0026gt; C-s-f1   获取Mouse Events中的信息 要想获得mouse event中的position list,可以使用以下两个函数\n (event-start event)  若为drag event,则返回start-postion\n若为click或button-down event,则返回唯一的那个postion\n (event-end event)  若为drag event,则返回end-postion\n若为click或button-down event,则返回唯一的那个postion\n (posnp object)  判断object是否为mouse position\n下面的函数,一mouse postion list为参数,返回相应部分的值\n (posn-window postion)  返回postion list中的window\n (posn-area position)  返回position中的window area标志\n若event发生在text-area则返回nil,否则返回表示area的symbol\n (posn-point position)  返回position中的buffer位置信息.\n当event发生在text-area,marginal area或fringe上时,返回一个表示buffer位置的整数\n其他情况下,返回值意义不明确\n (posn-x-y position)  以\u0026rsquo;(X . Y)的形式返回相对(posn-window postion)的坐标,单位为像素.\n下面的例子,演示了如何将相对window的坐标转换为相对frame的坐标\n(defun frame-relative-coordinates (position) \u0026#34;Return frame-relative coordinates from POSITION. POSITION is assumed to lie in a window text area.\u0026#34; (let* ((x-y (posn-x-y position)) (window (posn-window position)) (edges (window-inside-pixel-edges window))) (cons (+ (car x-y) (car edges)) (+ (cdr x-y) (cadr edges)))))  (posn-col-row postion)  以\u0026rsquo;(COL . ROW)的格式返回buffer postion在text area中的列与行\n它是根据(postion-x-y postion)的信息与frame的默认字符的宽度和默认行的高度,计算出来的.\n需要注意的是,ROW是从text area的最顶端开始计算的,也就是说,如果(position-window positon)拥有header line,则它不会计算如ROW中\n (posn-actual-col-row postion)  以\u0026rsquo;(COL . ROW)的形式返回真正的相对(posn-window postion)的列数与行数\n (posn-string positiion)  返回position中的string object,可能为nil或\u0026rsquo;(STRING . STRING-POS)\n (posn-image position)  获得position中的image object,可能为nil或\u0026rsquo;(image\u0026hellip;)\n (posn-object position)  返回position中的string object或image object,可能为nil或\u0026rsquo;(STRING . STRING-POS)或\u0026rsquo;(image\u0026hellip;)\n (posn-object-x-y position)  获取相对POSITION list中的\u0026rsquo;(DX . DY). 即位置相对(posn-object position)的坐标. 单位为像素\n若position为buffer position,则返回相对该处字符左上角的坐标.\n (posn-object-width-height position)  以\u0026rsquo;(WIDTH. HEIGHT)格式,返回(posn-object position)的宽度和高度,单位为像素\n若position为buffer position,则返回位置处字符的宽度和高度\n (posn-timestamp position)  返回position中的timestamp信息,表示事件发生的时间戳,以毫秒为单位\n以下函数根据buffer position或screen position,计算出position list\n (posn-at-point \u0026amp;optional pos window)  该函数返回position list用于表示参数pos在参数window中的位置. 若pos在window中不可见,则返回nil\n参数pos默认为参数window中光标的位置\n参数window默认为选中的window\n (posn-at-x-y x y \u0026amp;optional frame-or-window whole)  该函数返回position list用于表示(x . y)在参数frame-or-window中的相对坐标,\n参数x,y是相对frame-or-window的以像素为单位的位置.\n参数frame-or-window,默认为当前window\n若参数为nil,则坐标是相当与window text area来计算的. 否则计算包括整个window area(text-rea+scroll bar+margin+fringe)\n获取scroll bar event中的信息  (scroll-bar-event-ratio event)  以格式\u0026rsquo;(PORTION .WHOLE)返回event在scroll-bar中的位置.\n (scroll-bar-scale ratio total)  该函数事实上将参数ratio与total相乘,并将结果约为整数.\n这里参数ration不是数字,而是格式为\u0026rsquo;(NUM . DENOM)的cons ceil. 一般该值由函数scroll-bar-event-ration返回.\n该函数用于将scroll bar position转换为buffer postion是很方便:\n(+ (point-min) (scroll-bar-scale (posn-x-y (event-start event)) (- (point-max) (point-min)))) 捕获Input Event  (read-key-sequence prompt \u0026amp;optional continue-echo dont-downcase-last switch-frame-ok command-loop)  该函数读取key sequence并以string或vector的形式返回.\n该函数会一直读取key sequence直到获取到一个完整的key sequence为止(即在当前keymap下能定位到某个command)\n需要注意的是: 以mouse event开头的key sequence,是在mouse所在的window中keymap中查找对应command的\n参数prompt为提示信息,nil表示没有提示\n参数continue-echo表示当key sequence不完整时,是否显示已经输入的key sequence\n默认情况下,任何upper case event在找不到对应command时,会转换为lower case event再去查找一遍(这是会设置变量`this-command-keys-shift-translated\u0026rsquo;为t),参数dont-downcase-last禁止这种转换\n参数swith-frame-ok表示在输入key sequence的过程中,是否能切换frame\n参数command-loop若为非nil,则表示可以一次输入多个key sequence(一个key sequence与command想对应). nil表示只读取表示一个key sequence\n`read-key-sequence\u0026rsquo;会压抑住quitting,也就是说,在输入`C-g\u0026rsquo;时,就好像其他普通的字符一样,不会去设置quit-flag\n当使用`read-key-sequence\u0026rsquo;读取mouse event时,若mouse event发生在window的非text area中,则会添加prefix-key来表示该area:\u0026lsquo;header-line,\u0026lsquo;horizontal-scroll-bar,\u0026lsquo;menu-bar,\u0026lsquo;mode-line,\u0026lsquo;vertical-line,\u0026lsquo;vertical-scroll-bar\n(read-key-sequence \u0026#34;Click on the mode line: \u0026#34;) =\u0026gt; [mode-line (mouse-1 (#\u0026lt;window 6 on NEWS\u0026gt; mode-line (40 . 63) 5959987))]  (read-key-sequence-vector prompt \u0026amp;optional continue-echo dont-downcase-last switch-frame-ok command-loop)  与`read-key-sequence\u0026rsquo;类似,只是肯定以vector类型返回\n num-input-keys  当前Emacs session目前为止处理过的key sequence的数量.\n (read-event \u0026amp;optional prompt inherit-input-method seconds)  该函数只读取一个event,而不像`read-key-sequence\u0026rsquo;一样可能读取多个event.\nThe returned event may come directly from the user, or from a keyboard macro. It is not decoded by the keyboard\u0026rsquo;s input coding system\n参数prompt为提升信息\n若参数inherit-input-method为非nil,则支持用当前输入法输入non-ASCII字符. 否则会禁用输入法\n参数seconds表示等待输入的超时秒数,若超时还未有event发生,则返回nil. 若参数seconds为nil,则Emacs在等待用户输入时被认为处于idle状态,若设置了值,则等待期间不会认为处于idle状态.\nIf `read-event\u0026rsquo; gets an event that is defined as a help character, then in some cases `read-event\u0026rsquo; processes the event directly without returning.\nCertain other events, called \u0026ldquo;special events\u0026rdquo;, are also processed directly within `read-event\u0026rsquo;\n (read-char \u0026amp;optional prompt inherit-input-method seconds)  读取并返回输入的character. 若用户产生的event不是character(例如点击事件或功能键事件),则`read-char\u0026rsquo;会抛出一个错误\n (read-char-exclusive \u0026amp;optional prompt inherit-input-method seconds)  类似`read-char\u0026rsquo;,只是当读到的event不是character时,会忽略这个event,接着读取下一个event,而不是抛出错误\n num-nonmacro-input-events  该变量存储了到目前为止从terminal读取到的input events总数(那些由keyboard macro)产生的不算.\n (read-key \u0026amp;optional prompt)  该函数读取single key. 它处于`read-key-sequence\u0026rsquo;和`read-event\u0026rsquo;之间.\n跟`read-key-sequence\u0026rsquo;不同之处在于,它读取single key而不是完整的key sequence\n跟`read-event\u0026rsquo;不同之处在于,它会根据`input-decode-map\u0026rsquo;,`local-function-key-map\u0026rsquo;和`key-translation-map\u0026rsquo;解码并转换用户的输入.\n (read-char-choice prompt chars \u0026amp;optional inhibit-quit)  该函数使用`read-key\u0026rsquo;读取并返回一个character. 它会忽略任何不是参数chars中的member的character.\nchars为一个由characters组成的list. 表示可接受的character范围.\n (read-quoted-char \u0026amp;optional prompt)  类似`read-char\u0026rsquo;,只是当读取的地一个character是一个8进制数时(0-7),它会读取接下来输入的所有8进制数,并返回由这些8进制numeric character code所表示的character.\n(read-quoted-char \u0026#34;What character\u0026#34;) ---------- Echo Area ---------- What character 1 7 7- ---------- Echo Area ---------- =\u0026gt; 127 Modifying and Translating Input Events 在使用`read-event\u0026rsquo;时,Emacs会根据`extra-keyboard-modifiers\u0026rsquo;的值对读取到到的event做改变(modify),然后根据`keyboard-translate-table\u0026rsquo;的值做转换(translate)\n extra-keyboard-modifiers  该变量允许Lisp程序模拟按下键盘上的modifier key.\n该变量的至必须为一个设置了modifier bit位的character(例如'?\\C-\\M-a'). 真正其作用的是其中的modifier bit(?\\C-\\M-).\n若变量的值为`?\\C-@',不会设置Ctrl被按下,相反, 这个值表示取消所有的modification\n另外,需要注意的是, 该变量只会修改从keyboard读取到的event,而对mouse event或其他类型的event无效\n keyboard-translate-table  该变量为terminal-local variable. 它允许你将一个keyboard event重新映射成另一个keyboard event\n一般情况下,它的值为一个char-table或nil.\nNote that this translation is the first thing that happens to a character after it is read from the terminal. Record-keeping features such as `recent-keys' and dribble files record the characters after translation.\n (keyboard-translate from to)  该函数通过修改`keyboard-translate-table\u0026rsquo;的值来达到将character code FROM转换为character code TO的目的.\nEvent Input的其他特性  unread-command-events  该变量存储的值为一个由event组成的list,表示待读取的event.\n该list中的event,以显示的顺序(即最前面的最先被使用)被读取,并且在使用后被删除\n一般情况下,从该list中读取的event不会添加到当前命令的key sequence中(即不会被`this-command-keys'),因为该event在第一次读取时已经添加过一次了. 但若list中的element格式为'(t . EVENT)则表示强制将该event放入当前command的key sequence中\n (listify-key-sequence key)  该函数将key(string或vector)转换为由单独event组成的list,可以很容易的将这个list放入`unread-command-events\u0026rsquo;中\n (input-pending-p \u0026amp;optional check-timers)  该函数检查是否有command input可以被读取了.\n若参数check-timers为非nil,则若没有input可以被读取时,运行Emacs运行已经ready的timers\n last-input-event  该变量存储最后的terminal input event. whether as part of a command or explicitly by a Lisp program.\n在下面的例子中,这段Lisp程序读取字符'1'(ASCII码为49). 假设我们用C-x C-e来执行这段代码,则会发现`last-input-event\u0026rsquo;的值为'1'(49),而`last-command-event\u0026rsquo;只为?\\C-e(5)\n(progn (print (read-char)) (print last-command-event) last-input-event) -| 49 -| 5 =\u0026gt; 49  宏(while-no-input body\u0026hellip;)  当运行body的过程中没有输入时,正常执行body并返回body的值.\n但若执行body的过程中有输入到来,则会中断body的执行(类似quit),并返回t\n若执行body的过程中,被真正的quit所打断,则返回nil\n若BODY中某部分绑定`inhibit-quit\u0026rsquo;为非nil,则即使有输入到来,也不会中断该部分代码的执行,直到该部分代码被执行完毕.\n (discard-input)  该函数丢弃terminal input buffer的内容并取消正在处理的keyboard macro,并返回nil\n例如:\n(progn (sleep-for 2) ;在等待期间,用户可能输入了一些东西 (discard-input)) ;会丢弃用户在等待期间所输入的东西 =\u0026gt; nil 关于输入法 读取event的函数会调用当前使用的输入法. 但`read-event\u0026rsquo;读取一个print character(包括\u0026lt;SPC\u0026gt;)时,会以该character作为参数,调用`input-method-function\u0026rsquo;所表示的函数\n input-method-function `read-event\u0026rsquo;读取一个print character(包括\u0026lt;SPC\u0026gt;)时,会以该character作为参数,调用`input-method-function\u0026rsquo;所表示的函数  该input-method-function的返回值应该是一系列由event组成的list. 若返回nil表示没有输入,这样`read-event\u0026rsquo;会等待下一个event产生.\n若input-method-function中又调用了`read-event\u0026rsquo;或`read-key-sequence',则需要记住把`input-method-function\u0026rsquo;的值绑定为nil,否则会发生无限递归.\nThe input method function is not called when reading the second and subsequent events of a key sequence. Thus, these characters are not subject to input method processing. The input method function should test the values of `overriding-local-map' and `overriding-terminal-local-map'; if either of these variables is non-`nil', the input method should put its argument into a list and return that list with no further processing.\nKeymaps input event与command的对应关系被记录在名为\u0026quot;keymaps\u0026quot;的结构体中. 每个event type对应一个command或另一个keymap.\n当一个event type绑定到另一个keymap时,这个keymap被用于查找下一个input event的对应关系.\n若某个event sequence找到的是一个keymap,则我们称该key sequence为\u0026quot;prefix key\u0026quot;. 否则则为\u0026quot;complete key\u0026quot;.\n这个从event sequence一直找到某个command的过程,被成为\u0026quot;key lookup\u0026quot;\nEmacs中有三类keymap:\n global map  由所有buffer所共享\n local keymap  由buffer指定的major mode所决定,会覆盖global map的key sequence\n minor mode keymaps  由buffer所开启的minor mode所决定,会覆盖global map和local keymap的key sequence\nKey Sequences \u0026ldquo;Key sequence\u0026rdquo;,简称为\u0026quot;key\u0026quot;,是指一个或多个input event做组成的序列集合. input event包括characters,function keys,mouse actions或system events\n当用vector来表示key sequences时,每个vector的元素都是character,每个character表示一个input event. 例如`[?\\C-x ?l]\u0026lsquo;表示key sequence `C-x l\u0026rsquo;\n (kbd keyseq-text)  将string类型的keyseq-text转换为key sequence.\n(kbd \u0026#34;C-x\u0026#34;) =\u0026gt; \u0026#34;\\C-x\u0026#34; (kbd \u0026#34;C-x C-f\u0026#34;) =\u0026gt; \u0026#34;\\C-x\\C-f\u0026#34; (kbd \u0026#34;C-x 4 C-f\u0026#34;) =\u0026gt; \u0026#34;\\C-x4\\C-f\u0026#34; (kbd \u0026#34;X\u0026#34;) =\u0026gt; \u0026#34;X\u0026#34; (kbd \u0026#34;RET\u0026#34;) =\u0026gt; \u0026#34;\\^M\u0026#34; (kbd \u0026#34;C-c SPC\u0026#34;) =\u0026gt; \u0026#34;\\C-c \u0026#34; (kbd \u0026#34;\u0026lt;f1\u0026gt; SPC\u0026#34;) =\u0026gt; [f1 32] (kbd \u0026#34;C-M-\u0026lt;down\u0026gt;\u0026#34;) =\u0026gt; [C-M-down] Keymaps的内部结构 keymap是一个list,它的car为\u0026rsquo;keymap. 剩下的元素可以是如下格式:\n \u0026lsquo;(EVENT-TYPE . BINDING)  该EVENT-TYPE对应着BINDING\n \u0026lsquo;(EVENT-TYPE ITEM-NAME . BINDING)  该event-type对应着binding,同时该binding也是一个名为ITEM-NAME的simple menu item\n \u0026lsquo;(EVENT-TYPE ITEM-NAME HELP-STRING . BINDING)  该event-type对应着binding,同时该bingding也是一个名为ITEM-NAME的菜单项,而带有help string\n \u0026lsquo;(EVENT-TYPE menu-item . DETAILS)  EVENT-TYPE对应着的绑定,同时也是一个extended menu item\n \u0026lsquo;([t] . BINDING)  设置BINDING为\u0026quot;default key binding\u0026quot;. 任何不能找到对应项的event-type都执行该binding\n  某char-table\n  某string\n  某parent-keymap\n  若元素为keymap,则表示该keymap所定义的绑定关系都嵌入到包含该keymap的keymap中来.\n有一点需要注意:key `M-a\u0026rsquo;在keymap中被分拆表示为`\u0026lt;ESC\u0026gt; a\u0026rsquo;(只有在meta与另一个普通字符关联时,才被分拆),而`M-\u0026lt;end\u0026gt;\u0026lsquo;直接存储为`M-\u0026lt;end\u0026gt;\u0026rsquo;\n (keymapp object)  判断object是否为keymap,若object为symbol,则判断该symbol对应的function definition是否为keymap\n(keymapp \u0026#39;(keymap)) ; =\u0026gt; t (fset \u0026#39;foo \u0026#39;(keymap)) (keymapp \u0026#39;foo) ; =\u0026gt; t (keymapp (current-global-map)) ; =\u0026gt; t 创建keymap  (make-sparse-keymap \u0026amp;optional prompt)  创建一个空的keymap\n若传递了参数prompt,则其称为keymap的overall prompt string. 你只能为menu keymap设置该值,因为任何被设了overall prompt string的keymap都被认为是menu\n (make-keymap \u0026amp;optional prompt)  类似(make-spare-keymap),但是它所创建的不是空keymap,而是包含了一个char-table,这个char-table包含了所有的不带modifier的characters\n新产生的keymap绑定所有这些characters到nil\n (copy-keymap keymap)  深拷贝keymap. However, recursive copying does not take place when the definition of a character is a symbol whose function definition is a keymap; the same symbol appears in the new copy.\n(setq map (copy-keymap (current-local-map))) =\u0026gt; (keymap ;; (This implements meta characters.) (27 keymap (83 . center-paragraph) (115 . center-line)) (9 . tab-to-tab-stop)) (eq map (current-local-map)) =\u0026gt; nil (equal map (current-local-map)) =\u0026gt; t keymap的继承 若keymap中的element为某keymap,则该被包含的keymap的内容会被内嵌到包含的keymap中,即实现了keymap的继承机制.\n我们称被包含的keymap为parent-keymap\n如果parent-keymap中的绑定关系被更改了,则这些改变也会影响到继承keymap(因为keymap中的元素为指向parent-keymap的引用). 反过来则不会影响parent-keymap,这是因为使用define-key更改的绑定是直接记录在继承的keymap中的\n (keymap-parent keymap)  获取keymap中的parent-keymap\n (set-keymap-parent keymap parent-keymap)  设置参数parent-keymap为keymap的parent keymap,若参数parent-keymap为nil,则清空keymap的所有parent keymap\n该函数返回参数parent-keymap\n若keymap本身为其他sub-keymap的parent keymap,则该操作也会影响到sub-keymap\n (make-composed-keymap maps \u0026amp;optional parent)  若希望创建一个keymap,这个keymap继承于多个keymap, 则需要使用该函数\n该函数创建一个keymap,该keymap集合了maps中的所有keymap的绑定信息. 还可以为它设置一个parent keymap\n参数maps可以是单个的keymap,或者一个由keymap组成的list.\n当Emacs在创建的这个keymap中搜索event type的绑定信息时,Emacs会按顺序搜索maps中的keymap,最后搜索parent. 以找到的第一个符合条件的绑定为准.\n需要注意的是: maps中的nil绑定会覆盖parent中的绑定信息,但是不会覆盖maps中的其他keymap的绑定信息\n(defvar help-mode-map (let ((map (make-sparse-keymap))) (set-keymap-parent map (make-composed-keymap button-buffer-map special-mode-map)) ... map) ... ) 标准Emacs prefix key keymap  esc-map  global keymap. 默认绑定到\u0026lt;ESC\u0026gt;\n help-map  global keymap. 默认绑定到C-h\n mode-specific-map  global keymap. 默认绑定到C-c\n ctl-x-map  global keymap. 默认绑定到C-x\n mule-keymap  global keymap. 默认绑定到C-x \u0026lt;RET\u0026gt;\n ctl-x-4-map  global keymap. 默认绑定到C-x 4\n ctl-x-5-map  global keymap. 默认绑定到C-x 5\n 2C-mode-map  global keymap. 默认绑定到C-x 6\n vc-prefix-map  global keymap. 默认绑定到C-x v\n goto-map  global keymap. 默认绑定到M-g\n search-map  global keymap. 默认绑定到M-s\n facemenu-keymap  global keymap. 默认绑定到M-o\n (define-prefix-command symbol \u0026amp;optioinal mapvar prompt)  该函数创建一个sparse keymap并存储在symbol的function definition中, 这样绑定到该symbol的key sequence就称为了\u0026quot;prefix key\u0026quot;\n该函数返回symbol\n该函数同时也会设置symbol的value为该keymap,但若参数mapvar为非nil,则symbol的值为mapvar\n若参数prompt为非nil,则它称为该keymap的overall prompt string. 同样的,请只有当该keymap为menu时才这么做\nActive Keymaps active keymaps按照优先级从高到底以此为:\n  由光标/鼠标点所在的string的keymap property指定的keymap\n  minor mode开启的keymap\n由变量`emulation-mode-map-alists\u0026rsquo;,`minor-mode-overriding-map-alist\u0026rsquo;和`minor-mode-map-alist\u0026rsquo;决定\n  当前buffer的local keymap\n一般由buffer的major mode决定\n  global keymap\n由变量`global-map\u0026rsquo;决定\n  除了上面的常见keymaps外,Emacs还提供了一些方法让程序员激活其他的keymaps.\n  变量`overriding-local-map\u0026rsquo;指定的keymap会替代除了globa keymap之外的其他三种常见keymap\n  `overriding-terminal-local-map\u0026rsquo;指定的keymap的优先级高过其他任何keymaps(包括`overriding-local-map\u0026rsquo;指定的keymap), 常用于临时修改keybinding(参见函数`set-transient-map\u0026rsquo;)\n  总结来说,搜索active keymap的顺序为:\n(or (if overriding-terminal-local-map (FIND-IN overriding-terminal-local-map)) (if overriding-local-map (FIND-IN overriding-local-map) (or (FIND-IN (get-char-property (point) \u0026#39;keymap)) (FIND-IN-ANY emulation-mode-map-alists) (FIND-IN-ANY minor-mode-overriding-map-alist) (FIND-IN-ANY minor-mode-map-alist) (if (get-text-property (point) \u0026#39;local-map) (FIND-IN (get-char-property (point) \u0026#39;local-map)) (FIND-IN (current-local-map))))) (FIND-IN (current-global-map))) ;; In the above pseudo-code, if a key sequence starts with a mouse event (*note Mouse Events::), that event\u0026#39;s position is used instead of point, and the event\u0026#39;s buffer is used instead of the current buffer. 下面是一些相关函数与变量:\n (current-active-maps \u0026amp;optional olp position)  当前环境下处于激活状态的keymap的list.\n正常情况下,该函数的返回值会忽略掉`overriding-local-map\u0026rsquo;和`overriding-terminal-local-map\u0026rsquo;的值,但若参数olp为非nil,则不会忽略掉这俩个变量的值.\n参数position可以是`event-start\u0026rsquo;函数返回的event position或buffer position,表示使用position所在的string的keymap property指定的keymap代替光标或鼠标点所在的stirng的keymap property\n (key-binding key \u0026amp;optional accept-defaults no-remap position)  该函数根据key在当前active 的keymaps中查找对应的binding.\n参数accept-default控制是否检查default binding,即keymap中格式为(t . binding)的元素\n当command被重映射过,key-binding默认会查找被重新映射过的binding,但若参数no-remap为非nil,则`key-binding\u0026rsquo;会忽略重映射\n参数position可以是`event-start\u0026rsquo;函数返回的event position或buffer position,表示使用position所在的string的keymap property指定的keymap代替光标或鼠标点所在的stirng的keymap property\n(key-binding \u0026#34;\\C-x\\C-f\u0026#34;) ; =\u0026gt; find-file  global-map  改变量额值为默认的global keymap\n (current-global-map)  返回当前global keymap的 引用而不是拷贝.\n (current-local-map)  该函数返回当前buffer的local keymap的 引用而不是拷贝\n (current-minor-mode-maps)  返回当前minor mode开启的keymaps的list\n (use-global-map keymap)  设置keymap为global keymap\n (use-local-map keymap)  设置keymap为当前buffer的local keymap(大多数major mode命令都使用该函数来设置local keymap)\n参数keymap可以为nil,表示不设置local keymap\n minor-mode-map-alist  该变量是一个由元素\u0026rsquo;(variable . keymap)组成的alist.\n它表示,当变量variable的值为非nil时,对应的keymap处于激活状态,否则若变量variable的值为nil,则keymap被禁用. 这里keymap可以是一个keymap或者一个function definition为keymap的symbol\n通常情况下变量variable被用于控制是否启用某个minor mode\n minor-mode-overriding-map-alist  该变量运行major mode覆盖特定minor mode的key binding.\n该alist的元素跟`minor-mode-map-alist\u0026rsquo;类似,也是(VARIABLE . KEYMAP)\n若统一变量variable,同时在`minor-mode-overriding-map-alist\u0026rsquo;和`minor-mode-map-alist\u0026rsquo;中出现,则使用`minor-mode-overriding-map-alist\u0026rsquo;中的对应keymap覆盖`minor-mode-map-alist\u0026rsquo;中的keymap\n overriding-local-map  该值若为nil,则该值所指定的keymap会覆盖除了global map外的所有keymap\n overriding-terminal-local-map  若为非nil,则该变量所表示的keymap,会优先于`overriding-local-map\u0026rsquo;,buffer的local keymap,text property或overlay keymap和其他所有的minor mode keymap\n改变了为terminal local variable,不能设置为buffer-local\n overriding-local-map-menu-flag  若该值为非nil,则表示`overriding-local-map\u0026rsquo;和`overriding-terminal-local-map\u0026rsquo;的值可以影响到menu bar的显示, 默认为nil\n需要注意的是,无论是否影响menu bar的显示,`overriding-local-map\u0026rsquo;和`overriding-terminal-local-map\u0026rsquo;依然会影响到通过menu bar产生的key sequence的执行情况\n special-event-map  存放special event与command对应关系的keymap.\n若某event type在该keymap中有binding,则该event type被认为是特殊的,并且该event所对应的绑定command会直接被函数`read-event\u0026rsquo;所执行\n emulation-mode-map-alist  This variable holds a list of keymap alists to use for emulation modes. It is intended for modes or packages using multiple minor-mode keymaps. Each element is a keymap alist which has the same format and meaning as `minor-mode-map-alist', or a symbol with a variable binding which is such an alist. The \u0026ldquo;active\u0026rdquo; keymaps in each alist are used before `minor-mode-map-alist' and `minor-mode-overriding-map-alist'.\n (set-transient-map keymap \u0026amp;optional keep-pred on-exit)  该函数临时增加keymap作为优先级最高的keymap\n正常情况下,keymap只会被使用一次,来查找紧接着的下一个key sequence的binding. 但若参数keep-pred为t则keymap一直有效,直到某个key sequence在keymap中找不到binding为止.\n 参数on-exit,若为非nil,则需要是一个不带参数的回调函数,会在map失效时调用该函数.  .\nKey Lookup 根据key sequence在指定keymap中查找binding的过程,称为\u0026quot;Key lookup\u0026quot;\nkey lookup的过程只使用key sequence中各event的event type作为查找的条件,而忽略event的其他部分. 当event为mouse event时,甚至可以使用symbol类型的mouse event type来代替list类型的整个event.\n通过key lookup找到的binding,我们称之为\u0026quot;keymap entry\u0026quot;.\n这里的BINDING可以是以下几种类型的对象\n  nil\n  command/lambda表达式\n  string/vector\n  bingding为keyboard macro\n  keymap\n  list\n  这时list的格式应该为'(other-keymap . other-event-type),表示为\u0026quot;indirect entry\u0026quot;\n即,它会在other-keymap中搜索other-event-type表示的binding\n该功能重用与为某个key创建其他key的引用.\n symbol  使用symbol的function definition\n 其他类型  上面几种类型的binding找到回,都会当成command被execute-command执行.\n但若不是上面几种类型的其他类型,则不会被当成command看待\n相关函数   (lookup-key keymap key \u0026amp;optional accept-defaults)\n返回key在keymap中的binding\n(lookup-key (current-global-map) \u0026#34;\\C-x\\C-f\u0026#34;) ; =\u0026gt; find-file (lookup-key (current-global-map) (kbd \u0026#34;C-x C-f\u0026#34;)) ; =\u0026gt; find-file (lookup-key (current-global-map) \u0026#34;\\C-x\\C-f12345\u0026#34;) ; =\u0026gt; 2 If the string or vector KEY is not a valid key sequence according to the prefix keys specified in KEYMAP, it must be \u0026ldquo;too long\u0026rdquo; and have extra events at the end that do not fit into a single key sequence. Then the value is a number, the number of events at the front of KEY that compose a complete key.\n若参数accept-defaults不为nil,则`lookup-key\u0026rsquo;在找不到key的binding是,会使用default binding\n若key为meta character+普通character则会被分拆为一个由两个character组成的sequence:`meta-prefix-char\u0026rsquo;表示的值+普通character\n(lookup-key (current-global-map) \u0026#34;\\M-f\u0026#34;) ; =\u0026gt; forward-word (lookup-key (current-global-map) \u0026#34;\\ef\u0026#34;) ; =\u0026gt; forward-word Unlike `read-key-sequence', this function does not modify the specified events in ways that discard information . In particular, it does not convert letters to lower case and it does not change drag events to clicks.\n  (undefined)\n该函数常用于keymap中用于undefine某个key.\n它调用`ding',但是不会引发error\n  (local-key-binding key \u0026amp;optional accept-default)\n该函数在当前的local keymap(由major-mode决定的)中查找key的binding\n参数accept-defaults决定了是否检查default binding\n  (global-key-binding key \u0026amp;optional accept-defaults)\n该函数在global keymap中查找key的binding\n参数accept-defaults决定了是否检查default binding\n  (minor-mode-key-binding key \u0026amp;optional accept-defaults)\n该函数返回所有active minor mode中key所对应的binding.\n返回的值为由'(MODENAME . BINDING)组成的alist\n若第一个找到的binding不是prefix definition(即binding不为keymap或function definition不为keymap的symbol),则接下来的其他minor mode中的binding都会忽略掉,因为他们都会被找到的该binding所屏蔽掉. Similarly, the list omits non-prefix bindings that follow prefix bindings.\n参数accept-defaults决定了是否检查default binding\n  配置项meta-prefix-char\n该变量为meta作为prefix时的character code,用于将代meta的character转换为一个由两个character组成的sequence. 默认为27,表示\u0026lt;ESC\u0026gt;的character code\nmeta-prefix-char ; The default value. =\u0026gt; 27 (key-binding \u0026#34;\\M-b\u0026#34;) =\u0026gt; backward-word ?\\C-x ; The print representation =\u0026gt; 24 ; of a character. (setq meta-prefix-char 24) =\u0026gt; 24 (key-binding \u0026#34;\\M-b\u0026#34;) =\u0026gt; switch-to-buffer ; Now, typing `M-b\u0026#39; is ; like typing `C-x b\u0026#39;. (setq meta-prefix-char 27) ; Avoid confusion! =\u0026gt; 27 ; Restore the default value!   Changing Key Binding  (define-key keymap key binding)  该函数设置keymap中的key的对应binding.\n若参数key为`[t]',则表示设置default binding\n (substitute-key-definition olddef newdef keymap \u0026amp;optional oldmap)  该函数扫描keymap中的所有binding为olddef的key,并rebind这些key到newdef. 该函数返回nil\n若参数oldmap为非nil,则表示 只有在oldmap中包含的key才参与替换.\n (suppress-keymap keymap \u0026amp;optional nodigits)  该函数将keymap中的所有binding为`self-insert-command\u0026rsquo;的key都重映射到`undefined\u0026rsquo;上,使得插入文本变得不可能.\n若nodigits为nil,则`suppress-keymap\u0026rsquo;重新映射数字的binding为`dgit-argument',重新映射`-\u0026lsquo;为`negative-argument\u0026rsquo;\n若nodigits为非nil,则数字和`-\u0026lsquo;都跟字符一样映射为`undefined\u0026rsquo;\n由于该函数会更改keymap的结构,因此当该keymap被其他keymap引用时,很容易产生问题,因此,一般参数keymap都为新创建的keymap\n (global-set-key key binding)  设置global keymap中key的绑定\n(global-set-key KEY BINDING) ;; == (define-key (current-global-map) KEY BINDING)  (global-unset-key key)  删除global-keymap中key的绑定\n(global-unset-key KEY) ;; == (define-key (current-global-map) KEY nil)  (local-set-key key binding)  设置local keymap中key的绑定\n(local-set-key KEY BINDING) ;; == (define-key (current-local-map) KEY BINDING)  (local-unset-key key)  取消local keymap中key的绑定\n(local-unset-key KEY) ;; == (define-key (current-local-map) KEY nil) Remapping Commands A special kind of key binding can be used to \u0026ldquo;remap\u0026rdquo; one command to another, without having to refer to the key sequence(s) bound to the original command.\nTo use this feature, make a key binding for a key sequence that starts with the dummy event `remap', followed by the command name you want to remap;\n例如,要用`my-kill-line\u0026rsquo;替代`kill-line',可以这样:\n(define-key my-mode-map [remap kill-line] \u0026#39;my-kill-line) 需要注意的是: remap只对active keymap才生效 另外, 不能对已经remap的binding再做remap. 例如\n(define-key my-mode-map [remap kill-line] \u0026#39;my-kill-line) (define-key my-mode-map [remap my-kill-line] \u0026#39;my-other-kill-line) ;不会生效 要取消remap,只需要remap到nil即可\n(define-key my-mode-map [remap kill-line] nil)  (command-remapping command \u0026amp;optional position keymap)  该命令返回当前active-keymap中被remap的command(a symbol)被remap到什么binding\n若command没有被remap,或者不是symbol类型,则该函数返回nil.\n参数position可以通过指定buffer position或mouse event position来决定当前active的keymap\n若指定了参数keymaps,则使用参数keymaps中的keymap代替但钱active keymaps. 该参数在position为非nil时被忽略\n用于转换event sequence的keymap 当`read-key-sequence\u0026rsquo;函数读取key sequence时,它使用\u0026quot;translation keymaps\u0026quot;来转换特定的event sequence为其他的event sequence.\n这些translation keymap按优先级排列分别为:`input-decode-map',`local-function-key-map\u0026rsquo;和`key-translation-map'\n当读取key sequence时,Emacs会针对其中的每个event作一次检查,若在translation keymap中发现有对应的binding,则将该event转换为绑定的event\n For example, VT100 terminals send `\u0026lt;ESC\u0026gt; O P' when the keypad key \u0026lt;PF1\u0026gt; is pressed. On such terminals, Emacs must translate that sequence of events into a single event `pf1'. This is done by \u0026ldquo;binding\u0026rdquo; `\u0026lt;ESC\u0026gt; O P' to `[pf1]' in `input-decode-map'. Thus, when you type `C-c \u0026lt;PF1\u0026gt;' on the terminal, the terminal emits the character sequence `C-c \u0026lt;ESC\u0026gt; O P', and `read-key-sequence' translates this back into `C-c \u0026lt;PF1\u0026gt;' and returns it as the vector `[?\\C-c pf1]'.\n Translation keymaps take effect only after Emacs has decoded the keyboard input (via the input coding system specified by `keyboard-coding-system').\n input-decode-map  该变量的keymap转换的是由功能键产生的key sequence(This variable holds a keymap that describes the character sequences sent by function keys on an ordinary character terminal.)\n local-function-key-map  This variable holds a keymap similar to `input-decode-map' except that it describes key sequences which should be translated to alternative interpretations that are usually preferred. It applies after `input-decode-map' and before `key-translation-map'.\n注意: 若`local-function-key-map\u0026rsquo;中的某个key与minior mode keymap,local keymap或global keymap有冲突,则该key会被忽略而不会作转换\n key-translation-map  类似`input-decode-map'. 区别在于它的优先级比较低.\n与`input-decode-map\u0026rsquo;类似,与`local-function-key-map\u0026rsquo;不同,该keymap不存在与其他普通keymap冲突就不生效的情况.\nYou can use `input-decode-map', `local-function-key-map', and `key-translation-map' for more than simple aliases, by using a function, instead of a key sequence, as the \u0026ldquo;translation\u0026rdquo; of a key. Then this function is called to compute the translation of that key.\nThe key translation function receives one argument, which is the prompt that was specified in `read-key-sequence'\u0026ndash;or `nil' if the key sequence is being read by the editor command loop. In most cases you can ignore the prompt value.\nScanning keymaps  (accessible-keymaps keymap \u0026amp;optional prefix)  该函数返回指定keymap中所有可以到达的'(key . binding)的alist\n (map-keymap function keymap)  该函数对keymap中的每个binding都调用function执行一次. function接收两个参数:event type和binding\n若keymap包含parent-keymap,该parent-keymap中的binding也被执行,这话似一个不断递归的过程.\n (where-is-internal comand \u0026amp;optional keymap firstonly noindirect no-remap)  该函数返回一个list,包含了在keymaps中绑定到command的所有key sequence.\n参数command可以任意object,该函数使用`eq\u0026rsquo;与keymap的binding进行比较\n若参数keymap为nil,则搜索范围为当前active的keymaps(不管`overriding-local-map\u0026rsquo;的值).\n若参数keymap为keymap,则搜索范围为参数keymap和global keymap\n若参数keymap为keymap组成的list,则搜索范围仅仅是指定的这些keymaps\n 命令(describe-binding \u0026amp;optional prefix buffer-or-name)  该命令列出当前key binding并显示在*Help*\n若参数prefix为非nil,则只列出以prefix为prefix key的key sequence\n默认绑定为`C-h b'\nMenu Keymaps Defining Menus 一个menu其实就是带有prompt-string的keymap. 这个prompt-string是`make-keymap',`make-sparse-keymap\u0026rsquo;和`define-prefix-command\u0026rsquo;函数的最后一个参数.\n需要注意的是,使用define-key为menu创建新绑定时,会将新绑定放在最前面,因此若关心menu项的顺序的话,要注意从最后项开始向最前项定义.\n当然也可以使用`define-key-after\u0026rsquo;来指定新绑定的位置.\n  (keymap-prompt keymap)\n获取keymap中的prompt-string\n     Simple Menu Items\n定义menu item的原始方法是绑定event type(具体是什么event type无所谓)到如下格式的list\n (ITEM-STRING . REAL-BINDING) (ITEM-STRING HELP-STRING . REAL-BINDING)  例如:\n(defvar menu-lancher-keymap (make-sparse-keymap \u0026#34;menu-lancher\u0026#34;)) (define-key menu-lancher-keymap \u0026#34;C-c C-a\u0026#34; \u0026#39;(\u0026#34;menu-item\u0026#34; \u0026#34;menu-item-help\u0026#34; (lambda () (message \u0026#34;show menu-item\u0026#34;)))) 需要注意的是, 使用lookup-key来查找键绑定时,只会返回real-binding这部分内容.\n(lookup-key menu-lancher-keymap \u0026#34;C-c C-a\u0026#34;) ;; =\u0026gt; ((lambda nil (message \u0026#34;show menu-item\u0026#34;))) 若real-binding为nil,则menu-item无法被选中.\n若real-binding为symbol,且该symbol具有非nil的menu-enable属性(该属性需为一个S-表达式),则每次显示menu都会执行该S-表达式以决定该item是否可选.\n     Extended Menu Item\n定义Extended menu item的方法是绑定event type(具体是什么event type无所谓)到如下格式的list(这些list的car都是menu-item)\n  (menu-item ITEM-NAME)\n定义不可选中的menu item.\n  (menu-item ITEM-NAME REAL-BINDING . ITEM-PROPERTY-LIST)\n定义可选中的menu item. 其中\n  ITEM-NAME为一个表达式,该表达式的运行结果必须返回一个string.\n  REAL-BINDING为要执行的command\n  ITEM-PROPERTY-LIST定义了menu item的其他信息\n   :enable FORM FORM的计算结果决定了该menu item是否有用     :visible FORM FORM的计算结果决定了是否显示该menu item   :helper HELP-STR HELP-STR为固定字符串,其指定了help-echo的显示内容   :button (TYPE . SELECTED) 该属性提供了一种定义radio button或toggle button的方式    TYPE表示button的类型,可以是:toggle或:radio    SELECTED需要为一个FORM,该FORM的计算结果决定了是否选中该button    对于toggle button来说,SELECTED的返回值决定了该button为on还是off    对于radio button来说,The SELECTED form for each radio button in the group should check whether the variable has the right value for selecting that button. Clicking on the button should set the variable so that the button you clicked on becomes selected.   :key-sequence KEY-SEQUENCE 该属性指定该menu item对应的command可能被分配到哪个键序列上.    若分配的键序列与该command实际分配的键序列相同,则能够加快menu的显示速度    若分配的键序列与实际分配的键序列不同,则无效果   :key-sequence nil 表示该menu item对应的command可能没有对应的键绑定,这使得Emacs不用去搜索对应的键序列,从而加快menu的显示速度   :keys STRING STRING被显示为触发该menu item的键序列,可以在STRING中使用\\\\[\u0026hellip;]格式   :filter FILTER-FN 该属性提供了一种动态产生menu item的途径.    FILTER-FN为一个函数,该函数接收REAL-BINDING作为唯一的参数,该函数的返回值会作为该menu item的真正READL-BINDING.             Menu Separator\n所谓menu separator是一种特殊的menu item. 它被显示为一个横线,因此被用来将menu分隔成几个部分.\nmenu separator也是一个以symbol menu-item开头的list. 它的格式如下:\n  (menu-item SEPARATOR-TYPE)\n(menu-item \u0026#34;--\u0026#34;)   (menu-item SEPARATOR-TYPE nil . ITEM-PROPERTY-LIST)\n(menu-item \u0026#34;--\u0026#34; nil :visible (boundp \u0026#39;foo))   这里SEPARATOR-TYPE为一个以\u0026quot;\u0026ndash;\u0026ldquo;开头的字符串. 它有如下几种类型\n  \u0026quot;\u0026rdquo; / \u0026ldquo;-\u0026rdquo; / \u0026ldquo;\u0026ndash;\u0026rdquo;\n默认的seprator风格\n  \u0026ldquo;\u0026ndash;no-line\u0026rdquo; / \u0026ldquo;\u0026ndash;space\u0026rdquo;\n以空格分隔\n  \u0026ldquo;\u0026ndash;single-line\u0026rdquo;\n以menu前景色着色的单行线\n  \u0026ldquo;\u0026ndash;double-line\u0026rdquo;\n以menu前景色着色的双行线\n  \u0026ldquo;\u0026ndash;single-dashed-line\u0026rdquo;\n以menu前景色着色的单行间断线\n  \u0026ldquo;\u0026ndash;double-dashed-line\u0026rdquo;\n以menu前景色着色的双行间断线\n  \u0026ldquo;\u0026ndash;shadow-etched-in\u0026rdquo;\n3D的凹入线\n  \u0026ldquo;\u0026ndash;shadow-etched-out\u0026rdquo;\n3D的凸出线\n  \u0026ldquo;\u0026ndash;shadow-etched-in-dash\u0026rdquo;\n3D的凹入间断线\n  \u0026ldquo;\u0026ndash;shadow-etched-out-dash\u0026rdquo;\n3D的凸出间断线\n  \u0026ldquo;\u0026ndash;shadow-double-etched-in\u0026rdquo;\n3D的凹入双行线\n  \u0026ldquo;\u0026ndash;shadow-double-etched-out\u0026rdquo;\n3D的凸出双行线\n  \u0026ldquo;\u0026ndash;shadow-double-etched-in-dash\u0026rdquo;\n3D的凹入双行间断线\n  \u0026ldquo;\u0026ndash;shadow-double-etched-out-dash\u0026rdquo;\n3D的凸出双行间断线\n    Menu and the Mouse 若一个menu keymap是由鼠标事件触发的,则会弹出一个menu,使得用户可以通过鼠标来选择菜单项.\nthe event generated is whatever character or symbol has the binding that brought about that menu item.\n比较常见的方式是使用button-down事件来触发menu,这样一释放鼠标就能触发menu item了\n一般情况下,若menu keymap的binding中有另一个keymap,则该keymap被认为是submenu. 但若被包含的keymap中无其他menu item,则会直接显示该keymap的内容,而不是作为submenu\nHowever, if Emacs is compiled without X toolkit support, or on text terminals, submenus are not supported. Each nested keymap is shown as a menu item, but clicking on it does not automatically pop up the submenu. If you wish to imitate the effect of submenus, you can do that by giving a nested keymap an item string which starts with ‘@’. This causes Emacs to display the nested keymap using a separate \u0026ldquo;menu pane\u0026rdquo;; the rest of the item string after the ‘@’ is the pane label. If Emacs is compiled without X toolkit support, or if a menu is displayed on a text terminal, menu panes are not used; in that case, a ‘@’ at the beginning of an item string is omitted when the menu label is displayed, and has no other effect.\nMenus and the Keyboard 若menu是由键盘事件触发的,则我们称这种menu为keyboard menu.\nEmacs使用文本的方式,在echo area中显示菜单. 若在一次无法显示完整的菜单,可以通过按\u0026lt;SPC\u0026gt;(由变量`menu-prompt-more-char\u0026rsquo;决定)来显示下一屏菜单.\nThe Menu Bar 要添加item到menu bar上,需要先创建自己的\u0026quot;function key\u0026quot;(例如KEY),然后为 [menu-bar KEY] 这样一个键序列添加绑定.\n若为同一个 [menu-bar KEY] 绑定了多个不同的menu item,则只会创建一个menu,但包含了多个menu item的内容.\n下面是一个例子:\n;; Make a menu keymap (with a prompt string) ;; and make it the menu bar item’s definition. (define-key global-map [menu-bar words] (cons \u0026#34;Words\u0026#34; (make-sparse-keymap \u0026#34;Words\u0026#34;))) ;; Define specific subcommands in this menu. (define-key global-map [menu-bar words forward] \u0026#39;(\u0026#34;Forward word\u0026#34; . forward-word)) (define-key global-map [menu-bar words backward] \u0026#39;(\u0026#34;Backward word\u0026#34; . backward-word)) local keymap可以取消global keymap创建的menu bar item. 方法是重新绑定该item的key为\u0026rsquo;undefined. 例如:\n(define-key dired-mode-map [menu-bar edit] \u0026#39;undefined)   menu-bar-final-items\n默认情况下,menu bar先显示global-map中定义的menu item,再显示local-map中定义的menu item.\n而该变量中包含着的多个item对应的fake function key. 这些item会显示在menubar的最后面.\n  menu-bar-update-hook\n在重新刷新menu bar之前会触发该hook.\n  Tool bars Tool-bar的定义与menu-bar的定义及其类似,只是fake \u0026ldquo;function key\u0026quot;由\u0026quot;menu-bar\u0026quot;变为了\u0026quot;tool-bar\u0026rdquo;. 例如:\n(define-key global-map [tool-bar KEY] ITEM) 同样,也可以通过为major mode的local map添加`[tool-bar FOO]\u0026lsquo;绑定来设置特定major-mode的tool-bar\n你还可以为Modifier-key(shift,control,meta\u0026hellip;)+鼠标点击定义不同的意义. 例如:\n;; if the original item was defined this way, (define-key global-map [tool-bar shell] \u0026#39;(menu-item \u0026#34;Shell\u0026#34; shell :image (image :type xpm :file \u0026#34;shell.xpm\u0026#34;))) ;; here is how you can define clicking on the same tool bar image with the shift modifier: (define-key global-map [tool-bar S-shell] \u0026#39;some-command) 但是ITEM中的REAL-BINDING必须是一个command,而不能是keymap\nITEM中除了能使用一般的extended menu item中的属性外,还能使用`:image\u0026rsquo;属性来指定显示的图标.\n  `:image IMAGE\u0026rsquo;\n这里IMAGE可以是一个image对象,或一个由4个image对象组成的vector.\n若IMAGE是一个由4个image对象组成的vector,则在不同的条件下会展示不同的image对象:\n   item 0 Used when the item is enabled and selected.     item 1 Used when the item is enabled and deselected.   item 2 Used when the item is disabled and selected.   item 3 Used when the item is disabled and deselected.    若IMAGE为单个的image对象,则当该menu item disable时,Emacs自动使用edge-detection算法修改image的显示\n  `:rtl IMAGE'\n表示当使用right-to-left语言时,显示的图像内容.\n  相关函数与变量\n  tool-bar-map\n默认情况下,`[tool-bar]\u0026lsquo;的定义是通过如下代码实现的:\n(global-set-key [tool-bar] `(menu-item ,(purecopy \u0026#34;tool bar\u0026#34;) ignore :filter tool-bar-make-keymap)) 这里函数`tool-bar-make-keymap\u0026rsquo;会从变量`tool-bar-map\u0026rsquo;中动态派生出实际的tool-bar map. 因此可以通过修改该变量的值来修改默认的global tool-bar. 在某些Major mode中(例如Info mode)是通过将`tool-bar-map\u0026rsquo;设为buffer-local,再设置该值的方式来代替global tool bar的.\n  (tool-bar-add-item icon def key \u0026amp;rest props)\n通过修改`tool-bar-map\u0026rsquo;的方式,添加item到tool bar中. 其中\nICON为XPM,XBM或PBM文件的 base name. 例如若ICON为\u0026quot;exit\u0026quot;,则emacs会依次查找exit.xpm,exit.pbm和exit.xbm\nDEF为实际调用的命令\nKEY为the fake function key symbol in the prefix keymap.\nPROPS则为tool bar menu item的其他属性.\nTo define items in some local map, bind ‘tool-bar-map’ with ‘let’ around calls of this function:\n(defvar foo-tool-bar-map (let ((tool-bar-map (make-sparse-keymap))) (tool-bar-add-item …) … tool-bar-map))   (tool-bar-add-item-from-menu command icon \u0026amp;optional map \u0026amp;rest props)\n用该函数可以将menu bar中的绑定添加到tool bar中来.\n各参数说明与tool-bar-add-item icon类似.\nThe binding of COMMAND is looked up in the menu bar in MAP (default ‘global-map’)\nMAP must contain an appropriate keymap bound to ‘[menu-bar]’.\n该函数会修改`tool-bar-map\u0026rsquo;,因此最好只在修改global tool bar item时才使用该函数\n  (tool-bar-local-item-from-menu command icon in-map \u0026amp;optional from-map \u0026amp;rest prop)\n该函数可以用来创建非全局的tool bar items.\n使用方式类似`tool-baar-add-item-from-menu',只是多了个IN-MAP参数用来指明新加的tool bar item放在哪个keymap中.\n  auto-resize-tool-bars\n若该变量值为非nil,则tool bar会自动改变大小以便在一个frame中能显示出所有的tool bar item\n若变量值为\u0026rsquo;grow-only,则tool bar只自动增大,而不自动缩小. 要想缩小tool bar,必须用户手工输入`C-l'\n  auto-raise-tool-bar-buttons\n若该变量为非nil,则当鼠标移到item上时,该item会凸起\n  tool-bar-button-margin\n指定了tool bar item的extra margin. 单位为像素\n  tool-bar-button-relief\n该变量值指定了tool bar item的阴影宽度,单位为像素\n  tool-bar-border\nThis variable specifies the height of the border drawn below the tool bar area. An integer specifies height as a number of pixels.\nIf the value is one of ‘internal-border-width’ (the default) or ‘border-width’, the tool bar border height corresponds to the corresponding frame parameter.\n  Modifying Menus 当使用`define-key\u0026rsquo;往menu中添加item时,会把新加的item放到menu的第一项的位置.\n若想指定新加item的位置,需要使用`define-key-after'\n  (define-key-after map key binding \u0026amp;optional after)\n与`define-key\u0026rsquo;类似,在MAP中将KEY绑定到BINDING. 但是位置由AFTER决定.\nThe argument KEY should be of length one—a vector or string with just one element.\nBut AFTER should be a single event type—a symbol or a character, not a sequence.\n先加入的item位置在AFTER之后,若AFTER为t或nil,则表示新item会放在最后的位置.\n下面是一些例子\n;; makes a binding for the fake function key \u0026lt;DRINK\u0026gt; and puts it right after the binding for \u0026lt;EAT\u0026gt;. (define-key-after my-menu [drink] \u0026#39;(\u0026#34;Drink\u0026#34; . drink-command) \u0026#39;eat) ;; Here is how to insert an item called ‘Work’ in the ‘Signals’ menu ;; of Shell mode, after the item ‘break’: (define-key-after (lookup-key shell-mode-map [menu-bar signals]) [work] \u0026#39;(\u0026#34;Work\u0026#34; . work-command) \u0026#39;break)   Easy Menu 使用宏`easy-menu-define symbol maps doc menu\u0026rsquo;可以很容易的定义pop-up-menu / menu-bar-menu\n  (easy-menu-define symbol maps doc menu)\n该宏定义一个pop-up-menu / menu-bar-menu,其内容由MENU决定.\n若参数SYMBOL非空,则会生成一个名为SYMBOL的函数,该函数用来弹出该menu. 且该函数使用DOC作为其的doc-string.\n参数SYMBOL不需要被引用.\nMAPS可以为一个keymap,也可以为一个由keymap组成的list.\n if MAPS is a keymap, the menu is added to that keymap, as a top-level menu for the menu bar It can also be a list of keymaps, in which case the menu is added separately to each of those keymaps.  MENU参数的第一个元素必须为字符串,该字符串被作为menu label.\nMENU参数中紧跟着的是以下的键值对的任意组合:\n  :filter FUNCTION\nFUNCTION会接收唯一的一个函数:其他menu item组成的列表. 其返回值作为menu中显示的真实item\n  :visible VISIBLE-FORM\nVISIBLE-FORM的执行结果决定了该item是否可见\n  :active ENABLE-FORM\nENABLE-FORM的执行结果决定了该item是否可选.\n  参数MENU可以是如下几种形式:\n  [NAME CALLBACK ENABLE]\nNAME为一个字符串,表示menu item的名字\nCALLBACK为点击该item时要运行的命令或S-表达式\nENABLE为一个S-表达式,其执行结果决定了该item是否可用.\n  [MENU CALLBACK [KEYWORD ARG]\u0026hellip;]\n这里KEYWORD与ARG对必须是如下几种:\n  :keys KEYS\nKEYS为与menu item等价的keyboard键序列,它需为字符串格式\n  :key-sequence KEYS\n该KEYS用来加速Emacs第一次显示menu.\n若你知道该menu item没有对应的keyboard键序列,则KEYS应该设成nil,否则它应该是表示该键序列的string或vector\n  :active ENABLE\nENABLE为一个S表达式,其计算结果决定了该item是否可用\n  :visible INCLUDE\nINCLUDE为一个S表达式,其计算结果决定了该item是否可见\n  :label FORM\nFORM是一个S表达式,其计算结果作为该menu item的标签(默认为参数NAME)\n  :suffix FORM\nFORM是一个S表达式,其计算结果会作为后缀自动加到menu item标签后\n  :style STYLE\nSTYLE为一个symbol,它决定了该item的类型.\n它可以是以下几个值:\n   \u0026lsquo;toggle checkbox     \u0026lsquo;radio radio button   其他 ordinary menu item      :selected SELECTED\nSELECTED为一个S表达式,其计算结果决定了该checkbox item或radio button item是否被选中\n  :help HELP\nHELP为一个字符串,描述了menu item\n    menu-string\nMENU也可以是一个字符串,则该字符串在menu中显示为一段不可用的文本.\n若字符串以`-\u0026lsquo;开头,则解释为menu-separator\n  (MENU1 MENU2 \u0026hellip;)\nMENU还可以使上述MENU格式组成的list,则表示为submenu\n    下面是一个例子:\n(easy-menu-define words-menu global-map \u0026#34;Menu for word navigation commands.\u0026#34; \u0026#39;(\u0026#34;Words\u0026#34; [\u0026#34;Forward word\u0026#34; forward-word] [\u0026#34;Backward word\u0026#34; backward-word])) Major Mode and Minor Mode Hooks Emacs中大多数的hook为\u0026quot;normal hooks\u0026quot;,这表示该hook中的函数会被不带参数调用,且他们的返回值会被忽略. 以`-hook\u0026rsquo;结尾的hook都是\u0026quot;normal hook\u0026quot;.\n非`-hook\u0026rsquo;结尾的hook可能为\u0026quot;abnormal hook\u0026quot;,这表示该hook中的函数会被带参数调用,或者他们的返回值会被使用. 一般这种`abormal hook\u0026rsquo;的名称是以`-functions\u0026rsquo;结尾的.\n以`-function\u0026rsquo;结尾的hook表示它的值为单个的函数,而不是函数列表,此时 不能用`add-hook\u0026rsquo;来添加hook函数,而需要使用`add-function\u0026rsquo;代替\nhook触发式,排在前面的hook函数优先被调用\n调用Hook中的函数   (run-hooks \u0026amp;rest hookvars) 该函数依次调用hookvars中的hook函数. 每个hookvar都是一个 符号. 且每个hook都需为一个\u0026quot;normal hook\u0026quot;\n若hookvar为buffer-local变量,则调用的hook函数以hookvar的buffer-local的值为准,但 若此时hook值中有元素t,则表示全局的hook值中定义的函数也会被调用\n  (run-hook-with-args hook \u0026amp;rest args) 该函数以参数args调用hook中的函数,此时hook为\u0026quot;abnormal hook\u0026quot;\n  (run-hook-with-args-until-failure hook \u0026amp;rest args) 以参数args依次调用abnormal hook中的函数,直到某个函数返回nil为止\n该函数返回最后那次调用函数的返回值. 即若由于hook中某个函数返回nil而退出时也返回nil,否则返回非nil值\n  (run-hook-with-args-until-success hook \u0026amp;rest args) 以参数args依次调用abnormal hook中的函数,直到某个函数返回非nil为止\n该函数返回最后那次调用函数的返回值. 即若由于hook中某个函数返回非nil而退出时则返回该值,否则返回nil值\n  设置Hook变量   (add-hook hook function \u0026amp;optional append local) 为hook添加function为hook函数\n若function已经存在(使用equal进行比较),则不再重复添加\n若function的`permanent-local-hook\u0026rsquo;属性非nil,则 `kill-all-local-variables\u0026rsquo;或更改major mode都不会将该函数从hook的当前值中被删除\n默认情况下,function会被放在hook的最前方优先调用,但`append\u0026rsquo;参数可以让function添加到hook的最后方,最后被调用\n参数`local\u0026rsquo;表示将function加入buffer-local hook中,该标志会使hook变为buffer-local变量,并在buffer-local变量值中添加元素`t\u0026rsquo;(表示同时也执行该hook的global value)\n  (remove-hook hook function \u0026amp;optional local) 该函数从hook中移除function\n若参数`local\u0026rsquo;为非nil,则表示将该hook变为buffer-local hook,然后移除function\n  Major Modes 每个Major Mode都需要有一个\u0026quot;mode hook\u0026quot;. Major Mode在完成初始化过程的最后一个步骤都应该是调用\u0026quot;mode hook\u0026quot;\n每个Major Mode都需要一个以`-mode\u0026rsquo;结尾的命令用来进入该Major Mode\n  命令(fundamental-mode) fundamental-mode不包含任意的与该mode相关的函数定义和变量设置. 它 甚至没有mode hook\n  配置项major-mode 该变量为buffer-local变量,其值为一个symbol,标识了当前处于哪个major mode. 其标准的默认值为`fundamental-mode\u0026rsquo;\n若默认值为nil,则当Emacs使用命令(例如`switch-to-buffer\u0026rsquo;)创建新buffer(??是创建吗??)时, 新buffer的major mode与之前buffer保持不变 但是作为一个特例,若前一个buffer的major-mode的`mode-class\u0026rsquo;属性为`special',则 新buffer的Major Mode为Fundamental mode (具体参见Major Mode Conventions)\n  Major Mode Conventions 定义Major Mode时,有很多惯例需要遵守,因此推荐使用`define-derived-mode\u0026rsquo;从一个现成的Major Mode中继承新Major Mode. 该宏会自动维护这些惯例.\n下面是一些常见的惯例\n  进入Major Mode的命令以`-mode\u0026rsquo;结尾\n且当不带参数调用时,该命令通过设置 keymap,syntax table和buffer-local变量 将当前buffer切换到新的Major Mode.\n该命令不能修改buffer的内容\n  为进入Major Mode的命令添写doc-string,简要描述一下该mode有哪些特殊命令\ndoc-string中可以使用`\\[COMMAND]',`\\[KEYMAP]\u0026lsquo;和`\\\u0026lt;KEYMAP\u0026gt;\u0026lsquo;来自动显示用户自定义的键绑定.\n  进入Major Mode的命令的第一个动作应该是调用`kill-all-local-variables\u0026rsquo;\n`kill-all-local-variables\u0026rsquo;会先触发`change-major-mode-hook\u0026rsquo;,然后清理之前的Major Mode设置的buffer-local变量\n  Major Mode Command需要设置buffer-local变量`major-mode\u0026rsquo;的值为major mode command的symbol.\n命令`describe-mode\u0026rsquo;会根据该变量输出帮助文档\n  Major Mode Command需要设置buffer-local变量`major-name\u0026rsquo;的值为该major mode的\u0026quot;pretty\u0026quot; name.\n`major-name\u0026rsquo;通常为一个字符串,且它的值用来会显示在mode line上\n  由于Emacs只有一个命名空间,因此所有与Major Mode相关的变量,常量和函数,应该以该major mode名称为前缀\n  当Major Mode是用来编辑特定结构的文本或编程语言时,具备根据结构自动缩进文本是很有用的一项功能,因此这类major mode一般都会有缩进函数,并将其设置为变量`indent-line-function\u0026rsquo;的值. 同时也可能设置其他一些关于缩进的变量的值\n  Major Mode通常有其自己的keymap,该keymap的名字一般为`mode名称-mode-map'\nMajor Mode Command应该调用`use-local-map\u0026rsquo;函数来安装自己的keymap\n  Major Mode Keymap中的键绑定,一般以`C-c'+控制字符或数字或`{}\u0026lt;\u0026gt;:;\u0026lsquo;为前缀.\n`C-c\u0026rsquo;+标点符号是留给minor mode使用的.\n`C-c'+普通字母留给用户使用的\nmajor mode也可以重新绑定`M-n',`M-p\u0026rsquo;但应该表示某种向前向后移动的命令\n  编辑文本的major mode不应该重定义\u0026lt;RET\u0026gt;为任何非换行的命令.\n非编辑文本的major mode无此显示\n  Major mode不应该修改哪些会严重影响用户性能的配置项(例如是否开启Auto-Fill mode)\n  若major mode有自己的syntax table,则该syntax table变量的名称规范为`mode名称-mode-syntax-table'\n  若major mode希望支持某种编程语言的注释语法,则需要设置与注释语法相关的变量.\n具体参见`comment-column',`comment-start-skip',`comment-start',`comment-end'\n  若major mode有自己的缩写表,则需要存放到名为`MODENAME-mode-abbrev-table\u0026rsquo;的变量中.\nIf the major mode command defines any abbrevs itself, it should pass ‘t’for the SYSTEM-FLAG argument to ‘define-abbrev’. 详情参见Defining Abbrevs\n  major mode通过设置buffer-local变量`font-lock-defaults\u0026rsquo;来设置高亮\n  major mode中用到的每个face都应该尽可能的从已有的Emacs face中继承\n  major mode应该告诉Imenu如何找出buffer中的各个定义和章节的位置.\n方法是通过设置`imeu-generic-expression',`imenu-prev-index-position-function',`imenu-extract-index-name-function',`imenu-create-index-function'. 具体参见Imenu\n  major mode可以定义buffer local变量`eldoc-documentation-function\u0026rsquo;以便eldoc能支持该mode\n  major mode可以通过设置`completion-at-point-functions\u0026rsquo;来指定如何实现补全. 具体参见Completion in Buffers\n  在major mode command中使用`make-local-variable\u0026rsquo;来创建buffer-local变量.\n不要使用`make-variable-buffer-local\u0026rsquo;来创建buffer local变量 ,因为该函数会是的即使不是该mode的buffer中的变量也变成buffer-local变量.\n  每个major mode都应该有一个名为`MODENAME-mode-hook\u0026rsquo;的normal hook.\nmajor mode command的最后步骤应该是 使用`run-mode-hooks\u0026rsquo;依次调用`change-major-mode-after-body-hook',`MODENAME-mode-hook\u0026rsquo;和`after-change-major-mode-hook\u0026rsquo;这三个hook\n  若major mode为子mode,则在major mode command开始时还需要调用父mode的major mode command\n通过宏`define-derived-mode\u0026rsquo;定义的mode会自动完成这种设计,但若没有使用`define-derived-mode\u0026rsquo;宏,则需要手工调用`delay-mode-hooks\u0026rsquo;中的父mode command\n  若从major mode切换成其他major mode,则会触发`change-major-mode-hook',可以进行一些特殊处理\n  若该major mode仅用来管理由major mode自己产生的文本(而不是用户输入的内容),则该major command symbol的`mode-class\u0026rsquo;属性应该为`special',像下面所示:\n(put \u0026#39;funny-mode \u0026#39;mode-class \u0026#39;special) 默认情况下,若`major-mode\u0026rsquo;的默认值为`nil',则新创建的buffer会继承当前buffer的major mode. 但对于属性`mode-class\u0026rsquo;为`special\u0026rsquo;的major mode来说, 新创建的buffer使用Fundamental Mode代替,像Dired,Rmail,Buffer List这些Major Mode都开启了该特性\n同时,在这些special major mode中调用`view-buffer\u0026rsquo;函数并不能启用`view-mode' minor mode,因为这类的mode通常都提供了他们自己的类似view-mode的键绑定\n这类major mode,推荐使用`define-derived-mode\u0026rsquo;直接从`special-mode\u0026rsquo;中继承\n  通过配置`auto-mode-alist\u0026rsquo;变量,可以让Emacs打开特定规则的文件名时自动选中Major Mode.\nIf you define the mode command to autoload, you should add this element in the same file that calls ‘autoload’.\nIf you use an autoload cookie for the mode command, you can also use an autoload cookie for the form that adds the element (参见autoload cookie)\n  定义mode的代码可能会被重复执行\n因此在定义与mode相关的变量时,推荐使用`defvar\u0026rsquo;和`defcustom'\n  How Emacs Chooses a Major Mode 当Emacs打开文件时,会自动根据文件名称和文件内容选择合适的major mode\n  命令(normal-mode \u0026amp;optional find-file)\n让Emacs为当前buffer选择合适的major-mode\n该函数先调用`set-auto-mode\u0026rsquo;函数,然后运行`hack-local-variables\u0026rsquo;来使file local变量生效. 参见Local Variables in Files 和File Local Variables\n若参数`find-file\u0026rsquo;为非nil,则normal-mode假设是被`find-file\u0026rsquo;函数调用的,这种情况下,它会根据`enable-local-variables\u0026rsquo;的值来决定是否应用file local变量的值.\n若参数`find-file\u0026rsquo;为nil,则无条件应用file local变量值\n该函数内部调用`set-auto-mode\u0026rsquo;来选择major mode,若选择失败,则根据`major-mode\u0026rsquo;的默认值来决定应用major mode\n  函数(set-auto-mode \u0026amp;optional keep-mode-if-same)\n该函数为当前buffer选择合适的major-mode,其选择的依据依次为\n  根据`_*_\u0026lsquo;行或文件结尾处的`mode:\u0026rsquo; file local变量值.\n注意: 若`enable-local-variables\u0026rsquo;为nil,或文件名称匹配`inhibit-local-variables-regexps\u0026rsquo;中的元素,则Emacs不使用file local变量\n  根据`interpreter-mode-alist\u0026rsquo;变量值和`#!\u0026lsquo;行推测\n  根据`magic-mode-alist\u0026rsquo;变量值和buffer开头的内容推测\n  根据`auto-mode-alist\u0026rsquo;变量值和文件名称推测\n  若参数keep-mode-if-same为非nil,则若该buffer已经处于合适的mode状态时,并不再此调用major mode coomand. 这样是为了防止用户自定义的buffer loal 变量值被重设\n  (set-buffer-major-mode buffer) 设置指定buffer的major mode为`major-mode\u0026rsquo;的默认值.\n若默认值为nil,则表示使用当前buffer的major mode.\n作为特例,`*scratch\u0026rsquo; buffer的值会被设置为`initial-major-mode'\n低层的原始创建buffer的函数不会调用该函数,但中层的创建buffer的函数(例如`switch-to-buffer\u0026rsquo;和`find-file-noselect')在创建buffer时会使用该函数\n  配置项initial-major-mode\n该值决定了初始的`*scratch*' buffer的major mode. 该变量的值应该为major mode command的symbol\n  变量interpreter-mode-alist\n该变量告诉Emacs如何根据`#!\u0026lsquo;行的内容判断major mode\n它一个alist,其元素格式为`(REGEXP . MODE)\u0026rsquo; 表示`#!\u0026lsquo;行内容匹配REGEXP的其Major Mode为MODE\n  变量majic-mode-alist\n该变量告诉Emacs如何根据buffer内容判断major mode\n该值为一个alist,其元素格式为`(REGEXP . FUNCTION)\u0026rsquo;, 若buffer开头部分的内容匹配REGEXP,且FUNCTION为非nil,则Emacs会通过调用该FUNCTION切换Major Mode\n若FUNCTION为nil,则通过变量`auto-mode-alist\u0026rsquo;判断Major Mode\n  变量`majic-fallback-mode-alist' 该变量类似`magic-mode-alist',但 只有在`auto-mode-alist\u0026rsquo;中没有相应配置时才生效\n  变量`auto-mode-alist' 该变量告诉Emacs如何根据文件名称判断major mode\n该值为一个alist,其元素格式 一般 为`(REGEXP . MODE-FUNCTOIN)\u0026lsquo;表示文件名称匹配REGEXP的话,调用MODE-FUNCTION来选择Major Mode(若访问的文件是扩展过的文件名 ,则文件名会先经过`file-name-sans-versions\u0026rsquo;过滤掉版本号或备份标志)\n元素还可能为格式`(REGEXP FUNCTION t)',表示调用FUNCTION后,Emacs继续搜索`auto_mode-alist\u0026rsquo;并选择合适的Major Mode. 该功能在处理压缩的文件时特别有用.\n  Mode Help   命令(describe-mode \u0026amp;optional buffer)\n该命令显示指定buffer(默认为当前buffer)的major mode和minior mode的相关文档.\n该函数使用`documentation\u0026rsquo;函数从major mode command和minior mode command中获取doc-string\n  Derived Modes 创建一个新的major mode的推荐方法是使用`define-derived-mode\u0026rsquo;从一个现有的major mode中继承出来.\n即使没有接近的major mode,那也应该从`text-mode\u0026rsquo;,`special-mode\u0026rsquo;或`prog-mode\u0026rsquo;这三大基本major mode中选一个来继承.\n实在不行,那就从`fundamental-mode\u0026rsquo;中继承\n  宏(define-derived-mode VARIANT PARENT NAME DOCSTRING KEYWORD-ARGS\u0026hellip; BODY\u0026hellip;)\n该宏定义VARIANT为新Major Mode Command,该Major Mode,继承自PARENT,且以NAME为Mode Name\n参数VARIANT和PARENT为不被引用的symbol\n新的Major Mode覆盖了PARENT Mode的以下几个方面:\n  新Major Mode拥有自己的keymap,名为`VARIANT-map'. 除非`VARIANT-map\u0026rsquo;在调用`define-derived-mode\u0026rsquo;前已经被设置并且定义了父keymap,否则PARENT mode的keymap为`VARIANT-map\u0026rsquo;的父keymap\n  新Major Mode拥有自己的syntax table,名为`VARIANT-syntax-table',但该名字可以通过`:syntax-table' keyword关键字修改 除非`VARIANT-syntax-table在调用`define-derived-mode\u0026rsquo;前已经被设置并且定义了父syntax-table,否则PARENT mode的syntax-table为`VARIANT-syntax-table的父syntax-table\n  新Major Mode拥有自己的abbrev table,存在名为`VARIANT-abbrev-table\u0026rsquo;的变量中,但该变量名可以通过`:abbrev-table' keyword关键字修改\n  新Major Mode有自己的mode hook,名为`VARIANT-hook'. 该hook会在运行完其祖先的mode hook后,通过`run-mode-hooks\u0026rsquo;调用\n  可以在参数BODY指定了如何覆盖PARENT mode的其他设置. 注意不要加`interactive\u0026rsquo;语句,`define-derived-mode\u0026rsquo;会自动添加该语句\n若PARENT有一个非nil的`mode-class\u0026rsquo;属性,则`define-derived-mode\u0026rsquo;会设置VARIANT的`mode-class\u0026rsquo;属性为相同的值.\n参数PARENT也可以为nil,表示新Major Mode没有父mode\n参数DOCSTRING为对新Major Mode的说明,`define-derived-mode\u0026rsquo;会在此基础上增添一些关于mode hook,mode keymap的信息,该参数可以省略\n`define-drived-mode\u0026rsquo;支持以下几种KEYWORD-ARG\n  `:syntax-table'\n为新Major Mode指定syntax table变量.\n若参数为nil,则表示使用PARENT mode的syntax table变量,若参数PARENT为nil,则使用标准syntax-table\n  `:abbrev-table'\n为新Major Mode指定abbrev-table变量.\n若参数为nil,表示使用PARENT mode的abbrev-table变量,若参数PARENT为nil,则使用`fundamental-mode-abbrev-table'\n  `:group'\n指定了该mode所属的customization group.\n    函数(derived-mode-p \u0026amp;rest modes)\n当前Major Mode是否继承自modes中的任意一个mode, modes为symbol列表\n  Basic Major Modes 除了Fundamental mode外,还有三个普遍被继承的mode:Text mode,Prog mode和Special mode\n  命令(text-mode)\nText-mode用于编辑自然语言.\nIt defines the ‘\u0026quot;’ and ‘\\’ characters as having punctuation syntax (参见 Syntax Class Table)\n该mode下绑定`M-\u0026lt;TAB\u0026gt;\u0026lsquo;为`ispell-complete-word\u0026rsquo;\n  Prog-mode\nProg-mode用于编辑编程语言. 大u偶数的编程语言major mode都继承自该mode\nProg-mode设置`parse-sexp-ignore-comments\u0026rsquo;为`t',设置`bidi-paragraph-direction\u0026rsquo;为`left-to-right'\n  Special-mode\nSpecial-mode常用于那些内容由Emacs自动产生(而不是人工输入或从文件读取)的buffer中.\n从Special mode继承的mode会设置`mode-class\u0026rsquo;属性为`special'\nSpecial mode设置mode为只读的.且会重新绑定很多通用绑定,例如`q\u0026rsquo;绑定为`quit-window',`g\u0026rsquo;绑定为`revert-buffer'\n  Mode Hooks 每个Major Mode Command最后三条指令应该是调用`change-major-mode-after-body-hook',自己的`MODE-hook',和`after-change-major-mode-hook'. 通常是通过调用函数`run-mode-hooks\u0026rsquo;来自动完成上面的三个步骤.\n当major mode为某个父mode的子mode,则在body中调用父mode command时,应该放入`delay-mode-hooks\u0026rsquo;结构内,这样才能保证父mode的hook不会立即被触发,而统一等到子mode调用`run-mode-hooks\u0026rsquo;时再触发.\n若不使用`define-derived-mode\u0026rsquo;宏,而选择手工定义Major Mode,则可能会需要用到下列函数\n  函数(run-mode-hooks \u0026amp;rest hookvars)\nMajor Mode应该使用该函数来运行自己的mode hook.\n该函数类似`run-hooks',但它还会调用`change-major-mode-after-body-hook\u0026rsquo;和`after-change-major-mode-hook'.\n若在`delay-mode-hooks\u0026rsquo;宏的body中调用该函数,它不会立即执行这些hook,而是推迟到下一次调用`run-mode-hooks\u0026rsquo;时再执行\n  宏(delay-mode-hooks \u0026amp;rest body) 该宏执行BODY中的语句,但BODY中的所有`run-mode-hooks\u0026rsquo;调用都会延迟运行他们的hook,直到下次不在`delay-mode-hooks\u0026rsquo;结构中的调用`run-mode-hooks\u0026rsquo;才运行.\n  变量`change-major-mode-after-body-hook' 触发的时机在major mode hook之前\n  变量`after-change-major-mode-hook' 触发时机正常应该为major mode command的最后一步!\n  Generic Modes \u0026ldquo;Generic Modes\u0026quot;是指的那些只支持基本的注释语法和Font Lock Mode的简单Major Mode.\n使用宏`define-generic-mode\u0026rsquo;来定义generic mode,更多例子参见`generic-x.el\u0026rsquo;中的内容\n  (define-generic-mode mode comment-list keyword-list font-lock-list auto-mode-list function-list \u0026amp;optional docstring)\n若参数docstring为nil,则`define-generic-mode\u0026rsquo;会自动生成一个\n  Minor Modes \u0026ldquo;minor mode\u0026quot;提供了一系列的与major mode无关的特性.\n 变量minor-mode-list 该变量存储了所有的minor mode commands  Minor Mode Conventions 定义minor mode也有一些惯例要遵循,这些惯例有:\n  每个minor mode都应该有一个以`-mode\u0026rsquo;结尾的指示变量,用于判断该minor mode是否启用.\n若minor mode是buffer-local的,则该指示变量也应该是buffer-local的\n该指示变量常与变量`minor-mode-alist\u0026rsquo;结合来在mode line上显示minor mode name.\n该指示变量还与变量`minor-mode-map-alist\u0026rsquo;结合来判断是否激活minor mode keymap.\n  定义一个与上面的指示变量同名的命令,该命令用于开启/关闭minor mde\n该命令需要能够接收一个可选参数.\n  当以interactive方式调用该命令时,若不带参数调用该命令,则切换minor-mode的状态,若参数为正数,则开启minor-mode,若为负数则关闭minor-mode\n  当在lisp中调用该命令时,若参数为nil或正数,则开启minor mode,参数若为\u0026rsquo;toggle,则切换minor-mode,参数为负数则关闭minor-mode\n  下面是一个实现模板\n(interactive (list (or current-prefix-arg \u0026#39;toggle))) (let ((enable (if (eq arg \u0026#39;toggle) (not foo-mode) ; this mode’s mode variable (\u0026gt; (prefix-numeric-value arg) 0)))) (if enable DO-ENABLE DO-DISABLE))   若想在mode line显示该minor mode,则需要往变量中`minor-mode-alist\u0026rsquo;中添加相应的元素.\n`minor-mode-alist\u0026rsquo;中的元素格式应该为`(MODE-VARIABLE STRING)'. 其中\n  `MODE-VARIABLE\u0026rsquo;为指示minor-mode是否开启的哪个变量名称\n  `STRING\u0026rsquo;为在mode line上的显示文本.\n  要注意 minor-mode-alist中不要出现重复的MODE-VARIABLE\n    还有一些类似Major Mode的惯例\n  those regarding the names of global symbols\n  the use of a hook at the end of the initialization function\n  the use of keymaps\n  other\n    另外,尽可能允许用户通过`customization\u0026rsquo;来开闭minor mode.\n因此应该尽量使用`defcustom\u0026rsquo;来定义minor mode的标识变量. 并且要记得 給该标识变量加上autoload cookie并指定`:require\u0026rsquo;定义minor mode的库:\n;;;###autoload (defcustom msb-mode nil \u0026#34;Toggle msb-mode. Setting this variable directly does not take effect; use either \\\\[customize] or the function `msb-mode\u0026#39;.\u0026#34; :set \u0026#39;custom-set-minor-mode :initialize \u0026#39;custom-initialize-default :version \u0026#34;20.4\u0026#34; :type \u0026#39;boolean :group \u0026#39;msb :require \u0026#39;msb)   Keymaps and Minor Modes 每个minor mode都可以有自己的keymap. 要为minor mode设置自己的keymap,需要往变量`minor-mode-map-alist\u0026rsquo;中添加元素. 具体参见Definition of minor-mode-map-alist\nDefining Minor Modes   (define-minor-mode MODE DOC [INIT-VALUE [LIGHTER [KEYMAP]]] KEYWORD-ARGS\u0026hellip; \u0026amp;rest BODY)\n该宏定义一个新的名为MODE的minor mode,并生成一个名为MODE的minor mode command. 参数DOC为该minor mode的说明文档\n该宏还定义了一个名为MODE的指示变量,通过设置该变量为t或nil可以开启/关闭该minor mode. 该变量的默认值为INIT-VALUE.\n参数LIGHTER为一个字符串或nil,当开启了该minor mode后就会在mode-line中显示该字符串, 若为nil则表示不显示在mode-line上\n参数KEYMAP为nil,值为keymap的变量名,keymap,或元素为`(KEY-SEQUENCE . DEFINITION)\u0026lsquo;的alist. 它指定了该minor mode所使用的keymap,并生成名为`MODE-map\u0026rsquo;的变量用于存放keymap 这里的KEY-SEQUENCE和DEFINITION参数格式要匹配`define-key\u0026rsquo;函数的参数格式.\n目前参数KEYWORD-ARGS支持如何keyword参数:\n  `:group GROUP\u0026rsquo;\n指定BODY中的`defcustom\u0026rsquo;语句定义配置项时所属的默认组为GROUP, 若不指定该参数,则所属的默认组为参数MODE\n使用该参数前,请确保已经预先用`defgroup\u0026rsquo;定义了分组\n  `:global GLOBAL-P'\n指明该minor-mode作用于为global还是buffer-local, 默认为nil即为buffer-local的.\n将一个minor-mode变为global的,意味着它的指示变量`MODE\u0026rsquo;被定义为用户配置项, 通过配置项界面改变该变量的值会同时关闭/开启该minor mode.\n这种情况下,需要 保证在配置该配置项时有运行相应的minor mode代码,最简单的方法是使用`:require\u0026rsquo;关键字\n  `:init-value INIT-VALUE'\n设置指示变量`MODE\u0026rsquo;的初始值\n  `:lighter LIGHTER'\n设置显示在mode-line上的内容\n  `:keymap KEYMAP'\n设置minor mode的KEYMAP\n  `:variable PLACE'\n使用PLACE作为minor mode的指示变量(默认为参数MODE).\n这里PLACE可以是一个变量名称,或者可以被`setf\u0026rsquo;赋值的泛型变量(参见Generalized Variables).\nPLACE还可以是格式为`(GET . SET)\u0026lsquo;的cons cell. 其中GET为获取minor mode状态的表达式, SET为接收一个参数并设置minor mode的函数\n  `:after-hook AFTER-HOOK-FORM\u0026rsquo;\nAFTER-HOOK-FORM为一个S表达式(不需要被引用), 它会在minor mode hook触发后运行.\n  其他任意的keyword参数\n这些keyword参数直接被传递給`defcustom\u0026rsquo;用来作为生成minor mode指示变量时的参数. 比较常见的有`:require\u0026rsquo;参数.\n  下面是一个使用`define-minor-mode\u0026rsquo;的例子\n(define-minor-mode hungry-mode \u0026#34;Toggle Hungry mode. Interactively with no argument, this command toggles the mode. A positive prefix argument enables the mode, any other prefix argument disables it. From Lisp, argument omitted or nil enables the mode, `toggle\u0026#39;toggles the state. When Hungry mode is enabled, the control delete key gobbles all preceding whitespace except the last. See the command \\\\[hungry-electric-delete].\u0026#34; ;; The initial value. nil ;; The indicator for the mode line. \u0026#34; Hungry\u0026#34; ;; The minor mode bindings. \u0026#39;(([C-backspace] . hungry-electric-delete)) :group \u0026#39;hunger)   宏(define-globalized-minor-mode GLOBAL-MODE MODE TURN-ON KEYWORD-ARGS) 创建一个与MODE对应的名为GLOBAL-MODE的minor mode.\n`GLOBAL-MODE\u0026rsquo;的意义在于同时启用/关闭所有buffer中的名为`MODE\u0026rsquo;的minor mode\n它会使用函数`TURN-ON\u0026rsquo;来开启buffer中的minor mode,使用`(MODE -1)\u0026lsquo;来关闭buffer中的minor mode\n该宏会定义一个名为`GLOBAL-MODE\u0026rsquo;的配置项,用户可以通过customize通过更改该配置项的值来开启/关闭该minor mode. 当更改该配置项时,请保证已经执行了该`define-globalized-minor-mode\u0026rsquo;代码,最简单的方法是使用`:require\u0026rsquo;关键字参数\n使用`:group GROUP\u0026rsquo; keyword 参数指定了`GLOBAL-MODE\u0026rsquo;所属的组别.\n一般情况下,定义了一个global minor mode的同时,需要定义一个buffer local minor buffer,这样才能允许某些buffer不开启该minor mode\n  Mode Line Format 每个Emacs window的底部一般都会有一个mode line,用来显示buffer的信息.\n每个Emacs Window的顶部也可以有一个header line,其作用与mode line类似.\nMode Line基础说明 mode line显示什么内容由buffer local变量`mode-line-format\u0026rsquo;决定.\nheader line显示什么内容则由buffer local变量`header-line-format\u0026rsquo;决定\n当前选中的window的mode line使用名为`mode-line\u0026rsquo;的face显示, 其他为选中的mode line使用名为`mode-line-inactive\u0026rsquo;的face显示\n出于效率考虑,Emacs不会不停地更新mode line和header line. 只有当你进行如下操作时才回去更新mode-line和header-line\n  更改window configuration\n  切换buffer\n  narrow或widen buffer\n  scroll buffer\n  修改了buffer内容\n  调用了函数`force-mode-line-update'\n  (force-mode-line-update \u0026amp;optional all) 该函数强制更新当前buffer的mode-line和header-line\n但若参数all为非nil,则表示强制更新所有buffer的mode-line和header-line\n  mode-line-format,header-line-format和frame-title-format的格式 mode-line-format,header-line-format和frame-title-format的格式可能是以下几种类型:\n  字符串 类似`format\u0026rsquo;函数中的格式说明符.\n除了字符串中的\u0026rdquo;%-Constructs\u0026quot;会被替换为其他数据外,其他的内容原样显示\n若部分子串包含`face\u0026rsquo;属性,则该部分字串显示时使用`face\u0026rsquo;属性指定的face来显示, 其他没有`face\u0026rsquo;属性的字串,使用`mode-line\u0026rsquo;或`mode-line-inactive\u0026rsquo;来显示.\n字串中的`help-echo\u0026rsquo;和`keymap\u0026rsquo;属性具有特殊的意义,具体参见Properties in Mode\n  SYMBOL类型的变量\n显示为symbol的值.\n但 即使symbol的值为带\u0026rdquo;%-constructs\u0026quot;的字符串,其中的\u0026quot;%-constructs\u0026quot;也不会被转义!!\n此外,若symbol的值为t或nil,或者该symbol被标记为\u0026quot;risky\u0026quot;(该symbol的`risky-local-variable\u0026rsquo;属性非nil),则这些symbol的值会被忽略\n  (字符串 其他数据\u0026hellip;) / (列表 其他数据\u0026hellip;)\n若数据为一个list,且该list的第一个元素为字符串类型或list类型,则表示递归处理所有的列表元素,并将结果合并显示.\n  (:eval FORM)\n若数据为一个list,且第一个元素为`:eval',则表示运行`FORM',并将结果作为显示内容\n注意 FORM中不要load任何文件,因为这样可能导致无穷循环\n  (:propertize ELT PROPS\u0026hellip;)\n若数据为一个list,且第一个元素为`:propertize',则表示递归处理ELT,并为结果加上PROPS提供的字符串属性.\n参数PROPS应该由0到多个\u0026quot;TEXT-PROPERTY\u0026quot; \u0026ldquo;VALUE\u0026quot;组成\n  (SYMBOL THEN ELSE)\n若数据为一个list,且第一个元素为非条件语句的关键字,则表示若SYMBOL的值为非nil则显示递归处理THEN的处理结果,否则显示ELSE的处理记过.\nELSE可以省略,则表示若symbol值为nil,什么也不显示\n  (WIDTH REST\u0026hellip;)\n若数据为一个list,且第一个元素为整数,则表示限定REST的结果显示宽度为WIDTH.\n若WIDTH为正数,表示向左对齐,WIDTH为负数,表示向右对齐.\n  Mode-line-format中常用到的变量 下面所列举的变量,都是mode-line-format的组成部分\n  mode-line-mule-info\n该变量在mode-line-format中可以显示语言环境,buffer的字节编码,当前的输入法\n  mode-line-modified\n该变量会显示当前buffer是否被修改. 默认情况下:\n  若buffer被修改显示'**'\n  若buffer未被修改显示为'\u0026ndash;'\n  若buffer只读显示为'%%'\n  若buffer只读单被修改,显示为'%*'\n    mode-line-frame-identification\n该变量可以用来标识当前frame\n在图形界面下,该变量默认为\u0026rdquo; \u0026ldquo;. 在字符界面下,该变量默认为\u0026rdquo;-%F \u0026quot;\n  mode-line-buffer-identification\n该变量可以用来标识当前buffer.\n它的默认值为\u0026quot;%12b\u0026quot;,附带一些text properties\n  mode-line-position\n该变量标识光标所在当前buffer的位置.\n它默认为\u0026quot;%p\u0026quot;,显示当前所在位置是整个buffer的百分之多少处.\n但也可以给它添加注入buffer大小,行号,列号等信息\n  vc-mode\n该变量指示buffer所关联的文件纳入的版本控制信息.\n若文件未纳入版本控制系统中,则该变量值为nil\n  mode-line-modes\n该变量显示buffer所开启的major mode,minor mode,递归编辑层次,buffer所关联进程的状态,是否出于narrow状态\n该变量值中又包含了三个变量:\n  mode-name\nMajor Mode的名称\n  mode-line-process\n与当前buffer相关的process的状态.\n该变量紧挨着major-name显示. 默为nil\n  minor-mode-alist\n该变量是一个buffer local变量,它指示了如何显示minor-mode.\n该变量的元素组成格式为`(MINOR-MODE-VARIABLE MODE-LINE-STRING)'\n当MINOR-MODE-VARIABLE的值为非nil时,则显示MODE-LINE-STRING,否则什么也不显示\n       mode-line-remote\n该变量用来显示当前buffer的`default-directory\u0026rsquo;是否是远程目录\n  mode-line-client\n该变量用来标识哪些frame为`emacsclient\u0026rsquo;的frame\n  global-mode-string\n若开启了该minor mode的话,该变量的内容会显示在`which-func-mode' minor mode后,否则会显示在`mode-line-modes\u0026rsquo;后\n  %-constructs说明 类似format函数中的格式字符串,%-constructs的格式为`%[整数]标识',这里的整数指定了最小的长度,标识指定了替换为何值\n   %% %字符     %b 当前buffer名称   %c 当前光标所在的列数   %e 当Emacs接近内存耗尽时,显示警告信息,否则为空   %f 当前buffer访问的文件名称   %F 当前frame的title或name   %i 当前buffer可访问部分的size,单位为字节   %I 类似%i,但以更人性化的方式显示,例如会转换为多少k,M,G   %l 当前光标所在的行数   %n 若当前buffer出于narrow状态,则显示\u0026quot;Narrow\u0026quot;,否则显示空   %P The percentage of the buffer text above the top of window, or ‘Top’, ‘Bottom’ or ‘All’. Note that the default mode line construct truncates this to three characters.   %p The percentage of the buffer text that is above the bottom of the window (which includes the text visible in the window, as well as the text above the top), plus ‘Top’ if the top of the buffer is visible on screen; or ‘Bottom’ or ‘All’.   %s 与当前buffer相关的process的状态   %z 键盘,中断,buffer编码格式的信息   %Z 类似%z,但还包括换行符的信息   %* 若buffer只读,显示\u0026quot;%\u0026quot;,若buffer被修改过,显示\u0026quot;*\u0026quot;,否则显示\u0026quot;-\u0026quot;   %+ 类似%*,但若一个read-only buffer被修改了,它显示\u0026quot;*\u0026quot;,而%*会显示\u0026quot;%\u0026quot;   %\u0026amp; 若buffer被修改则显示\u0026quot;*\u0026quot;,否则显示\u0026quot;-\u0026quot;   %[ 显示递归编辑的层次,多少层就有多少个\u0026quot;[\u0026quot;   %] 显示递归编辑的层次,多少层就有多少个\u0026quot;]\u0026quot;   %- 使用\u0026quot;-\u0026ldquo;填充剩余的mode line    Mode Line中的text properties 某些text properties在mode line中有其特殊的意义:\n `face\u0026rsquo;属性影响text的显示 `help-echo\u0026rsquo;属性提供了光标指向他text后弹出的帮助内容 `keymap\u0026rsquo;属性是的text能处理鼠标点击事件  模拟mode line的显示结果   (format-mode-line format \u0026amp;optional face window buffer) 该函数,将format当成是`mode-line-format\u0026rsquo;的值,模拟当指定的WINDOW显示指定BUFFER时会显示怎样的mode-line.\n参数face指定了那些没有指定`face\u0026rsquo;属性的text应该如何显示\n  Window Header Line head-line与mode-line极其类似,它的显示是由变量`header-line-format\u0026rsquo;指定的. 且`header-line-format\u0026rsquo;的格式与`mode-line-format\u0026rsquo;的格式一样\n当一个Window只能显示一行内容时,则它不会显示header line.\n若一个window只能显示两行内容时,它无法同时显示mode-line和header-line. 这时若mode-line不为nil,则会显示mode-line而不是header-line\n (window-header-line-height \u0026amp;optional window) 该函数返回指定WINDOW的header line的高度,单位为像素  Imenu Imenu会在imenu菜单(参见Imenu)中列出buffer中的语法定义名称或章节名称,然后通过点击菜单中的定义名称或章节名称就能直接跳转到相应位置上了.\n  命令(imenu-add-to-enubar NAME)\n该命令会产生一个名为NAME的imenu菜单\n  当然,使用Imenu的前提是,能够产生一个定义/章节名称与buffer位置之间关系的索引.\n通过设置`imenu-generic-expression\u0026rsquo;定义Imenu 通过设置`imenu-generic-expression\u0026rsquo;定义Imenu,是最常用的方式\n  imenu-generic-expression\n该变量为一个list,它指定了使用那种正则表达式来定位定义/章节的位置. 它的元素可以是以下两种格式\n  (SUB-MENU-TITLE REGEXP INDEX)\n这里SUB-MENU-TITLE表示通过REGXP找到的项目应该放到名为`SUB-MENU-TITLE\u0026rsquo;的子菜单中. 若其值为nil,则表示找到的项目直接放到Imenu菜单中.\n参数REGEXP则表示buffer中任何匹配REGEXP的内容都被认为是定义/章节.\n参数INDEX则说明了,REGEXP中哪个匹配的子组为定义/章节的名称\n  (SUB-MENU-TITLE REGEXP INDEX FUNCTION ARGUMENTS\u0026hellip;)\n这种格式的`SUB-MENU-TITLE',`REGEXP\u0026rsquo;和`INDEX\u0026rsquo;与上面格式的意义相同.\n不同之处在于,当点击Imenu中的相关项是,会调用`FUNCTION\u0026rsquo;函数,且传入参数为:菜单项的名称,定义的位置和参数ARGUMENTS\n    imenu-case-fold-search\n该变量决定了使用`imenu-generic-expression\u0026rsquo;中的正则表达式匹配buffer内容时,是否大小写敏感.\n默认为t,表示大小写敏感.\n  imenu-syntax-alist\n该变量是一个元素为'(CHARACTER-OR-STRING . SYNTAX-DESCRIPTION)的alist.\n当Imenu处理`imenu-generic-expression\u0026rsquo;时,会使用该变量来修改当前buffer的syntax table(通过调用`modfy-syntax-entry\u0026rsquo;来实现,具体参见Syntax Table Functions).\n  通过设置`imenu-prev-index-position-function\u0026rsquo;和`imenu-extract-index-name-function\u0026rsquo;来定义Imenu   imenu-prev-index-position-function\n该变量的函数,需要从光标开始处向前扫描,并将光标定位到发现定义/章节的位置,然后返回非nil值.\n若向前再找不到任何定义/章节了,则该函数需要返回nil\n  imenu-extract-index-name-function\n该变量的函数,需要从光标所在位置出抽取出定义/章节的名字\n  通过设置`imenu-create-index-function\u0026rsquo;来定义Imenu 该变量的函数不接受参数,并且返回当前buffer的index alist.\n该变量的默认值为`imenu-default-create-index-function',该函数通过调用`imenu-prev-index-position-function\u0026rsquo;和`imenu-extract-index-name-function\u0026rsquo;的值来产生index alist. 但若这两个参数有一个为nil,则根据`imenu-generic-expression\u0026rsquo;来产生index alist\n这里index alist的元素有三种格式\n  \u0026lsquo;(INDEX-NAME . INDEX-POSITION)\n表示选择INDEX-NAME项,则跳转到INDEX-POSITION位置\n  \u0026lsquo;(INDEX-NAME INDEX-POSITION FUNCTION ARGUMENTS\u0026hellip;)\n表示选择INDEX-NAME项,则执行`(funcall FUNCTION INDEX-NAME INDEX-POSITION ARGUMENTS\u0026hellip;)\u0026rsquo;\n  \u0026lsquo;(SUB-MENU-TITLE . SUB-INDEX-ALIST)\n表示根据SUB-INDEX-ALIST创建子菜单SUB-MENU-TITLE\n  Font Lock Mode Font Lock Mode根据Major Mode的语法规则来对buffer内容进行作色.\nFont Lock Mode通过两种途径来寻找要高亮作色的文本:\n 根据syntax table的语法规则来作色,这种方法优先进行 通过查询(通常通过正则表达式),这种方法随后运行  Font Lock Mode的基础说明 很多变量用来控制Font Lock Mode如何高亮显示. 但Major Mode不应该直接设置这些变量,它应该通过设置`font-lock-defaults\u0026rsquo;变量来实现这一目的.\nFont Lock minor mode启动时,会根据`font-lock-defaults\u0026rsquo;的值来自动设置其他变量.\n  font-lock-defaults\n该变量的值可以为nil,表示Font Lock mode不做任何高亮,需要用户手工通过Edit-\u0026gt;Text Properties-\u0026gt;Faces菜单手工指定那些文本高亮.\n若该变量的值为非nil,则其格式应该为:\n(KEYWORDS [KEYWORDS-ONLY [CASE-FOLD [SYNTAX-ALIST [SYNTAX-BEGIN OTHER-VARS...]]]]) 其中:\n  KEYWORDS\n会被设置为`font-lock-keywords\u0026rsquo;的值. 该变量会影响基于查询的高亮.\nKEYWORDS可能是一个symbol,一个变量或一个返回值为list的函数\nKEYWORDS也可以是一个由多个symbol组成的list,每个symbol对应高亮的一个等级. 其中第一个symbol对应\u0026rsquo;mode default\u0026rsquo;等级的高亮,下一个symbol对应\u0026rsquo;level 1\u0026rsquo;级的高亮,再下一个symbol对应\u0026rsquo;level2\u0026rsquo;级别的高亮依次类推.\n\u0026lsquo;mode default\u0026rsquo;级别的高亮通常与\u0026rsquo;level 1\u0026rsquo;级别的高亮一样,它在当变量`font-lock-maximum-decoration\u0026rsquo;为nil时被使用.\n  KEYWORD-ONLY\n会被用来设置`font-lock-keyword-only\u0026rsquo;的值. 该变量标识了是否只采用基于搜索的高亮.\n若该变量为nil,则Font Lock mode会使用基于语法的高亮,否则Font Lock mode不会使用基于语法的高亮\n  CASE-FOLD\n被用来设置`font-lock-keywords-case-fold-search\u0026rsquo;的值. 该变量表明了在基于搜索的高亮时,是否忽略大小写的差异.\n若为非nil,则表示Font Lock mode在搜索时忽略大小写\n  SYNTAX-ALIST\n被用来作为Font Lock mode基于语法高亮时使用的syntax table.\n该变量的值若为nil,则其应该为由格式`(CHAR-OR-STRING . STRING)\u0026lsquo;组成的list.\n若变量的值为nil,则Font Lock mode使用函数`syntax-table\u0026rsquo;返回的syntax table作为依据.\n  SYNTAX-BEGIN\n该变量用于设置`font-lock-beginning-of-syntax-function\u0026rsquo;的值.\n一般设置该值为nil,而使用`syntax-begin-function\u0026rsquo;代替\n  OTHER-VARS\n剩下的所有元素都统一叫做OTHER-VARS, 其中每个元素的格式应该为(VARIABLE . VALUE),表示将VARIABLE设置为buffer local变量,然后设置值为VALUE\n一样用于设置影响Font Lock mode高亮的其他变量\n    基于搜索的高亮 直接控制基于搜索高亮的变量是`font-lock-keywords\u0026rsquo;,它一般由`font-lock-defautls\u0026rsquo;的\u0026rsquo;KEYWORDS\u0026rsquo;元素指定\nAuto-Indentation Tabulated List Mode Tabulated List Mode是一种用列表来显示数据的Major Mode,这种数据往往由一条条的记录组成,每条记录的内容又可以划分到多个列中.\nTabulated List Mode继承至Special mode,且同时被多个子mode继承,例如Process Menu mode和Package Menu Mode\n要想继承Tabulated List Mode,需要在`define-derived-mode\u0026rsquo;中的BODY中通过设置一些变量(下面会讲到)来定义数据的结构,然后调用函数`tabulated-list-init-header\u0026rsquo;来初始化header line 同时,继承的子mode还需要定义一个\u0026quot;listing command\u0026rdquo;,该命令不是major mode command,它是給用户使用的命令封装,该命令通常完成以下几个动作\n 创建或切换到某个特定buffer 开启新的Major mode 指定要以列表方式显示的数据. 调用`tabulated-list-print\u0026rsquo;函数,以弹出该buffer  指定tabulated data的格式 通过定义以下变量来指定tabulated data的格式\n  tabulated-list-format 该变量为buffer-local变量,它定义了数据的格式.\n该变量为一个vector,且vector中的每个元素都表示一个数据列,其格式为`(NAME WIDHT SORT)\u0026rsquo;. 其中:\n  NAME为列的名称\n  WIDHT为每列的保留宽度,该参数对最后一列来说无意义\n  SORT指定了根据该列排序记录的方式.\n   值 意义     nil 表示不排序   t 表示根据字符串排序   其他判断函数 使用该判断函数传入`sort\u0026rsquo;进行排序. 该判断函数的参数为`tabulated-list-entries\u0026rsquo;中的元素        tabulated-list-entries\n该变量为buffer-local变量,它指定了要显示的记录数据. 它的值 可以为一个list,或一个函数\n若该值为list,则list中的每个元素格式应该为`(ID CONTENTS)',其中\n  ID可以为nil,或一个标识某条记录的lisp object\n  CONTENT为一个表示记录内容的vector,其中vector中的每个元素表示记录的一列内容.\nvector中的元素可能为字符串或者格式为`(LABEL . PROPERTIES)\u0026lsquo;的list,\n若元素为字符串则表示直接显示该字符串\n若元素为`(LABEL . PROPERTIES)\u0026lsquo;格式的list,则表示用`LABEL\u0026rsquo;和`PROPERTIES\u0026rsquo;作为参数调用`insert-text-button\u0026rsquo;的方式来插入一个text button(参见Making Buttons)\n  若`tabulated-list-entries\u0026rsquo;的值为为一个函数,则不带参数调用该函数应该返回上面格式的list\n  tabulated-list-revert-hook\n该hook在重载入Tabulated List Buffer前会被触发, 常用于对`tabulated-list-entries\u0026rsquo;的值作预处理.\n  tabulated-list-printer\n该变量的值应该为一个函数, 该函数接收`tabulated-list-entries\u0026rsquo;中的ID和CONTENTS两个参数, 其返回值才作为真正的列内容显示\n默认该变量的函数,直接插入CONTENTS\n  tabulated-list-sort-key\n该变量指定了根据那几列对记录进行排序.以及是从大到小还是从小到大排序\n  nil表示不排序\n  (NAME . FLIP)格式的cons表示根据名为NAME的列排序,FLIP表示是否反转排序顺序\n    函数(tabulated-list-init-header) 该函数为Tabulated List buffer生成并设置`header-line-format\u0026rsquo;(参见Header Lines),并为header line分配keymap以便允许通过点击header列来排序\n该函数依赖上面所述的变量\n  函数(tabulated-list-print \u0026amp;optional remember-pos) 该函数刷新tabulated list buffer. 该函数通常被list command所调用\n该函数会作以下动作:\n  清空buffer\n  根据`tabulated-list-sort-key\u0026rsquo;对`tabulated-list-entries\u0026rsquo;中的数据进行排序\n  调用`tabulated-list-printer\u0026rsquo;所表示的函数输出记录\n  若参数REMEMBER-POS为非nil,则该函数在刷新buffer前会记住当前行的ID,并在刷新后自动定位到该ID行\n  (tabulated-list-print-entry id cols)\n在光标处插入新entry,entry信息由ID和COLS决定\n其中ID是一个用于标示entry的lisp对象,而COLS为一个由各列信息组成的vector\n  (tabulated-list-print-col n col-desc x) ??\n为光标处entry插入一个特定的entry列\n其中N为列编号,COL-DESC为列描述,X为光标处的列编号\n该函数在插入后,返回列编号\n  其他函数   (tabulated-list-get-id \u0026amp;optional POS)\n返回POS位置entry的ID. POS默认为光标当前位置\n  (tabulated-list-get-entry \u0026amp;optional POS)\n返回POS位置entry的信息. 返回的格式为一个由列信息组成的vector\nPOS默认为光标当前位置\n  (tabulated-list-delete-entry)\n删除光标所在位置的entry. 并返回一个(ID COLS\u0026hellip;)的列表来暂时被删除entry的信息.\n该函数同时会将光标移动到entry的最开头位置\n该函数只会更改buffer内容,而不会更改`tabulated-list-entries\u0026rsquo;的值\n  (tabulated-list-set-col COL DESC \u0026amp;optional CHANGE-ENTRY-DATA)\n更改当前位置的entry中第COL列的内容为DESC\nCOL可以是列的位置,也可以是列的名称.\nCHANGE-ENTRY-DATA指示了是否同时更改`tabulated-list-entries\u0026rsquo;的值\n  (tabulated-list-put-tag tag \u0026amp;optional advance)\n将TAG放入当前entry的padding区域\nTAG为字符串,且大小不能大于`tabulated-list-padding\u0026rsquo;的值\n若ADVANCE为非nil,则光标同时移动到下一行\n  tabulated-list-padding\n每个entry前预留于padding的字符个数\n  Desktop Save Mode Emacs Display The Display Property Images Number相关函数  判断是否为自然数(0+正整数)  (natnump object)\n 判断是否为0  (zerop number)\n 取余数  (% dividend divisor)\n%的参数必须是整数,对于任何两个整数dividend和divisor都有(+(% DIVIDEND DIVISOR) (* (/ DIVIDEND DIVISOR) DIVISOR)) == DIVIDEND\n(mod dividend divisor)\nmode的参数可以是Float型,它的返回值的正负号与DIVISOR一致,并且mod的商值使用floor进行截断到整数,然后再计算返回的余值.\n(+ (mod DIVIDEND DIVISOR) (* (floor DIVIDEND DIVISOR) DIVISOR)) == DIVIDEND\n  三角函数\n  (sin arg)\n  (cos arg)\n  (tan arg)\n  (asin arg)\n  (acos arg)\n  (atan y \u0026amp;optional x)\n  指数计算\n  (exp arg) e的arg次方\n  (expt x y) x的y次方\n  (log arg \u0026amp;optional base) base默认为e,取arg的指数\n  (aqrt arg) 取arg的平方根,若arg\u0026lt;0,则返回NaN\n  常量float-e\n  常量float-pi\n  获取随机值 (random \u0026amp;optional limit)\n  若limit为正整数，则返回0到limit的随意整数\n  若limit为t，则表示使用当前时间和Emacs的进程号重新选择一个种子\n  若limit为一个字符串，它表示使用string的内容作为种子\n    二进制函数 二进制函数只能作用于Integer型参数.\n 逻辑位移  (lsh Integer count)\nlsh是logical shift的缩写,它向左移动count位(若count为负数,则表示向右移动), 使用0填充\n 算术位移  (ash Integer count)\nash是arithmetic shift的缩写,它跟lsh类似,但当对负数进行右移时,使用符号位进行填充,即该函数不会改变Integer的正负号\n and操作  (logand \u0026amp;rest ints-or-markers)\n对所有Integer的所有位做and操作,若没有参数,则返回-1,即所有位都是1的Integer\n or操作  (logior \u0026amp;rest ints-or-markers) 对所有Integer的所有位做or操作,若没有参数,则返回0,即所有位都是0的Integer\n xor操作  (logxor \u0026amp;rest ints-or-markers) 对所有Integer的所有位做xor操作,若没有参数,则返回0,即所有位都是0的Integer\n not操作  (lognot integer) 对Integer的所有位做not操作\n字符串处理相关函数 Emacs has only very few functions that takes a string as argument. Any non-trivial string processing is done with a buffer. Use with-temp-buffer, then insert your string, process it, then use buffer-string to get the whole buffer content.\n判断函数  (stringp object) (string-or-null-p object) (char-or-string-p object) (string-prefix-p prefix str \u0026amp;optional ignore-case) (string-suffix-p suffix str \u0026amp;optional ignore-case) (compare-strings str1 start1 end1 str2 start2 end2 \u0026amp;optional ignore-case)  比较的区间为[start end),start为nil则默认为0,end为nil则表示字符串的结尾.\n该函数会把unibyte string先转换为multibyte string再进行比较.\n若比较的区间,两个string是相等的,则返回t. 若str1\u0026lt;str2,则返回负数,若str1\u0026gt;str2则返回正数. 该整数的绝对值指示了不同点开始的地方\n获取字符串的函数   (make-string count character)\ncount必须为整数，返回由count个character组成的字符串\n  (string \u0026amp;rest characters)\n返回由characters组成的字符串\n  带text properties截取子字符串\n  (substring myStr startIndex \u0026amp;optional endIndex)\nstartIndex和endIndex若为负数,则表示从尾部开始往回数.\n因此(substring str 0)表示返回str的一个copy,但推荐用copy-sequence代替\nsubstring中的参数str也可以是一个vector,例如\n(substring [a b (c) \u0026#34;d\u0026#34;] 1 3) ; =\u0026gt; [b (c)] 若string带有text properties,则新产生的string也会带有text properties\n  不带text properties截取字符串\n(substring-no-peroperties string \u0026amp;optional start end)\n  组合字符串\n  (concat \u0026amp;rest sequences) 返回连接多个字符串的字符串\n(concat \u0026#34;abc\u0026#34; (list 120 121) [122]) ; =\u0026gt; \u0026#34;abcxyz\u0026#34; (mapconcat function sequence separator)\n对sequence的每个元素都调用function,然后将结果用separator concat起来作为字符串返回.当function为\u0026rsquo;identity时则起到join的作用\n(mapconcat \u0026#39;identity \u0026#39;(\u0026#34;abc\u0026#34; \u0026#34;123\u0026#34; \u0026#34;one\u0026#34; \u0026#34;two\u0026#34; \u0026#34;three\u0026#34;) \u0026#34; \u0026#34;) ;=\u0026gt;\u0026#34;abc 123 one two three\u0026#34;  从buffer获取字符串  (buffer-substring myStartPos myEndPos)\n(buffer-substring-no-properties myStartPos myEndPos)\n 获取光标所在位置的内容  (thing-at-point THING),这里THING指明了各种类型:\n(thing-at-point \u0026lsquo;word) // 光标所在位置的单词\n(thing-at-point \u0026lsquo;symbol) // 光标所在位置的单词(包括连字符和下划线)\n(thing-at-point \u0026lsquo;line) // 光标所在位置的行, 一般情况下它获取一行及行结束符,然而若光标处于行的最后一个字符,则不获取行结束符\n(thing-at-point \u0026lsquo;sexp) // 光标所在位置的s表达式\n(thing-at-point \u0026lsquo;sentence) // 光标所在位置的句子\n(thing-at-point \u0026lsquo;defun) // 光标所在位置的函数\n(thing-at-point \u0026lsquo;url) // 光标所在位置的url, 若url不以http开头,则会自动加上http\n\u0026hellip;还有很多类型\n 获取光标所在THING的开始/结束位置  (bounds-of-thing-at-point THING)\n 从报文中截取字符串  (setq myStr (buffer-substring startPos endPos))\n字符串操作  获取字符串长度  (string-width myStr)\n这里要注意的是，不能用(lenth myStr)来获取字符串长度\n(length \u0026#34;我的\u0026#34;) ;=\u0026gt;2 (string-width \u0026#34;我的\u0026#34;) ;=\u0026gt;4   修改字符串内容\n由于字符串是character的数组,因此最基础的修改字符串内容的函数是使用(aset str idx char)来将str的地idx位置的内容替换为char. 由于字符串是数组,而数组的长度是不可变的,因此若替换的character和被替换的character的字节数不相同,则会报错\n(setq str \u0026#34;我的\u0026#34;) (aset str 0 ?\\m) ;str变为了\u0026#34;m的\u0026#34; (store-substring str idx string-or-char)\n使用string-or-char从idx开始替换str的内容,若替换的内容过长,则会报错\n(setq str \u0026#34;我的\u0026#34;) (store-substring str 0 ?n) ;str变为\u0026#34;n的\u0026#34; (store-substring str 1 \u0026#34;nm\u0026#34;) ;会raise args-out-of-range error   清空字符串\n(clear-string str) 该函数会使得str变为二进制字符串,并且将内部结构清空为0\n(setq str \u0026#34;我的\u0026#34;) (clear-string str) ;=\u0026gt;str现在为\u0026#34;\u0000\u0000\u0000\u0000\u0000\u0000\u0026#34;     判断字符串是否匹配某正则表达式  (string-match myRegex myStr)\n 获取捕获到的分组内容  (match-string N myStr) ,这里myStr可以忽略,表示在buffer中作的查询. 但若上一次的匹配使用string-match函数作的,则需要该参数\n 对字符串进行正则替换  (replace-regexp-in-string myRegex myReplacement myStr) ;这里myReplacement可以是一个函数,该函数接收匹配的字符串,然后返回要替换的字符串\n split字符串  (split-string myStr \u0026amp;optiional mySepeartor omit-nulls)\n根据separator拆分myStr,默认值为变量`split-string-default-separators`的值(默认为\u0026quot;[ \\f\\t\\n\\r\\v]+\u0026quot;)\n若omit-nulls为t则在组成list时,会忽略空字符串.\n若希望把字符串分解为(split-string-and-unquote \u0026ldquo;cd \u0026lsquo;abc edf\u0026rsquo;\u0026quot;)\n 字符串正则替换  (replace-regexp-in-string myRegxp myReplace myStr)\n   Format函数  %s  object的输出格式,但是不带引号. 若object为带text properties的string,则text properties也被复制进去了.\n %S  object的输出格式,带引号\n %.Ns / %.NS  截取字符串的前N位显示\n %o  8进制的Integer型\n %d  十进制的Integer型\n %x  十六进制的Integer型,字母用小些形式\n %X  十六进制的Integer型,字母用大写形式\n %c  输出Character\n %e  使用指数形式表示Float型\n %f  使用小数形式表示Float型\n %g  使用指数或小数形式表示Float型,使用哪种表示方式就看哪个更简短.\n %%  %\nlist相关函数 判断函数  (consp object)  object是否为cons cell. 一般情况下,list就是cons cell,但nil比较特殊,虽然它是list,但不是cons clell\n (atom object)  nil即是atom,也是list\n (listp object)  object是否为list\n (nlistp object)  object是否不是list\n (null object) (memq object list)  判断list中是否包含object,它返回list中第一次出现object的位置.函数名中的q表示使用 eq 作为比较函数.\n (memql object list)  类似memq,但是函数名中的ql表示使用 eql 作为比较函数.\n (member object list)  类似memq,但是使用 equal 作为比较函数\n (member-ignore-case str list)  类似member,但参数str必须是string类型,并且比较时不区分大小写,单字节字符串也被转换为多字符串进行比较.\n获取list中的元素  (car-safe object)  它与car不同点在于,若object不是cons ceil,则car会报错,而car-safe只是返回nil\n (cdr-safe object)  它与cdr不同点在于,若object不是cons ceil,则cdr会报错,而cdr-safe只是返回nil\n (pop list)  弹出list中的第一个元素\n (nth n list)  返回list中的第n个元素(从0开始计算), 若n为负数,则返回list中的第一个元素.\n (nthcdr n list)  返回第n个cdr后的list,若n为0或负数,则返回原list\n(nthcdr 2 \u0026#39;(1 2 3 4)) ;=\u0026gt;(3 4) (nthcdr 10 \u0026#39;(1 2 3 4)) ;=\u0026gt;nil (nthcdr -3 \u0026#39;(1 2 3 4)) ;=\u0026gt;(1 2 3 4)  (last list \u0026amp;optional n)  返回list中最后n个元素组成的list,默认n=1\n(last \u0026#39;(1 2 3 4 5) ) ;=\u0026gt;(5) (last \u0026#39;(1 2 3 4 5) 3 ) ;=\u0026gt;(3 4 5)  (safe-length list)  对于circular list,只能表示list的长度最大不会超过safe-length返回的值,而不是实际值.\n (butlast l \u0026amp;optional n)  返回l去掉了后面n个元素后的列表,默认n为1\n(butlast \u0026#39;(1 2 3 4) 1) ;=\u0026gt;(1 2 3) (butlast \u0026#39;(1 2 3 4) 2) ;=\u0026gt;(1 2)  (nbutlast l \u0026amp;optional n)  类似(butlast,但是会同时更改l的值\n创建cons cell和list  (cons obj1 obj2)  cons一般用来将一个元素添加到某个list中的头部.\n(cons 1 \u0026#39;(2 3 4)) ;=\u0026gt;(1 2 3 4)  (list \u0026amp;rest objects) (make-list n object)  返回由n个object组成的list\n(make-list 3 2) ;=\u0026gt;(2 2 2)  (append \u0026amp;rest sequences)  将所有的sequences中的元素串在一起组成一个list, 需要注意的是,出了最后一个参数以外,其他的参数都被copy一份,用于与最后那个参数进行连接.\n(setq trees \u0026#39;(pine oak)) ;=\u0026gt;(pine oak) (setq more-trees (append \u0026#39;(maple birch) trees)) ;=\u0026gt;(maple birch pine oak) (eq trees (last more-trees 2)) ;=\u0026gt;t 通过在最后的参数后添加nil,可以让所有的参数都强制copy\n最后的参数在处理上会有些特殊,最后一个参数只是单纯的被安置到前面参数组成list的cdr位置,例如\n(append \u0026#39;(x y) [z]) ;=\u0026gt;(x y . [z]),最后的参数只是放在cdr的位置而已,因此最终结果不是(x y z)  (reverse list) (copy-tree tree *optional vecp) (number-sequence from \u0026amp;optional to step)  返回一个number list,值的范围为从from开始到to结束,步进为step(默认为1)\n(number-sequence 4 9) ;=\u0026gt;(4 5 6 7 8 9) 若to为nil或与from相等,则返回单元素列表(from)\n若step为0,且to不为nil或与from的值相等,则elisp会报出错误,因为这会产生一个死循环\n若step不为0,而from累加step永远不会超过或到达to,则函数返回nil\n(number-sequence 8 5 1) ;nil (number-sequence 5 8 -1) ;nil 修改list变量 会破坏原参数中的值 这里的函数都会直接修改参数中的list\n  (push element list)\n把element放在list的第一位,作用类似cons\n  (add-to-list listname element \u0026amp;optional append compare-fn)\n类似push,但若list中已经有了element,则保持list不变\n若append为非nil,则将element放在list的最后位置\ncompare-fn默认使用equal进行比较\n  (add-to-ordered-list listname element \u0026amp;optional order)\n这里的order需要是number类型,\norder的值决定了element的位置,若order为nil,则将element放在list中最后带order的元素后面\n(setq foo nil) (add-to-ordered-list \u0026#39;foo \u0026#39;a 1) ;=\u0026gt;(a) (add-to-ordered-list \u0026#39;foo \u0026#39;c 3) ;=\u0026gt;(a c) (add-to-ordered-list \u0026#39;foo \u0026#39;b 2) ;=\u0026gt;(a b c) (add-to-ordered-list \u0026#39;foo \u0026#39;b 4) ;=\u0026gt;(a c b) 若element已经存在,且设定了order,则使用新orde放置element的位置 (add-to-ordered-list \u0026#39;foo \u0026#39;d) ;=\u0026gt;(a c b d) (add-to-ordered-list \u0026#39;foo \u0026#39;e) ;=\u0026gt;(a c b e d) (add-to-ordered-list \u0026#39;foo \u0026#39;f) ;=\u0026gt;(a c b f e d) 若order为nil,则将element放在list中最后带order的元素后面   (setcar cons-ceil object) / (setcdr cons-ceil object)\n修改cons-ceil的car/cdr部分,并返回参数object作为返回值\n通过setcdr可以实现删除/添加list中element的目的\n(setq x1 \u0026#39;(a b c d)) (setcdr x1 (cddr x1));=\u0026gt;\u0026#39;(a c d) (setcdr x1 (append \u0026#39;(1 2) (cdr x1))) ;=\u0026gt; (a 1 2 c d)   (nconc \u0026amp;rest lists)\n类似append,所不同的是它直接修改所有参数的last element的cdr,而不会先做copy-sequence操作.\n由于除了最后一个参数不用被修改之外,其他参数的结构都会被修改,因此除了最后一个参数可以是const list外,其他参数必须是个变量.\n跟append一样的,最后一个参数可以不是list\n(setq x \u0026#39;(1 2 3)) ; =\u0026gt; (1 2 3) (nconc x \u0026#39;z) ; =\u0026gt; (1 2 3 . z) x ; =\u0026gt; (1 2 3 . z)   (nreverse list)\n翻转参数list\n  (sort list predicate-less)\n使用predicate-less进行从小到大的排序,若存在相等的值,则保持相等值的位置不变\n(setq x1 \u0026#39;(1 2 4 3 7 6 5));=\u0026gt;(1 2 4 3 7 6 5) (sort x1 \u0026#39;\u0026lt;) ;=\u0026gt;(1 2 3 4 5 6 7) 这里的predicate-less为比较函数,它接收两个参数,并判断第一个参数是否小于第二个参数.\npredicate-less函数必须有下面两个特性:\n  A\u0026lt;B,则B!\u0026lt;A\n  若A\u0026gt;B,B\u0026gt;C,则A\u0026gt;C\n  注意:\nsort有一个很变态的特性:sort函数会让参数list依然指向原来的哪个cons-cell的位置,而不管这个cons-cell是否在sort后依然是处于第一个元素的位置. 例如\n(setq x1 \u0026#39;(9 8 7 2 3)) (sort x1 \u0026#39;\u0026lt;) ;=\u0026gt;(2 3 7 8 9) x1 ;=\u0026gt;(9),注意,x1实际上依然指向了9这个cons cell的位置 因此一般情况下,都需要把sort的返回结果赋值回参数list\n  (delq object list)\n移除list中所有与object相等的element,函数中的q表示使用eq作为比较函数.\n由于delq在删除list头部的element时,仅仅是返回跳过头部element的cdr位置,而不会改变list参数所指向的位置.\n(setq x1 \u0026#39;(a b c)) (delq \u0026#39;a x1) ;=\u0026gt;(b c) x1 ;=\u0026gt;(a b c) 因此使用delq,一般我们也需要将返回值赋值回参数list\n  (delete object seq)\ndelete函数比较特殊,它根据seq的类型不同而有不同的行为.\n当seq为list类型时,它跟delq一样会修改seq的值,所不同的是它使用equal作为比较函数.\n当seq为vector或string,则delete不会修改原seq的值\n(setq l \u0026#39;((2) (1) (2))) (delete \u0026#39;(2) l) ; =\u0026gt; ((1)) l ; =\u0026gt; ((2) (1)) ;; If you want to change `l\u0026#39; reliably, ;; write `(setq l (delete \u0026#39;(2) l))\u0026#39;. (setq l \u0026#39;((2) (1) (2))) (delete \u0026#39;(1) l) ; =\u0026gt; ((2) (2)) l ; =\u0026gt; ((2) (2)) ;; In this case, it makes no difference whether you set `l\u0026#39;, ;; but you should do so for the sake of the other case. (setq v [(2) (1) (2)]) (delete \u0026#39;(2) v) ; =\u0026gt; [(1)] v ; =\u0026gt; [(2) (1) (2)]   (delete-dups list)\n删除list中所有重复的元素,使用equal作为比较函数.\n当list中有多个重复元素时,delete-dups保留第一个元素.\n  不破坏原参数的值   (remq object list) 类似delq,但不改变原参数list的值. 这里的q也表示使用eq作为判断函数.\n  (remove object seq) 类似函数delete,但它保证不修改参数seq的值\n  alist相关函数 获取alist  (copy-alist alist)  拷贝alist的一个副本(two-level deep copy)\n根据key取key-value键值对  (assoc key alist)  当使用assoc在alist中取键值对时,只会取发现的第一个符合条件的键值对. 因此可以直接用push命令将要修改为的新键值对放到alist的前面,以此来模拟对老键值对的修改,同时保留了老键值对的历史.\n(assoc \u0026#39;garden *nodes*) assoc使用equal函数作为比较函数\n (assq key alist) 类似assoc,但函数名中的q表示使用eq作为比较函数. 一般用于key为symbol类似时,因为eq速度比equal快得多.  根据value查找key-value键值对   (rassoc value alist)\nrassoc也使用equal作为比较函数.\n  (rassq value alist)\n类似rassoc,但是函数名中的q标识用eq作为比较函数\n  (assoc-default key alist \u0026amp;optional test default)\nassoc-default与其他assoc系列函数不同之处在于, 它直接返回key部分,而且它也比较不为cons cell的element.\n若alist中某element为atom,则该element整个被用于与可以进行比较,且使用default作为返回值. 否则若element为cons cell,则使用(car element)进行比较. 使用(cdr element)作为返回值.\n(setq x1 \u0026#39;(0 (1 \u0026#34;one\u0026#34;) (2 \u0026#34;two\u0026#34;)(3 \u0026#34;three\u0026#34; ))) (assoc-default 1 x1);=\u0026gt;(\u0026#34;one\u0026#34;) (assoc-default 0 x1 \u0026#39;equal \u0026#34;zero\u0026#34;) ;=\u0026gt;\u0026#34;four\u0026#34; (assoc-default 4 x1) ;=\u0026gt;nil test为比较函数,默认为equal\n  更新新值/添加新值 使用push将新键值对放入alist中即可\n(push \u0026#39;(old-key new-value) *alist*) (push \u0026#39;(new-key new-value) *alist*) 删除键值对   根据key删除 (assq-delete-all key alist)\n类似delq的alist版,他可能会也可能不会修改原alist的结构,因此 需要将返回值赋值回原参数alist\n函数名中的q表示比较时使用eq函数\n  根据value删除 (rassq-delete-all value alist)\n类似assq-delete-all,但是它比较value而不是key\n  Property list相关函数  判断plist中是否存在指定的property  (plist-member plist property)\n返回plist中指向property的位置. 使用eq作为\n(plist-member \u0026#39;((1) \u0026#34;one\u0026#34; 2 two) 2) ;=\u0026gt;(2 two)   返回plist中匹配参数property的value值 (plist-get plist property)\n该函数使用eq作为比较函数\n   (plist-get \u0026#39;(foo 4) \u0026#39;foo) ; =\u0026gt; 4 (plist-get \u0026#39;(foo 4 bad) \u0026#39;foo) ; =\u0026gt; 4 (plist-get \u0026#39;(foo 4 bad) \u0026#39;bad) ; =\u0026gt; nil (plist-get \u0026#39;(foo 4 bad) \u0026#39;bar) ; =\u0026gt; nil (lax-plist-get plist property)\n类似plist-get,但是该函数使用equal来作为比较函数\n 增加/修改plist中的键值对  (plist-put plist peroperty value)\n该函数可能/可能不会修改原参数plist的结构.因此你需要把返回值重新赋值回原plist中\n(setq my-plist \u0026#39;(bar t foo 4)) ; =\u0026gt; (bar t foo 4) (setq my-plist (plist-put my-plist \u0026#39;foo 69)) ; =\u0026gt; (bar t foo 69) (setq my-plist (plist-put my-plist \u0026#39;quux \u0026#39;(a))) ; =\u0026gt; (bar t foo 69 quux (a)) (lax-plist-put plist property value) 类似plist-put函数,但是使用equal作为比较函数来决定是添加还是更新值\n环状结构体相关函数 有时我们会使用一种环状结构体来存储数据,我们可以插入数据到环状结构体中,也可以删除,旋转环状结构中的数据,还可以遍历数据或者根据索引的模值访问数据(在这种环状结构体中,最新插入的数据索引为0,然后从新到就以此累加).\nelisp提供了名为`ring`的package,供我们方便操作这种环状结构体.\n (make-ring size)  创建一个大小为size的环状结构\n (ring-p object)  判断object是否为环状结构体\n (ring-size ring)  获取该ring上实际包含了多少数据\n (ring-elements ring)  把ring中的数据,从新到旧,以list的形式返回\n (ring-emplty-p ring)  判断ring是否为空\n (ring-ref ring index)  根据索引,查找ring中相应的值.\n最新插入的数据索引为0,然后从新到旧依次累加.\n索引也可以为负数,-1表示最旧插入的数据,-2表示第二旧的数据,以此类推.\n (ring-insert ring object)  往ring中插入object,该object作为最新插入的数据,它的索引为0.\n若ring中的数据已经满了,则该操作会同时删除最旧的那个数据\n该函数的返回值为object\n (ring-insert-at-beginning ring object)  往ring中插入数据,但该数据被作为最旧的数据项来处理.\n若ring中的数据已经满了,则该操作会删除最旧的那个数据.\n (ring-remove ring \u0026amp;optional index)  除并返回ring中的数据. index若为nil则表示最旧的数据\n 若能够保证不超出ring的容量,则可以使用ring结构体作为先进先出队列来使用.例如   (let ((fifo (make-ring 5))) (mapc (lambda (obj) (ring-insert fifo obj)) \u0026#39;(0 one \u0026#34;two\u0026#34;)) (list (ring-remove fifo) t (ring-remove fifo) t (ring-remove fifo))) ;; =\u0026gt; (0 t one t \u0026#34;two\u0026#34;) Sequences相关函数  (sequencep object)  判断object是否为sequence\n (length sequence)  获取sequence中的element个数\n需要注意的是length不能对点列表和环形列表求长度,但是可以用safe-length代替\n (elt sequence index)  返回sequence中index所标示的element(index从0开始标示)\n若index的值不为0到(1- (length sequence)),则若参数sequence不是list,则elisp报`args-out-of-range`错误\n(string (elt \u0026#34;1234\u0026#34; 2)) ; =\u0026gt; \u0026#34;3\u0026#34; (elt [1 2 3 4] 4) ; error--\u0026gt; Args out of range: [1 2 3 4], 4 (elt [1 2 3 4] -1) ; error--\u0026gt; Args out of range: [1 2 3 4], -1  (copy-sequence sequence)  创建sequence的一个新的引用.\n这里引用的意思在于新的copy与原sequence共同指向一个结构,即:若对拷贝添加信新的元素,并不会对原sequence进行修改,但若对原element进行修改会同时影响原sequence,反之依然.\n(setq y (copy-sequence x)) ; =\u0026gt; [foo (1 2)] (eq x y) ; =\u0026gt; nil (equal x y) ; =\u0026gt; t (eq (elt x 1) (elt y 1)) ; =\u0026gt; t ;; Replacing an element of one sequence. (aset x 0 \u0026#39;quux) ; x =\u0026gt; [quux (1 2)] ; y =\u0026gt; [foo (1 2)] ;; Modifying the inside of a shared element. (setcar (aref x 1) 69) ; x =\u0026gt; [quux (69 2)] ; y =\u0026gt; [foo (69 2)] copy-sequence不能用于点列表和环形列表,可以用copy-tree函数拷贝点列表,但无法复制环形列表\n (append aVector nil) append函数提供了一种将sequence转换为list的方法 (setq avector [1 two (quote (three)) \u0026#34;four\u0026#34; [five]]) ; =\u0026gt; [1 two (quote (three)) \u0026#34;four\u0026#34; [five]] (append avector nil) ; =\u0026gt; (1 two (quote (three)) \u0026#34;four\u0026#34; [five])   Array相关函数  (arrayp object)  判断object是否为array\n (aref array index)  获取array中index所指的element的引用\n (aset array index object)  设置array中第index的元素为object,该函数返回object\n (fillarray array object)  将array中所有元素都填充为object\n(setq a [a b c d e f g]) ; =\u0026gt; [a b c d e f g] (fillarray a 0) ; =\u0026gt; [0 0 0 0 0 0 0] a ; =\u0026gt; [0 0 0 0 0 0 0] (setq s \u0026#34;When in the course\u0026#34;) ; =\u0026gt; \u0026#34;When in the course\u0026#34; (fillarray s ?-) ; =\u0026gt; \u0026#34;------------------\u0026#34; Vector相关函数   (vectorp object)\n判断object是否为vector\n  (vector \u0026amp;rest objects)\n创建由objects组成的vector\n  (make-vector N object)\n创建由N个object组成的vector\n  (vconcat \u0026amp;rest sequences)\n将sequences中的element,转换到vector中\n(setq a (vconcat \u0026#39;(A B C) \u0026#39;(D E F))) ; =\u0026gt; [A B C D E F] (eq a (vconcat a)) ; =\u0026gt; nil (vconcat) ; =\u0026gt; [] (vconcat [A B C] \u0026#34;aa\u0026#34; \u0026#39;(foo (6 7))) ; =\u0026gt; [A B C 97 97 foo (6 7)]   Char-Table相关函数   (char-table-p object) 判断object是否为char-table类型的\n  (make-char-table SUBTYPE \u0026amp;optional init) 创建一个新char-table对象,该char-table的subtype为参数SUBTYPE(必须为symbol类型). 该char-table的所有element初始化为参数init(默认为nil).\n一旦创建了char-table,就不能再修改其subtype了.\n  (char-table-subtype char-type) 返回char-table的subtype\n  (char-table-parent char-table) 获得char-table的父级char-table对象,若没有,则返回nil\nchar-table从父级char-table中继承值\n  (set-char-table-parent char-table new-parent-char-table) 为char-table设置父级char-table\n  (char-table-extra-slot char-table n) 返回char-table中第n个slot上的值\n一个char-table有多少个slot,由它的subtype的属性`char-table-extra-slots`决定\n  (set-char-table-extra-slot char-table n value) 设置char-table的第n个slot的值为value\n  (char-table-range char-table range) 该函数返回char-table中某个由参数range指定的范围内的值\nrange参数可以是:\n nil  获取默认值\n char  获取char对应的值\n \u0026lsquo;(from . to)  获取[from,to]这个范围内char的相应值\n  (set-char-table-range char-table range value) 设置char-table中由range所指范围的对应值.\n这里的参数range可能是:\n nil  设置char-table的默认值为value\n t  设置整个char-table的值为value\n char  设置char对应的值为value\n (from. to)  设置范围[from,to]之间的值为value\n  (map-char-table function char-table) 针对char-table中所有值非nil的键值对都作为参数调用function函数.\n该function函数必须接收两个参数(一个key,一个value). 其中key的类型可以是某个char,或这类似\u0026rsquo;(from . to)这样的标示范围的cons ceil(不是很明白什么时候会用到(from.to)这样类型的参数呢??) 而value的值为(char-table-range char-table key)的返回值\nmap-char-table的返回值必定为nil,因此我们通常只使用function的副作用.\n(let (accumulator) (map-char-table #\u0026#39;(lambda (key value) (setq accumulator (cons (list (if (consp key) (list (car key) (cdr key)) key) value) accumulator))) (syntax-table)) accumulator) ;; =\u0026gt; ;; (((2597602 4194303) (2)) ((2597523 2597601) (3)) ;; ... (65379 (5 . 65378)) (65378 (4 . 65379)) (65377 (1)) ;; ... (12 (0)) (11 (3)) (10 (12)) (9 (0)) ((0 8) (3)))   Bool-vector相关函数   创建bool-vector (make-bool-vector length initial)\n创建长度为length的bool-vector,每个值初始化为initial\n(setq a (make-bool-vector 10 nil)) ;=\u0026gt;#\u0026amp;10\u0026#34;\u0000\u0000\u0026#34;   类型判断\n(bool-vector-p object)\nobject是否为为bool-vector类型\n  集合运算\n(bool-vector-exclusive-or a b \u0026amp;optional c)\n求a和b的异或计算结果,若有参数c,则将结果存入c中. 所有参数都都必须为bool vector类型且具有相同的长度\n(bool-vector-union a b \u0026amp;optional c)\n求a\u0026amp;b的计算结果,若有参数c,则将结果存入c中. 所有参数都都必须为bool vector类型且具有相同的长度\n(bool-vector-intersection a b \u0026amp;optional c)\n求a|b的运算结果,若有参数c,则将结果存入c中. 所有参数都都必须为bool vector类型且具有相同的长度\n(bool-vector-set-difference a b \u0026amp;optional c)\n求a-b的运算结果,若有参数c,则将结果存入c中. 所有参数都都必须为bool vector类型且具有相同的长度\n(bool-vector-not a \u0026amp;optional b)\n求!a的运算结果,若有参数b,则将结果存入b中. 所有参数都都必须为bool vector类型且具有相同的长度\n(bool-vector-subsetp a b)\n判断a是否为b的子集, 所谓a是b的子集指的是所有a中值为t的位置,在b中也为t. 所有参数都都必须为bool vector类型且具有相同的长度\n(bool-vector-count-consecutive bool-vector a index)\n统计bool-vector中从index开始,连续值等于a的个数\n(bool-vector-count-population bool-vector)\n统计bool-vector中值为t的个数\n(aref bool-vector index)\n要修改/获取bool-vector的值,需要使用array的相关函数来进行:\n获取bool-vector中index的值\n(aset bool-vecotr index value)\n设置bool-vector在index位置的value\n下面是一些例子\n(setq bv (make-bool-vector 5 t)) ; =\u0026gt; #\u0026amp;5\u0026#34;^_\u0026#34; (aref bv 1) ; =\u0026gt; t (aset bv 3 nil) ; =\u0026gt; nil bv ; =\u0026gt; #\u0026amp;5\u0026#34;^W\u0026#34;   HashTable相关函数 判断函数  (hash-table-p table)  判断table是否为hash-table\n创建hash-table (make-hash-table \u0026amp;rest keyword-args)\n常用的keyword-args有:\n  :test TEST\n指定了用于测试相等的函数. 默认使用eq\n  :weakness WEAK\n指定了hash-table什么时候被垃圾回收机制回收. WEAK的可选参数为:\n nil(默认值)  表示key和value都不是弱引用,hash-table会保证key和value不会被垃圾回收机制回收\n key  表示key为弱引用,即若除了hash-table其他地方没有引用key的变量,则key变量所指的内存块被回收. 该key-value键值对从hash-table中被删除\n value  表示value为弱引用,即若除了hash-table其他地方没有引用value的变量,则value变量所指的内存块被回收. 该key-value键值对从hash-table中被删除\n key-or-value  表示若除了hash-table其他地方 同时 没有引用key或value的变量,则key和value变量所指的内存块被回收. 该key-value键值对从hash-table中被删除\n key-and-value / t  表示key和value都为弱引用,即若除了hash-table其他地方没有引用key或value的变量,则key或value变量所指的内存块被回收. 该key-value键值对从hash-table中被删除\n  :size SIZE 指示大致上会有SIZE个数据存入hash-table,用于优化初始容量,默认为65\n  :rehash-size REHASH-SIZE 指示当hash-table容量爆满后,怎么进行扩容.\n若REHASH-SIZE为正整数,则每次扩容都增加REHASH-SIZE个容量\n若REHASH-SIZE为正浮点数,则每次扩容都按照REHASH-SIZE的倍数来调整容量(因此REHASH-SIZE需要\u0026gt;1)\nREHASH-SIZE默认为1.5\n  :rehash-threshold THRESHOLD 该参数指明了什么时候hash-table进行扩容. 默认为0.8\nTHRESHOLD是一个不大于1的浮点数, 当hash-table中的元素个数\u0026gt;THRESHOLD乘与hash-table容量时,进行扩容\n(copy-hash-table table)\n创建table的副本,但 它的key和value与原table共享\n  添加item / 修改item的值 (puthash myKey myVal myHash)\n删除item (remhash myKey myHash)\n删除myHash中索引为myKey的键值对. 该函数总是返回nil\n(clrhash myHash)\n清空myHash中的所有内容,该函数总是返回nil\n获取某item的值 (gethash myKey myHash \u0026amp;optional default)\n若没key为myKey的item,则返回default,默认为nil\n获取hash中的属性   获取hash中的key-value键值对个数 (hash-table-count myHash)\n  获取hash中的查询机制(即:test属性的值) (hash-table-test myHashTable)\n  获取hash-table中:weak属性的值\n  (hash-table-weakness myHash)\n 获取hash-table中:rehash-size参数的值  (hash-table-rehash-size table)\n 获取hash-table中:rehash-threshold参数的值  (hash-table-rehash-threshold table)\n 获取hash-table中的:size参数的值  (hash-table-size table)\n为hash-map中的所有键值对调用函数处理 (maphash myFunc myHash)\nmyFunc接收两个参数,一个key,一个value.该函数总是返回nil\n获取hash-map中的所有key值 / value值  在emacs24.4之后,可以使用   ;; get all keys (require \u0026#39;subr-x) (hash-table-keys myHash) ; (hash-table-values myHash) ;  在emacs24.3可以自定义函数   (defun get-hash-keys (hashtable) \u0026#34;Return all keys in hashtable.\u0026#34; (let (allkeys) (maphash (lambda (kk vv) (setq allkeys (cons kk allkeys))) hashtable) allkeys ) ) (defun get-hash-values (hashtable) \u0026#34;Return all values in HASHTABLE.\u0026#34; (let (allvals) (maphash (lambda (kk vv) (setq allvals (cons vv allvals))) hashtable) allvals ) ) 修改Hash-table的比较方法 要修改Hash-table中的查询机制,需要同时修改计算Hash Code的方法和比较key值的方法.\n (define-hash-table-test name test-fn hash-fn)  定义一个名为name的hash-table查询机制.\n当定义了查询机制后,该查询机制就可以传给make-hash-table中的:test参数用于新生成的hash-table了.\ntest-fn需要接收两个key作为参数,并在认为两个key相等时返回非nil\nhash-fn则需要接收一个key作为参数,并返回一个整数(可以为负数)作为它的hash值.\nelisp提供了一个函数用于根据object的内容来生成hash值:sxhash\n(defun case-fold-string= (a b) (eq t (compare-strings a nil nil b nil nil t))) (defun case-fold-string-hash (a) (sxhash (upcase a))) (define-hash-table-test \u0026#39;case-fold \u0026#39;case-fold-string= \u0026#39;case-fold-string-hash) (make-hash-table :test \u0026#39;case-fold)  (sxhash obj)  根据obj的内容生成hash code,若两个obj是equal的,则该函数返回相等的hashcode\n(define-hash-table-test \u0026#39;contents-hash \u0026#39;equal \u0026#39;sxhash) (make-hash-table :test \u0026#39;contents-hash) Symbol相关函数 symbol组成部分  (symbol-name symbol)  获取symbol的名称\n(symbol-name \u0026#39;foo)  (symbol-function symbol)  获取symbol的函数cell\n (indirect-function symbol-or-function \u0026amp;optional noerror)  类似symbol-function,但若symbol的function cell为另一个symbol,则它会返回(indirect-function 另一个symbol)的值\n参数symbol-or-function表示它也可以是function类型的,若类型为function,则直接返回该function参数\n    (fset symbol definition)  设置symbol的函数cell为definition\n获取symbol  (make-symbol name)  创建uninterned symbol\n(setq sym (make-symbol \u0026#34;foo\u0026#34;)) ; =\u0026gt; foo (eq sym \u0026#39;foo) ; =\u0026gt; nil ,uninterned symbol和interned symbol是不一样的  (intern name \u0026amp;optoinal obarray)  返回obarray中名为name的symbol,若obarray中不存在名为name的symbol,则新建一个symbol.\nobarray默认为全局变量`obarray`\n参数name必须是字符串类型\n(setq sym (intern \u0026#34;foo\u0026#34;)) ; =\u0026gt; foo (eq sym \u0026#39;foo) ; =\u0026gt; t (setq sym1 (intern \u0026#34;foo\u0026#34; other-obarray)) ; =\u0026gt; foo (eq sym1 \u0026#39;foo) ; =\u0026gt; nil  (intern-soft name \u0026amp;optional obarray)  类似intern,但若obarray中不存在名为name的symbol,则返回nil\n且参数name可以为symbol类型和字符串类型\n(intern-soft \u0026#34;frazzle\u0026#34;) ; No such symbol exists. =\u0026gt; nil (make-symbol \u0026#34;frazzle\u0026#34;) ; Create an uninterned one. =\u0026gt; frazzle (intern-soft \u0026#34;frazzle\u0026#34;) ; That one cannot be found. =\u0026gt; nil (setq sym (intern \u0026#34;frazzle\u0026#34;)) ; Create an interned one. =\u0026gt; frazzle (intern-soft \u0026#34;frazzle\u0026#34;) ; That one can be found! =\u0026gt; frazzle (eq sym \u0026#39;frazzle) ; And it is the same one. =\u0026gt; t 其他函数  (mapatoms func \u0026amp;optional obarray)  对obarray中包含的每个symbol,都调用func来处理,然后返回nil.\nobarray默认为全局的obrray变量\n(setq count 0) (defun count-syms (s) (setq count (1+ count))) (mapatoms \u0026#39;count-syms) ; =\u0026gt; nil count ; =\u0026gt; 54972  (unintern symbol-or-string obarray)  从obarray中删除指定的symbol\n删除成功返回t,否则返回nil\nsymbol中的property  获取symbol的property  (get symbol property)\n从symbol的property list中出去出与参数property eq的值,若没有找到,则返回nil\n(symbol-plist symbol)\n返回symbol相应的property list\n(function-get symbol property) 该函数与get类似,但若参数symbol为另一个函数的别名时,该函数返回实际函数的property的值,而不是别名的property的值\n 设置symbol的property  (put symbol property value)\n设置symbol中property list的相应property的值.\n若原property不存在则添加新property和value,否则更新其value\n(put \u0026#39;fly \u0026#39;verb \u0026#39;transitive) ; =\u0026gt;\u0026#39;transitive (put \u0026#39;fly \u0026#39;noun \u0026#39;(a buzzing little bug)) ; =\u0026gt; (a buzzing little bug) (get \u0026#39;fly \u0026#39;verb) ; =\u0026gt; transitive (symbol-plist \u0026#39;fly) ; =\u0026gt; (verb transitive noun (a buzzing little bug)) (setplist symbol plist)\n覆盖symbol的原property list为参数plist\n该函数的返回值为参数plist\n(setplist \u0026#39;foo \u0026#39;(a 1 b (2 3) c nil)) ; =\u0026gt; (a 1 b (2 3) c nil) (symbol-plist \u0026#39;foo) ; =\u0026gt; (a 1 b (2 3) c nil) 标准symbol property说明  :advertised-binding  symbol所表示的函数的建议绑定键\n char-table-extra-slots  若symbol所表示的值为char-table类型,则该值指明了能有多少个额外slot\n customized-face,face-defface-spc,saved-face,theme-face  定义了face的方方面面的性质,不要去直接修改这些属性,而应该使用deffac及相关函数\n customized-value,save-vlaue,standard-value,theme-value  这些属性用来记录customizable variable的方方面面的属性,不要去直接修改这些属性,而应该使用defcustom及相关函数\n disabled  若为非nil,则表示该函数不为command\n face-documentation  指定face的说明,该属性由defface自动设置\n history-length  指明了minibuffer中,对指定的history list variable的最大历史存储数量\n interactive-form  symbol表示函数的interactive form. 不要直接修改该属性,使用定义函数时的interactive特殊form\n menu-enable  该属性是一个表达式,根据该表达式的值来决定是否在menu中显示该菜单项\n mode-class  若该属性为`special`,则指定的major mode是`special`的\n permanent-local  若该属性值为非nil,则表示symbol表示的变量是buffer-local的变量, 当更换major mode时,这种变量的值不会被重置\n permanent-local-hook  若该属性值为非nil,则表示当鞥该major mode时,该symbol表示的hook变量不被重置\n pure  该属性值为非nil告诉编译器,该symbol所表示的方法为纯函数方法(即没有副作用). 因此在使用const参数来调用该方法时,在编译期就能执行该方法. 这会让一些本该在运行期报的错误,在编译器就被检查出来.\n risky-local-variable  若该属性值为非nil,表示该symbol表示的变量,不建议设置为file-local variable\n safe-function  标示该symbol标示的函数,是否可以安全的执行\n safe-local-eval-function  标示该symbol标示的函数,是否可以安全的在file-local evaluation form中执行\n safe-local-variable  该属性值应该是一个函数,该函数用来决定该symbol表示的变量是否为safe file-local的\n side-effect-free  非nil表示symbol表示的函数无副作用,该属性用来决定函数的安全性和字节编译优化, 不要尝试手工修改它\n variable-documentation  该属性为指定变量的说明\nRegion/Mark相关函数  设置mark  (set-mark-command)\n 删除region  (kill-region)\n 注释region  (comment-region)\n 重新格式化region  (fill-region)\n 缩进region  (indent-region)\n 判断Region是否是active的  (region-active-p) 该函数还要求Transient-mark-mode\nEvaluation `(反引号) `类似\u0026rsquo;, 但当object前带了`,\u0026lsquo;时则会对该object进行求值, 当object前带了`,@`,则会将object的求值结果中的各个元素打散插入.\n对于,@的使用，还另有限制:\n  为了确保其参数可以被拼接，,@必须出现在序列(sequence)Ʈ中。形如`,@b的说法是错误的,因为无处可供b的值进行拼接。\n  要进行拼接的对象必须是个列表，除非它出现在列表最后。\n表达式 `(a ,@1) 将被求值成 (a . 1).\n但如果尝试将原子拼接到列表的中间位置,例如 `(a ,@1 b),将导致一个错误.\n  反引用并不是只能使用在.你可以在任何需要构造序列的场合使用反引用.\n  函数  (eval form \u0026amp;optional lexical)  在当前环境下执行form\n参数lexical决定了form中的本地变量采用的是静态作用域还是动态作用域.\n  nil 表示使用动态作用域\n  t 表示使用静态作用域\n  某个非空的alist 表示alist中所指定变量采用静态作用域,其他变量为动态作用域\n  (eval-region start end \u0026amp;optional stream read-function)\n  运行由start和end所标识的region\n默认情况下,eval-region并不产生任何输出,但通过传递一个非nil的stream参数,可以将期间产生的输出输出到stream中\n若read-function为非nil,则使用指定的read-function来取代read函数读取表达式. 该函数需要接收一个参数:读取输入的stream\n (eval-buffer \u0026amp;optioanl buffer-or-name stream filename unibyte print)  运行指定buffer的可见部分所组成的region.\nbuffer-or-name可以为buffer或string,也可以为nil表示当前buffer\nstream的作用跟eval-region中的stream类似,但若stream为nil而print为非nil,则执行的结果依然会被丢弃,但执行的过程中所产生的哪些输出会被输出到echo area中.\nfilename是給load-history使用的文件名称.\n若inibyte为非nil,则elisp reader尽可能的将string转换为unibyte格式.\n选项   max-lisp-eval-depth\n  max-specpdl-size\n  values\n  该变量的值为一个list,每个list元素都是执行form的结果,最近的结果放到第一位.\n(setq x 1) ; =\u0026gt; 1 (list \u0026#39;A (1+ 2) auto-save-default) ; =\u0026gt; (A 3 t) values ; =\u0026gt; ((A 3 t) 1 ...) 缓冲区 获取buffer对象   得到当前buffer对象\ncurrent-buffer(当前buffer不一定是在屏幕上显示的哪个缓冲区,另外,当命令执行完成后,光标所在的buffer自动成为当前buffer )\n  若缓冲区存在则返回该缓冲区对象,否则新建缓冲池对象返回\nget-buffer-create\n  若有同名缓冲区存在,则新建的缓冲区后会加上后缀\ngenerate-new-buffer\n  获得所有buffer的列表\nbuffer-list\n  获得窗口对应的buffer\nwindow-buffer\n  buffer操作   返回当前buffer的文件全路径\nbuffer-file-name\n  获得指定/当前buffer的名字\nbuffer-name\n   (buffer-name [buffer对象])   重命名缓冲区\nrename-buffer\n  产生一个唯一的缓冲区名 generate-new-buffer-name\n  设置指定buffer为当前buffer\n(set-buffer myBuffer)\n  保存当前buffer到文件\nsave-buffer\n  在不改变当前状态下,临时用另一buffer的变量代替现有变量执行语句\nwith-current-buffer\n   (with-current-buffer buffer对象或buffer名称 表达式)   关闭缓冲区\n(kill-buffer myBuffer) ;如果要用户确认是否要关闭缓冲区，可以加到kill-buffer-query-functions里。如果要作善后处理，可以用kill-buffer-hook\n  关闭当前buffer\n(kill-this-buffer)\n  确认缓冲区是否存在\nbuffer-live-p\n  使用临时buffer执行相应代码\nwith-temp-buffer\n   ;; use a temp buffer to manipulate string (with-temp-buffer (insert myStr) ;; manipulate the string here (buffer-string) ; get result )   创建新的空标记\nmake-marker\n   (make-marker)   设置标记的位置和缓冲区\nset-marker\n   (set-marker foo (point))   得到point处的标记\npoint-marker\n   (point-marker)   复制标记或直接用位置生成一个标记\ncopy-marker\n   (copy-marker 位置/marker对象)   得到一个marker的内容\nmaker-position / marker-buffer\n   (maker-position marker对象) (marker-buffer marker对象)   buffer大小\nbuffer-size\n  mark-marker\npoint /point-max /point-min\n  返回当前缓冲区的mark(注意mark与marker的区别,mark是用来与point一起定义一个region的,而marker是一个标记位置)\n  设置mark的值,并激活mark\nset-mark\n  加入/删除mark-ring的元素\npush-mark / pop-mark\n  取得region的起点和终点\nregion-beginning / region-end\n  让某个缓冲区可见\ndisplay-buffer\n  判断buffer是否被修改\n  (buffer-modified-p)\n 选中的window切换到上一个/下一个buffer  (previous-buffer)\n(next-buffer)\n   获取缓冲区内容   得到整个缓冲区的文本\nbuffer-string\n  得到buffer某个区间的文本\nbuffer-substring\n  得到point附件的字符\nchar-after / char-before\n  point处的词\ncurrent-word\n  得到point处的其他类型的文本\nthing-at-point\n  buffer内容处理相关函数 删除操作  删除从当前光标开始的N个字符  (delete-char N)\n  删除光标前的N个字符\n(delete-backward-char N)\n 删除region  (delete-region sartPos endPos)\n 清空整个buffer  (erase-buffer)\n  插入操作  在光标处插入文字  (insert str)\n 在光标处插入某buffer的一部分文本  (insert-buffer-substring-no-properties myBuffer myStartPos myEndPos)\n  插入文件中某部分到当前缓冲区中\n(insert-file-contents myPath)\n(insert-file-contents filename \u0026amp;optional visit beg end replace) 如果指定visit则会标记缓冲区的修改状态并关联缓冲区到文件，一般是不用的。 replace是指是否要删除缓冲区里其它内容，这比先删除缓冲区其它内容后插入文件内容要快一些，但是一般也用不上。 insert-file-contents会处理文件的编码，如果不需要解码文件的话，可以用insert-file-contents-literally。\n  查找/替换操作  改变大小写  (capitalize-region startPos endPos)\n 替换操作  变量`case-fold-search`决定是否大小写敏感\nreplace-match,需要与其他的search类函数配合,它替代上次search匹配的文本\n(replace-match 字符串) 表示用字符串替代上次search匹配的文本呢\n  获取上次正则查询的分组内容\n(match-string N) 返回上次正则查询的第N个分组的内容\n  获取上次正则查询分组的起始/结束电\n(match-beginning N)\n(match-end N)\n   保存现场   保存当前buffer,执行其中的表达式,然后回复为原来的buffer\nsave-current-buffer\n   (save-current-buffer 表达式)  保存narrow-to-region  (save-restriction (narrow-to-region pos1 pos2) lisp代码)\n 保存buffer状态  (save-excursion reset body )\nWindow 基本概念 live window 有buffer显示的window被称为live window, 可以通过 (window-livep object) 来判断\nvalid window valid window可能是live window或internal window. 要注意它与live window的区别. 一个valid window可能被删除,则变成invalid window,但它仍可能被其他lisp对象所引用. 并且一个被删除的window可能通过恢复之前报错的window configuration变回valid window\n使用 (window-valid-p object) 来判断是否为valid window\nselected-window 任何时候,不管有多少个frame,只有唯一一个selected window\n一般来说,selected window的buffer就是\u0026quot;current buffer\u0026rdquo;,但有一种情况例外,就是使用 set-buffer 之后.\nwindow与frame的关系 一个window只可能属于一个frame.\n  (window-frame \u0026amp;optional window)\n该函数获取指定window所属的frame\n  (window-list \u0026amp;optional frame minibuffer window)\n该函数获取指定frame的所有 live window 列表.\nMINIBUFFER参数指定了返回的live window列表是否包含minibuffer window.\n  t: 包含minbuffer window\n  nil: 当minibuffer被激活时才包含\n  其他: 不包含\n  WINDOW参数指定了live window列表中的第一个window,它应该是指定frame中的一个live window.\n若未指定WINDOW参数,则selected window作为列表的第一个window\n  window在每个frame中都是以window tree的形式被组织起来的.\n______________________________________ | ______ ____________________________ | || || __________________________ || || ||| ||| || ||| ||| || ||| ||| || |||____________W4____________||| || || __________________________ || || ||| ||| || ||| ||| || |||____________W5____________||| ||__W2__||_____________W3_____________ | |__________________W1__________________| 每个window tree的叶节点都是live window组成的. window tree的中间节点则是由internal window组成,即哪些不显示buffer的window internal window存在的目的是为了组织live window之间的关系. window tree的root节点被称为root window. 它可以是live window也可以是internal window\n一般来说,window tree并不包含minibuffer window,除非整个frame只有这个minibuffer window\n当分割一个window后,分割出来的两个live window中有一个 就是之前被分割的那个window对象. emacs会新建两个window对象:一个是分割出来的另一个live window,还有一个是internel window作为分割出两个live window的父window\n每个internal window最少具有两个子窗口,若某internal window的子窗口数降为1,则Emacs自动删除该internal window.\n获得窗口对象   (frame-root-window \u0026amp;optional frame-or-window)\n该函数返回FRAME-OR-WINDOW的root window\n参数FRAME-OR-WINDOW若为nil则表示返回当前选中frame的root window\n  (window-parent \u0026amp;optional window)\nWINDOW的父window, 默认为选中窗口的父window\n  (window-top-child \u0026amp;optional window)\n返回指定WINDOW的最上方的子window\n当然WINDOW必须是是internal window且其子窗口应是垂直组合的,否则该函数返回nil\n  (window-left-child *optional window)\n返回指定WINDOW的最左方的子window\n当然WINDOW必须是是internal window且其子窗口应是水平组合的,否则该函数返回nil\n  (window-child window)\n该函数返回指定WINDOW的第一个子window.\n该函数自动判断WINDOW中子window的排列方式,并返回最上方会最左方的子window\nWINDOW必须是internal window,否则返回nil\n  (window-combined-p \u0026amp;optional window horizontal)\n判断WINDOW是否与其他WINDOW垂直/水平排列.\n参数HORIZONTAL为nil表示判断是否垂直排列,否则判断是否水平排列\n  (window-next-sibling \u0026amp;optional window)\n返回WINDOW的下一个兄弟window\n  (window-prev-sibling \u0026amp;optional window)\n返回WINDOW的上一个兄弟window\n  (frame-first-window \u0026amp;optional frame-or-window)\n返回指定FRAME中的最最上方的live window\n  (window-in-direction direction \u0026amp;optional window ignore sign wrap mini)\n返回与WINDOW在DIRECATION方向上相邻的live window\n参数DIRECTION可能是above,below,left,right\n参数WINDOW必须是live window,且默认为选中的window\n一般情况下, 该函数会跳过那些参数`no-other-window\u0026rsquo;为非nil的window,但若参数IGNORE为非nil,则该函数不跳过\nIf the optional argument sign is a negative number, it means to use the right or bottom edge ofwindowas reference position instead ofwindow-point. If sign is a positive number, it means to use the left or top edge ofwindowas reference position.\n参数WRAP若为非nil,则表示允许越过frame边界,例如最右边的右边调到了最左边.\n参数mini指定了什么情况下返回minibuffer window,且若WRAP为非nil,则该函数只有在minibuffer被激活状态才返回minibuffer window\n  (window-tree \u0026amp;optional frame)\n返回指定frame的window-tree\n  得到当前光标所在的窗口对象\nselected-window\n  得到当前frame里的所有窗口\nwindow-list\n  window-lists里排在某个window之后/之前的窗口对象\nnext-window / previous-window\n  查找符合某个条件的窗口\nget-window-with-predicate\n  根据buffer获得window(如果有多个窗口显示同一个缓冲区,那么函数由window-list决定返回哪个).\nget-buffer-window\n  根据buffer获得全部的相应window\nget-buffer-window-list\n  根据给定的文件名,返回缓冲区\nfind-buffer-visiting\n  窗口操作   分割window\nsplit-window\n  删除当前选中的窗口\ndelete-window\n  删除其他窗口\ndelete-other-windows\n  得到当前窗口配置信息,可以用setq保存起来\ncurrent-window-configuration\n  设置当前窗口配置信息\nset-window-configuration\n  使某个窗口对象变成选中的窗口\nselect-window\n  执行的语句结束后,选择的窗口仍留在执行语句之前的窗口\nsave-selected-window / with-selected-window\n  遍历窗口操作\nwalk-windows\n  让某个窗口显示某个缓冲区\nset-window-buffer\n  让选中的窗口显示某个缓冲区\nswitch-to-buffer\n  窗口信息   得到当前窗口的结构\nwindow-tree\n  判断窗口对象是否存在\nwindow-live-p\n  获得窗口的高度(包括了mode line和 header line)\nwindow-height\n  获得窗口的高度(排除了mode line和 header line)\nwindow-body-height\n  窗口的宽度,不包括滚动条和边缘\nwindow-width\n  返回各顶点的坐标信息(包括滚动条,边缘,mode line ,header line)\nwindow-edges\n  返回窗口的文本区域的坐标信息\nwindow-inside-edges\n  用像素表示的window位置\nwindow-pixel-edges / window-inside-pixel-edges\n  文件 文件读写   打开一个文件\n(find-file myPath)\n  改变缓冲区关联的文件\nset-visited-file-name\n  保存当前文件\n(save-buffer)\n  另存为文件\n(write-file myPath)\n  把文本块追加到文件后\n  (append-to-file startPos endPos filePath)\n  把缓冲区当中的一部分写入到指定文件中\nwirte-region\n(write-region start end filename \u0026amp;optional append visit lockname mustbenew) 如果指定append则是添加到文件末尾。 visit参数也会把缓冲区和文件关联， lockname 则是文件锁定的名字 mustbenew(保文件存在时会要求用户确认操作。\n  文件信息   判断文件是否存在,对于目录和一般文件都能用这个函数进行判断,但是符号链接只有当目标文件存在时才返回t\nfile-exists-p\n  文件属性判断\nfile-readable-p / file-writable-p / file-executable-p / file-modes\n  判断文件类型是普通文件/目录/符号链接,其中file-symlink-p返回目标文件名\nfile-regular-p / file-directory-p / file-symlink-p\n  文件的详细信息\nfile-attributes\n  设置文件修改时间\nset-file-times\n  设置文件位模式\nset-file-modes\n  除去链接后的真实文件名\nfile-truename\n  文件名相关函数   分解文件路径各部分\nfile-name-directory / file-name-nodirectory / file-name-sans-extension / file-name-extension / file-name-sans-versions\n(file-name-directory \u0026#34;~/temp/test.txt\u0026#34;) ; =\u0026gt; \u0026#34;~/temp/\u0026#34; (file-name-nondirectory \u0026#34;~/temp/test.txt\u0026#34;) ; =\u0026gt; \u0026#34;test.txt\u0026#34; (file-name-sans-extension \u0026#34;~/temp/test.txt\u0026#34;) ; =\u0026gt; \u0026#34;~/temp/test\u0026#34; (file-name-extension \u0026#34;~/temp/test.txt\u0026#34;) ; =\u0026gt; \u0026#34;txt\u0026#34; (file-name-sans-versions \u0026#34;~/temp/test.txt~\u0026#34;) ; =\u0026gt; \u0026#34;~/temp/test.txt\u0026#34; (file-name-sans-versions \u0026#34;~/temp/test.txt.~1~\u0026#34;) ; =\u0026gt; \u0026#34;~/temp/test.txt\u0026#34;   测试一个路径是否是绝对路径\nfile-name-absolute-p\n  得到绝对路径\n(expand-file-name myFilePath)\n  把绝对路径转换成相对路径\n(file-relative-name myFilePath dirPath)\n  把路径转换为目录形式,也就是确保它是以路径分隔符结束的\nfile-name-as-directory\n(file-name-as-directory \u0026#34;~rms/lewis\u0026#34;) ; =\u0026gt; \u0026#34;~rms/lewis/\u0026#34;   获得目录名\ndirectory-file-name\n(directory-file-name \u0026#34;~lewis/\u0026#34;) ; =\u0026gt; \u0026#34;~lewis\u0026#34;   得到所在系统使用的文件名\nconvert-standard-filename\n(convert-standard-filename \u0026#34;c:/windows\u0026#34;) ;=\u0026gt; \u0026#34;c:\\\\windows\u0026#34;   得到某个目录的全部或者符合某个正则表达式的文件名,directory-files-attributes返回的列表包含了file-attributes得到的信息\ndirectory-files / directory-files-and-attributes\n  得到某个文件在目录中的所有版本\nfile-name-all-versions\n  得到通配符扩展厚的文件列表\nfile-expand-wildcards\n  文件操作   重命名 拷贝 删除文件\n(rename-file fileName newName)\n(copy-file sourcName desName)\n(delete-file fileName)\n  (copy-directory dirPath newDirPath)\n  删除目录\n(delete-directory dirPath 是否循环删除子目录的标记 是否放入Trash的标记)\n  设置文件MODE\n  (set-file-mode FILE MODE)\n 获取目录中的文件列表  (directory-files DIR \u0026amp;optional FULL MATCH NOSORT)\n 创建目录  (make-dirctory DIR \u0026amp;optional PARENTS)\n   临时文件   这个函数按给定前缀产生一个不和现有文件冲突的文件，并返回它的文件名。如果给定的名字是一个相对文件名，则产生的文件名会用temporary-file-directory 进行扩展。也可以用这个函数产生一个临时文件夹。\nmake-temp-file\n(make-temp-file \u0026#34;foo\u0026#34;) ; =\u0026gt; \u0026#34;/tmp/foo5611dxf\u0026#34;   产生一个不存在的文件名\nmake-temp-name\n(make-temp-name \u0026#34;foo\u0026#34;) ; =\u0026gt; \u0026#34;foo5611q7l\u0026#34;   神奇的handler  在Emacs里，底层的文件操作函数都可以托管给elisp中的函数，这样只要用elisp实现了某种类型文件的基本操作，就能像编辑本地文件一样编辑其它类型文件了  Processes Emacs可以同步或异步的方式创建子进程,并以process对象的形式表现出来.\n除了管理Emacs的子进程之外,Emacs还可以管理操作系统中的其他非Emacs子进程.\n (processp object)  判断object是否为Emacs的子进程\n创建子进程 可以使用`start-process\u0026rsquo;创建异步进程,并获得process object. 也可以使用`call-process\u0026rsquo;和`call-process-region\u0026rsquo;创建同步进程.\nEmacs创建的子进程继承了Emacs的运行环境,但可以使用`process-environment\u0026rsquo;覆盖默认的运行环境.\n参数program表示要执行的程序名称. 需要注意: program应该只包含要执行的程序名称,而不能包括参数\n参数buffer-or-name指定了程序的输出显示在哪个buffer中,nil表示丢弃输出. unless a custom filter function handles it. 对于同步进程,可以指定输出到文件中而不是buffer\n参数args表示传递到程序的参数,所有的args都是string类型的. 在这些string中, 扩展字符和其他shell特殊字符并不会经过shell展开,因为参数是直接传递给指定程序的.\n 配置项exec-suffixes  一个包含后缀字符串的list. 当搜索可执行程序时,会添加该列表中的后缀到执行程序名称的后面.\n exec-directory  该变量是一个表示目录的字符串,该目录存放的是Emacs自带的一些程序\n 配置项exec-path  当Emacs创建子进程时,若参数program为相对路径,会从该list中指定的目录中搜索要执行的程序.\n该list中的每个元素都是一个表示目录的字符串,若为nil则表示default directory(变量`default-directory\u0026rsquo;的值)\n (shell-quote-argument argument)  转义argument,使得返回的字符串以shell语法来看,其真实的内容就是argument\n该函数常用于将特殊参数按字面上的意义转递給shell去执行\n;; This example shows the behavior on GNU and Unix systems. (shell-quote-argument \u0026#34;foo \u0026gt; bar\u0026#34;) ; =\u0026gt; \u0026#34;foo\\\\ \\\\\u0026gt;\\\\ bar\u0026#34; ;; This example shows the behavior on MS-DOS and MS-Windows. (shell-quote-argument \u0026#34;foo \u0026gt; bar\u0026#34;) ; =\u0026gt; \u0026#34;\\\u0026#34;foo \u0026gt; bar\\\u0026#34;\u0026#34;   (split-string-and-unquote string \u0026amp;optional separators)\n该函数常用于将一个字符串分拆成由独立的command-line argument组成的list,可以直接作为创建子进程时的arg参数来使用\n该函数根据正则separators的要求将string进行分拆, 并对substring进行反引用\n  (combine-and-quote-string list-of-strings \u0026amp;optional seprator)\n该函数可以认为是`split-string-and-unquote\u0026rsquo;的反作用.\n该函数将list-of-string合并成一个单独的string, 若有必要的话,还会对list中的每个string先做一次引用转换.\n  (call-process program \u0026amp;optional infile destination display \u0026amp;rest args)\n同步调用program,这时Emacs会暂停一直等到子进程结束,并返回结束码\n若参数infile不为nil,表示program从哪个文件读取输入. nil表示从null device读取输入\n若参数display为非nil,则`call-process\u0026rsquo;会在有内容输出时,刷新buffer的显示.\n参数args表示传递給program的参数\n参数destination表示program的output输出到哪:\n buffer-or-string  插入到buffer中\n t  插入到当前buffer\n nil  丢弃输出\n 0  丢弃输出,并且不等待子进程结束就直接返回nil.\n (:file FILE-NAME)  覆盖FILE-NAME指代的文件内容\n (REAL-DESTINATION ERROR-DESTINATION)  区分输出stdout和stderr.\n若error-destination为nil表示丢弃stderr,若为t表示与stdout输出到一个地方,若为字符串表示输出stderr到文件中.\n注意: 你无法将error-destincation设置为某个buffer,因为实现起来太难了.\n  (process-file program \u0026amp;optional infile buffer display \u0026amp;rest args)\n类似`call-process\u0026rsquo;,但根据变量`default-directory\u0026rsquo;的值不同,可能会invoke a file handler\n参数的意思跟`call-process\u0026rsquo;极其相似,其区别在于:\n  Some file handlers may not support all combinations and forms of the arguments INFILE, BUFFER, and DISPLAY.\n  当file handler被调用时,该file handler根据参数program来决定应该运行哪个程序.\n  例如,suppose that a handler for remote files is invoked. Then the path that is used for searching for the program might be different from `exec-path\u0026rsquo;\n  参数infile也可能调用file handler. 该file handler可能与`process-file\u0026rsquo;自己选择的file-handler不一样\n  若参数buffer使用\u0026rsquo;(REAL-DESTINATION ERROR-DESTINATION)这样的格式,并且ERROR-DESTINATION为表示文件的字符串,则跟infile一样,可能调用起其他的file-handler\n    process-file-side-effect\n该变量指定了当调用`process-file\u0026rsquo;时,是否可以修改远程文件.\n默认为t,表示可以修改.\n该参数只能用在let-binding中,不要用在setq中\n  (call-process-region start end program \u0026amp;optional delete destination display \u0026amp;rest args)\n类似`call-process\u0026rsquo;,该函数同步调用子进程,并将从start到end处的文本作为进程的stdin.\n若参数delete为非nil,则会删掉从start到end处的文本内容,这在参数destination为t时,可以实现替代的功能.\n  (call-process-shell-command command \u0026amp;optional infile destination display \u0026amp;rest args)\n该函数同步执行shell命令command\n其参数说明与`call-process\u0026rsquo;类似\n  (process-file-shell-command command \u0026amp;optional infile destination display \u0026amp;rest args)\n类似`call-process-shell-command\u0026rsquo;,但是内部使用`process-file\u0026rsquo;代替`call-process\u0026rsquo;\n  (shell-command-to-string command)\n该函数将command作为shell command来执行,并将执行结果作为string返回\n  (process-lines program \u0026amp;rest args)\n该函数运行program,等待它执行完成,然后以字符串list的形式返回输出.\n若参数program退出时返回非0的退出码,该函数会抛出error\n  (start-process name buffer-or-name program \u0026amp;rest args)\n该函数异步创建PROGRAM子进程,并返回一个process object.\n参数NAME指定了返回process object的名称. 若改名称的process已经存在,则NAME会被修改(通过在后面添加\u0026lt;1\u0026gt;,\u0026lt;2\u0026gt;\u0026hellip;)成唯一的名称.\n参数BUFFER-OR-NAME是与process相关联的buffer\n若PROGRAM为nil,则Emacs创建一个新的伪终端(pty)并且将它的input和output与BUFFER-OR-NAME指定的buffer相关联,但是不会去创建子进程,而且参数ARGS被忽略\n(start-process \u0026#34;my-process\u0026#34; \u0026#34;foo\u0026#34; \u0026#34;sleep\u0026#34; \u0026#34;100\u0026#34;) ;;=\u0026gt; #\u0026lt;process my-process\u0026gt; (start-process \u0026#34;my-process\u0026#34; \u0026#34;foo\u0026#34; \u0026#34;ls\u0026#34; \u0026#34;-l\u0026#34; \u0026#34;/bin\u0026#34;) ;;=\u0026gt; #\u0026lt;process my-process\u0026lt;1\u0026gt;\u0026gt;   (start-file-process name buffer-or-name program \u0026amp;rest args)\n类似`start-process\u0026rsquo;,但是根据`default-directory\u0026rsquo;的值不同,可能会调用file handler\nThis function does not try to invoke file name handlers for PROGRAM or for the PROGRAM-ARGS.\n有些file handler不能支持`start-file-process\u0026rsquo;(例如函数`ange-ftp-hook-function\u0026rsquo;). 这种情况下,该函数什么也不做并返回nil\n  (start-process-shell-command name buffer-or-name command)\n类似`start-process\u0026rsquo;,只是它使用shell来执行COMMAND. 使用哪种shell由变量`shell-file-name\u0026rsquo;决定\n与直接用`start-process\u0026rsquo;来执行COMMAND相比,使用shell来执行COMMAND的好处在于可以使用shell特性来处理参数力的通配符. 也正因为这样,当在命令中包含任何特殊字符时,都需要使用`shell-quote-argument\u0026rsquo;来转义. 同样的,执行的命令来自于用户的输入,则为了安全考虑,也需要做一下转义\n  (start-file-process-shell-command name buffer-or-name command)\n类似`start-process-shell-command',但是在内部使用`start-file-process\u0026rsquo;代替`start-process'\n  process-connection-type\nEmacs通过\u0026quot;pty\u0026quot;或\u0026quot;pipe\u0026quot;来控制异步进程. 具体使用哪种方式由该变量的值决定.\nnon-nil表示使用pty,nil表示使用pipe\n(let ((process-connection-type nil)) ; use a pipe (start-process ...)) 对于那些用户可见的进程,使用\u0026quot;pty\u0026quot;更好点,因为它允许用户在进程与它的子进程之间进行job control(`C-c',`C-z\u0026rsquo;等操作)\n而对于程序内部使用的进程来说,偏向使用\u0026quot;pipe\u0026quot;,因为它更有效率,and because they are immune to stray character injections that ptys introduce for large (around 500 byte) messages. 而且pty的总数是有限制的,最好不要浪费\n  Deleting Processes delete process会立即断开Emacs与process的连接,并且Emacs会发送信号去终止process的执行,并调用process sentinel\n要注意: process被删除掉,不代表process object会被立刻回收 有些函数可以接收表示被删除process的process object,但是尝试对它作IO操作,发发送信号給它时,会爆出错误.\n 配置项delete-exited-processes  该变量决定了当一个process终止运行了,是否自动删除它.\n若为nil则不自动删除,直到运行`list-processes\u0026rsquo;命令才作删除\n非nil表示process退出时,自动删除它\n (delete-process process)  该函数主动删除process,会发送`SIGKILL\u0026rsquo;信号来关闭进程.\n参数process可以是一个process,process的名称,process关联的buffer,process关联的buffer名称.\n(delete-process \u0026#34;*shell*\u0026#34;) ; =\u0026gt; nil process的属性  命令(list-processes \u0026amp;optional query-only buffer)  该命令显示所有living process,并且会删除那些状态为`Exited\u0026rsquo;或`Signaled\u0026rsquo;的process. 该函数返回nil\n参数buffer指定了结果显示到哪个buffer中,默认为`*Process List*',它的major mode需要是Process Menu mode\n若参数query-only为非nil,则只列出那些query flag为非nil的process\n (process-list)  列出未删除掉的process的列表\n(process-list) =\u0026gt; (#\u0026lt;process display-time\u0026gt; #\u0026lt;process shell\u0026gt;)  (get-process name)  获取名称为name的process object,若没有,则返回nil\n(get-process \u0026#34;shell\u0026#34;) =\u0026gt; #\u0026lt;process shell\u0026gt;  (process-command process)  该函数返回PROCESS的执行命令. 该结果为string的列表,第一个元素为执行的program,剩下的元素为args\n(process-command (get-process \u0026#34;shell\u0026#34;)) =\u0026gt; (\u0026#34;bash\u0026#34; \u0026#34;-i\u0026#34;)  (process-contact process \u0026amp;optional key)  该函数返回serial process/network的set up的相关信息\n参数process可能为一个process,也可能一个connection\n若参数KEY为nil,则返回serial process的'(PORT SPEED)信息,或返回network process的'(HOSTNAME SERVICE)信息\n若参数KEY为t,则返回的值包含了connection,server或serial port的完整信息(即使用`make-network-process\u0026rsquo;或`make-serial-process\u0026rsquo;创建process时指定的所有keyword的值)\n若参数KEY为某个特定的keyword,则只返回对应的value\n若process为普通的child process则该函数总是返回t\n (process-id process)  获取PROCESS的pid\n (process-name process)  以string的形式返回PROCESS的名字\n (process-status process-or-name-or-buffer)  以symbol类型返回process的状态\n参数process-or-name-or-buffer必须是process,buffer或process-name中的一个.\n返回值说明如下:\n  \u0026lsquo;run\n进程正在运行\n  \u0026lsquo;stop\n进程被暂停执行,但等到时间片后会继续执行\n  \u0026lsquo;exit\n进程已经退出\n  \u0026lsquo;signal\n进程已经收到致命signal\n  \u0026lsquo;open\nprocess为network connection,该连接是open的\n  \u0026lsquo;closed\nprocess为network connection,该连接已关闭\n  \u0026lsquo;connect\nprocess为non-blocking connection,等待连接完成\n  \u0026lsquo;failed\nprocess为non-blocking connection,连接失败\n  \u0026lsquo;listen\nprocess为network server,正在监听\n  nil\nprocess不存在\n  (process-live-p process)\n  process是否alive.\n所谓alive指的它的status为\u0026rsquo;run,\u0026lsquo;open,\u0026lsquo;listen,\u0026lsquo;connect或stop\n (process-type process)  返回process的类型.\n\u0026lsquo;network表示process为network connection或server\n\u0026lsquo;serial表示process为serial port connection\n\u0026lsquo;real表示process为real subprocess\n (process-exit-status process)  返回PROCESS的exit status或被kill时的signal number. 若PROCESS没有终止运行,则返回0\n (process-tty-name process)  该函数返回PROCESS用来与Emacs交流时使用的terminal name\n若process使用pipe,则返回nil\n若process表示一个在remote host上运行的程序,则terminal name为process的peroperty `remote-tty\u0026rsquo;\n (process-coding-system process)  以\u0026rsquo;(DECODE . ENCODE)的格式描述decode process的输出时使用到编码,和encode process的输入时使用的编码\n (set-process-coding-system process \u0026amp;optional decoding-system encoding-sytem)  设置ENCODE/DECODE PROCESS的输入/输出时使用的编码规则\n (process-buffer process)  该函数返回PROCESS的关联buffer\nprocess的关联buffer有两个用处:存储process的输出内容和决定何时kill掉该process.\n关闭与process相关联的buffer,也会关闭对应的process.\n (process-mark process)  返回PROCESS的process-mark,\n默认的filter函数会将process的输出插入到关联的buffer. 插入的位置由函数`process-mark\u0026rsquo;的返回值决定,通常情况下,为buffer的尾端\n (set-process-buffer process buffer)  该函数设置PROCESS的关联buffer,若参数BUFFER为nil,则PROCESS无关联buffer\n (get-buffer-process buffer-or-name)  返回关联到该buffer的未删除process\n若有多个process关联到该buffer,则只会返回其中之一的process\n (process-filter process)  返回PROCESS的filter function\nsubprocess的stdout会传递給\u0026quot;filter function\u0026quot;来处理.\n (set-process-filter process filter)  设置PROCESS的filter function,若FILTER为nil表示使用默认的filter function\nfilter function需要接收2个参数:关联的process和输出的字符串.\n一般情况下,会在filter function中屏蔽调quitting. 否则按下C-g可能会发生无法预料的结果.\n在执行filter function时抛出的error默认情况下会自动被捕获,这样就不会影响正在执行的program. 然而若`debug-on-error\u0026rsquo;为non-nil,则error不会被自动捕获,这使得使用Lisp debugger调试filter function称为i可能.\n一个普通的filter function模板大概如下:\n(defun ordinary-insertion-filter (proc string) (when (buffer-live-p (process-buffer proc)) (with-current-buffer (process-buffer proc) (let ((moving (= (point) (process-mark proc)))) (save-excursion ;; Insert the text, advancing the process marker. (goto-char (process-mark proc)) (insert string) (set-marker (process-mark proc) (point))) (if moving (goto-char (process-mark proc))))))) Note that Emacs automatically saves and restores the match data while executing filter functions.\n另外,需要注意: 传递給filter function的输出内容,可能是任意大小的一块输出,很可能一整个句子会被拆分成很多块传递过来.\n (process-sentinel process)  返回process的sentinel\n (set-process-sentinel process sentinel)  设置process的sentinel. 若参数sentinel为nil,则使用默认的sentinel(它仅仅将message插入process buffer中)\n(defun msg-me (process event) (princ (format \u0026#34;Process: %s had the event `%s\u0026#39;\u0026#34; process event))) (set-process-sentinel (get-process \u0026#34;shell\u0026#34;) \u0026#39;msg-me) =\u0026gt; msg-me (kill-process (get-process \u0026#34;shell\u0026#34;)) -| Process: #\u0026lt;process shell\u0026gt; had the event `killed\u0026#39; =\u0026gt; #\u0026lt;process shell\u0026gt; \u0026ldquo;process sentinel\u0026quot;是一种函数,该函数在每次所关联的process的status发生改变时,都会被调用一次(包括程序退出时)\nsentinel function接收两个参数:process和描述事件类型的字符串\n其中字符串格式有下面几种:\n  \u0026ldquo;finished\\n\u0026rdquo;\n  \u0026ldquo;exited abnormally with code EXITCODE\\n\u0026rdquo;\n  \u0026ldquo;NAME-OF-SIGNAL\\n\u0026rdquo;\n  \u0026ldquo;NAME-OF-SIGNAL (core dumped)\\n\u0026rdquo;\n类似fileter function, 只有在Emacs处于waiting状态时,才会调用sentinel function.\nEmacs不会使用一个队列来保持调用sentinel的原因,它只记录当前状态和发生改变的原因. 因此若状态在很短时间内发生连续变化,只能触发一次sentinel的调用. 不过由于process终止运行后就不会再发生状态变更了,所以process终止操作总会触发一次sentinel\n每次运行process sentinel前,Emacs都会明确地检查一次process是否有输出\n若sentinel要将输出写到process buffer中时,一定要记得检查buffer是否还在,往被kill掉的buffer中写入会引发错误. 可以用`(buffer-name (process-buffer PROCESS))\u0026lsquo;是否为nil来检查buffer是否存在\nsentinel在处理quiting和error时,跟filter function一样. 默认情况下都会屏蔽quitting和自动捕获error\n在sentinel的执行期间,process的sentinel会临时设置为nil,以防止sentinel的重复调用\nNote that Emacs automatically saves and restores the match data while executing sentinels.\n  (waiting-for-user-input-p)\n  当sentinel或fileter function正在运行时,该函数返回nil.\n (process-query-on-exit-flag process)  返回PROCESS的query flag\n每个程序都由个query flag,若参数为t,则表示kill该process之前询问用户是否确定要作这项操作,默认为t\n (set-process-query-on-exit-flag process flag)  设置process的query flag\n每个process跟symbol类型,也带有自己的property list.\n (process-get process property)  获取process的property的value\n (process-put process property value)  设置process的property的值为value\n (process-plist process)  获取process的plist\n (set-process-plist process plist)  设置process的plist\n与Process的交互 Sending Input to Processes 可以使用如下命令为异步process的stdio流发送数据,在这些函数中,参数 PROCESS可以为process object或process的名称,或buffer或buffer的名称,或nil表示当前buffer的process\n  (process-send-string process string)\n給process的stdio发送string,该函数返回nil\n  (process-send-region process start end)\n将region的内容作为process的stdio\n参数START,END必须是integer或marker,否则会报错\n  (process-send-eof \u0026amp;optional process)\n传递eof到process的stdio\nprocess若为nil,则表示属于当前buffer的process\n该函数返回process\n  (process-running-child-p \u0026amp;optional process)\n该函数告诉你,process是否将对terminal的控制权交给了它的child process.\n注意: 当Emacs无法分辨时,也返回t\n  Sending Signals to Processes 每个发送signal給process的函数都接收两个可选参数:PROCESS和CURRENT-GROUP\n参数PROCESS必须为process object或process的名称或buffer或buffer name或nil(表示当前buffer的process).\n参数CURRENT-GROUP是一个标志,当运行一个job-control shell作为Emacs的subprocess时,该标志的不同值才有不同的意思.\n当参数CURRENT-GROUP的值为非nil,则信号是发送到Emacs与subprocess交互所使用的那个Terminal的process-group,而不是process的process group. 若process本身就是个job-control shell,表示中断的是shell的current subjob而不是shell本身(注意,这时Emacs是在与shell的当前job交互而不是shell交互)\n若参数CURRENT-GROUOP的值为nil,则信号发送到Emacs的直接子进程的process group. 若subproces为job-control shell,这就是shell本身\n当Emacs使用pipe与subprocess交互时,参数CURENT-GROUP是无效的.\n  (interrupt-process \u0026amp;optioal process current-group)\n发送SIGINT給process\n  (kill-process \u0026amp;optioal process current-group)\n发送SIGKILL\n  (quit-process \u0026amp;optioal process current-group)\n发送SIGQUIT\n  (stop-process \u0026amp;optioal process current-group)\n发送SIGSTP. 进程暂停后,可以使用`continue-process\u0026rsquo;再次让它运行起来\n  (continue-process \u0026amp;optioal process current-group)\n发送SIGCONT\n  命令(signal-process process signal)\n向process发信号\n参数signal必须为一个整数,或以signal为名称的symbol\n参数process除了可以使process object,process的名称,buffer,和buffer的名称外,可以为 process的pid,这允许你发送信号給非Emacs的子进程\n  Receiving Output from Process subprocess的stdout会传递給\u0026quot;filter function\u0026quot;来处理.\n默认的filter function只是简单的将内容插入到process相关联的buffer中去, 若process没有相关联的buffer,则丢弃该输出\n当subprocess结束运行后,Emacs reads any pending output, 然后就不再从subprocess中读取任何输出了,即使这时候subprocess的child process还有输出也不管.\n需要注意的是:subprocess的输出只有当Emacs处于waiting时才回被读取,即Emacs读取terminal input或调用`accept-process-output\u0026rsquo;时才会被读取.\n在某些操作系统中,当Emacs读取subprocess的输出时,输出的内容是以一小块一小块的方式被读取的,这就照成了读取的效率低下. 通过设置`process-adaptive-read-buffering\u0026rsquo;可以适当提高一些效率,因为它对这些进程进行延迟读取,等他们产生更多的输出时再读取出来.\n要区分subprocess中的stdout和stderr是不可能的,因为Emacs通常在pty中调用子进程,而pty只有一个stdout,若想区分他们,只能将其中一个重定向到文件中\n  (accept-process-output \u0026amp;optional process seconds millisec just-this-one)\n该函数允许Emacs读取PROCESS的输出.\n若参数PROCESS为非nil,则该函数会一直等待,直到从PROCESS读取到输出为止.\n参数SECONDS和MILLISEC为超时时间. 由于参数SECONDS可以是浮点型,因此参数MILLISEC不推荐使用.\n若参数PROCESS为非nil,而参数JUST-THIS-ONE为非nil,则只有该process的输出被处理. 若JUST-THIS-ONE为一个整数,则还会暂停定时器的执行\n若`accept-process-output\u0026rsquo;等待超时而没有读到任何东西,则返回nil\n  Accessing Other Processes Emacs除了可以与自己创建的subprocess交互外,也能与同机器上的其他进程交互,这些进程称为\u0026quot;System process\u0026rdquo;\n (list-system-processes)  列出所有正在运行的进程pid的list\n (process-attributes pid)  返回指定system process的属性组成的alist\n这些属性有:\n  euid\neffective user id\n  user\n  egid\nThe group id of the effective user id\n  group\n  comm\n运行该process的command\n  state\n该process的状态码\n   状态码 说明     \u0026ldquo;D\u0026rdquo; uninterruptible sleep (usually I/O)   \u0026ldquo;R\u0026rdquo; running   \u0026ldquo;S\u0026rdquo; interruptible sleep (waiting for some event)   \u0026ldquo;T\u0026rdquo; stopped, e.g., by a job control signal   \u0026ldquo;Z\u0026rdquo; \u0026ldquo;zombie\u0026rdquo;: a process that terminated, but was not reaped by its parent      ppid\n  pgrp\n  sess\nsession ID of the process\n  ttname\nprocess的控制终端的名称\n  tpgid\nThe numerical process group ID of the foreground process group that uses the process\u0026rsquo;s terminal.\n  minflt\nThe number of minor page faults caused by the process since its beginning. (Minor page faults are those that don\u0026rsquo;t involve reading from disk.)\n  majflt\nThe number of major page faults caused by the process since its beginning. (Major page faults require a disk to be read, and are thus more expensive than minor page faults.)\n  cminflt / cmajft\nLike `minflt\u0026rsquo; and `majflt\u0026rsquo;, but include the number of page faults for all the child processes of the given process.\n  utime\nprocess在user context下的运行时间(消耗CPU时间片的时间)\n  stime\nprocess在system context下的运行时间\n  time\nutime+stime\n  cutime / cstime / ctime\n类似utime,stime,time,但是包括指定process下的子进程\n  pri\n优先级\n  nice\n  thcount\nprocess中的进程数\n  start\nprocess开始的时间\n  etime\nprocess开始后,经过了多少时间\n  vsize\nprocess占用虚拟内存的大小,kb为单位\n  rss\nprocess占用物理空间的大小,kb为单位\n  pcpu\n占cpu的百分比\n  pmen\n占总物理内存的百分比\n  args\ncommand的参数\n  交易队列 通过交易队列,可以使用交易与process进行通讯.\n首先使用`tq-create\u0026rsquo;创建交易队列,然后使用`tq-enqueue\u0026rsquo;发送交易\n (tq-create process)  创建与PROCESS通讯的交易队列\n参数PROCESS必须可读写的,既可以是子进程, 也可以是网络连接.\n (tq-equeue queue question regexp closure fn \u0026amp;optional delay-question)  发送交易到队列QUEUE\n参数QUESTION为发送的消息\n参数FN为当answer回来时的回调函数. 他接收两个参数:参数CLOSURE和接收到的answer\n参数REGEXP为一个正则表达式,该正则表达式应该匹配整个完整答案结束时的文本. `tq-enqueue\u0026rsquo;使用该正则来判断answer是否已经接收完全\n若参数DELAY-QUESTION为非nil,则会暂缓question的发送,直到process对之前的question都回应完后再发送. 对某些process来说,这样会得到比较靠谱的answer\n (tq-close queue)  等待所有的交易完成,然后关闭队列\nTransaction queues的实现依靠filter function\nNetwork Process Emacs Lisp程序可以创建TCP/UDP链接(通过内建/外部支持,甚至还能创建加密的网络连接)，既能创建客户端,也能创建服务端.\nElisp把网络链接看成时跟subprocess类似的东西，也用process object来表示。当然这种process object没有pid，也不能对它发送信号什么的。\n通过调用`make-network-process‘可以创建Network connection和Network server。 该函数接受keyword参数`:server t’表示创建Network server process. `:type datagram\u0026rsquo;表示创建UDP链接\n可以通过`stop-process\u0026rsquo;和`continue-process\u0026rsquo;来stop/resume network process的操作. 对于server process来说,stop意味着不再接收新连接请求. 对于network connection来说,stop意味着不再接收输入流\n通过带参数`:server t\u0026rsquo;调用`make-network-process\u0026rsquo;创建的network server. 它接受客户端的连接请求,并创建一个新的process object表示这个新的network connection. 这个新生成的表示network connection的process object有如下几个特征:\n connection process的名称为server process的名称+客户端唯一标识 若server process没有默认的filter function,则connection process没有自己独立的process buffer. 否则Emacs为process buffer创建自己独立的buffer,buffer名称为server的buffer名称或process名称加上client的唯一标识 connection process的链接类型,filter connection和sentinel都继承至server process connection process的process contact信息根据client端的地址信息来设置 connection process的本地地址根据用于该链接的端口号决定 client process的plist初始化为server process的plist一样  创建表示网络连接/网络服务的process object   (make-network-process \u0026amp;rest args)\n该函数创建一个network connection或network server,并返回一个process object.\n这里参数args可能是以下keyword:\n :name NAME  使用NAME作为process的名称\n :type TYPE  定义链接类型. nil表示TCP链接; \u0026lsquo;datagram表示UDP链接;\u0026lsquo;seqpacket表示\u0026quot;sequenced packet stream\u0026quot;链接\n :server SERVER-FLAG  若参数为非nil,表示创建network server,否则为创建Network connection\n若为stream type server(TCP类型的server),则该参数必须为一个整数,表示最大可以等待的连接数\n :host HOST  表示要连接的host. 它可以是一个表示Internet地址的字符串,或symbol \u0026lsquo;local.\n若为Network Server指定host,则Network Client必须连接到这个HOST的请求才会被接受\n :service SERVICE  SERVICE指定了要连接的端口. 它可以是表示service名称的字符串,或者表示端口号的整数\n对于Network server.该参数还可以为t,表示让系统自己选择一个未用的port\n :family FAMILY  FAIMILY指定了链接协议的种类.\nnil表示由系统自动选择.\n\u0026lsquo;local表示为Unix socket,这种情况下:host参数可以被忽略\n\u0026lsquo;ipv4或\u0026rsquo;ipv6表示使用IPv4和IPv6\n :Local LOCAL-ADDRESS  对于Network Server. LOCAL-ADDRSS为监听的地址.\n该参数会覆盖FAMILY,HOST和SERVICE的值\n其中LOCAL-ADDRESS的格式根据FAMILY的不同而不同\n  IPv4的地址使用一个5元素的vector表示[A B C D Port]\n  IPv6的地址使用一个9元素的vector表示[A B C D E F G H Port]\n  本地地址使用字符串表示\n  :remote REMOTE-ADDRESS\n  对于Network connection来说REMOTE-ADDRESS为要连接到的地址. 该参数会覆盖FAMILY,HOST和SERVICE\n对于UDP Server来说,REMOTE-ADDRESS指定了remote datagram address的初始设置\nREMOTE-ADDRESS的格式参见LOCAL-ADDRESS的格式\n :nowait BOOL  若BOOL为非nil,则对于TCP connection来说,函数不等待连接完成就返回.\n当链接连接成功或失败后,会调用process的sentinel function\n :stop STOPPED  若STOPPED为非nil,则创建的network connection或network server处于stopped状态\n :buffer BUFFER  使用BUFFER作为process buffer\n coding CODING  设置process的编码,格式为\u0026rsquo;(DECODING ENCODING)\n :noquery QUERY-FLAG  初始化process的query flag,若为非nil,则在delete 该process时会提升用户确认\n :filter FILTER  初始化process的filter function\n :filter-multibyte MULTIBYTE  若MULTIBYTE为非nil,则传递给process filter function的字符串为multbyte格式的.否则为unibyte格式的.\n默认为参数`enable-multibyte-characters\u0026rsquo;的值\n :sentinel SENTINEL  初始化process的sentinel\n :log LOG  初始化Network server的log function.\n每次server接受一次client发起的连接请求就会调用一次log function.\n传递给log function的参数有:SERVER,CONNECTION和MESSAGE\n :plist PLIST  初始化process的plist\n下面的参数是专为network connection使用的\n :bindtodevice DEVICE-NAME  指定绑定到哪张网卡,只有从该网卡接受到的报文才会被处理,若DEVICE-NAME为nil,表示任何网卡\n broadcast BROADCAST-FLAG  对于datagram process来说,若BROADCAST-FLAG为非nil,则process会接受发送到广播域的UDP报文,也能将UDP报文发送到广播域\n对TCP 链接无效\n :dontroute DONTROUTE-FLAG  若DONTROUTE-FLAG为非nil,则表示不由路,及只能发送报文给统一网段的地址\n :keepalive KEEPALIVE-FLAG  若为TCP链接,且KEEPALIVE-FLAG为非nil,则开启low-level keep-alive messages交换功能\n linger LINGER-ARG  若LINGER-ARG为非nil,则会在关闭链接前会等待链路上的报文都转发成功后才关闭.\n若LINGER-ARG为整数,它表示等待报文转发的最大时间.\n默认参数nil表示关闭链接时直接丢弃所有未转发的报文\n :oobinline OOBINLINE-FLAG  若为TCP链接,且OOBINLINE-FLAG为非nil,则接受out-of-band数据包\n :priority PRIORITY  设置数据包的优先级,为整数.\n该参数与系统,协议都相关\n :reuseaddr REUSEADDR-FLAG  该参数对stream server process生效.\n默认REUSEADDR-FLAG为非nil,表示该服务可以立刻重用指定的端口.\n若REUSEADDR-FLAG为nil,表示在一个进程使用了指定端口后,一段时间内该端口不能被其他进程所使用.\n  (set-network-process-option process option value \u0026amp;optional no-error)\n设置已存在network process的网络属性,可设置的属性参见`make-network-process\u0026rsquo;中的属性(但不包括reuseaddr属性)\n若参数NO-ERROR为非nil,则当设置的参数不支持时不会抛出error,只返回nil\n若设置成功,则返回t\n  (open-network-stream name buffer host service \u0026amp;rest parameters)\n该函数创建一个TCP连接(可选择加密),并返回一个process object\n参数NAME表示该process object的名称,若有重复名称则会自动添加编号\n参数BUFFER为与该connection相连的buffer. 默认情况下connection的输出会插入到该buffer中. 若BUFFER为nil表示没有连接的buffer\n参数HOST和SERVICE指明了要连接的服务端的地址和端口. 其中host为字符串类型,SERVICE可以为字符串也可以为整数\n剩下的参数PARAMETERS,是各种keyword参数:\n  :nowait BOOLEAN\n若为飞nil,则表示创建异步连接\n  :type TYPE\n连接的类型.\n   TYPE 说明     plain 普通的,未加密的链接   tls / ssl TLS链接   nil / network 自动决定类型. 若系统支持参数:success和:capability-command,则先尝试通过STARTTLS建立加密链接,若失败了,使用普通的未加密链接   starttls 类似nil,但是若通过STARTTLS创建链接失败了,则关闭该链接   shell shell connection      :always-query-capabilities BOOLEAN\n若为非nil,则总是询问server端能支持的特性,及时创建的只是普通的链接\n  :capability-command CAPABILITY-COMMAND\n定义查询server端支持特性时的命令串\n  :end-of-command REGEXP\n匹配command结束的正则表达式\n  :end-of-capability REGEXP\n匹配CAPABILITY-COMMAND命令串结束的正则表达式,默认为:end-of-command的值\n  :starttls-function FUNCTION\n该function应该能接收一个参数,该参数为服务端对CAPABILITY-COMMAND的回应.\n该function应该返回nil或激活STARTTLS的命令\n  :success REGEXP\n使用该正则表达式来判断是否正常开启STARTTLS特性\n  :use-starttls-if-possible BOOLEAN\n若值为非nil,计时Emacs没有内建TLS支持,也尝试开启STARTTLS特性\n  :client-certificate LIST-OR-T\n可以以\u0026rsquo;(KEY-FILE CERT-FILE)的格式明确指明了certificate key file和certificate file的地址\n或者t表示通过查询`auth-source\u0026rsquo;来获取信息\n  :return-list CONS-OR-NIL\n指明`make-network-stream\u0026rsquo;的返回值.\n若为nil则返回process object\n否则返回\u0026rsquo;(PROCESS-OBJECT . PLIST). 其中PLIST包含如下keyword:\n  :greeting STRING-OR-NIL\n表示服务端返回的欢迎信息\n  :capabilities STRING-OR-NIL\n表示服务端的支持的特性信息\n  :type SYMBOL\n链接的类型,可能为\u0026rsquo;plain或\u0026rsquo;tls\n      (process-datagram-address process)\n若PROCESS为UDP connection或UDP server. 则该函数返回remote peer address\n  (set-process-datagram-address process address)\n若PROCESS为UDP connection或UDP server. 则该函数设置remote peer address为ADDRESS\n  测试Network特性 要测试本机上的make-network-process支持哪些特写特性,可以使用`featurep\u0026rsquo;函数:\n(featurep \u0026#39;make-network-process \u0026#39;(KEYWORD VALUE)) 它表示`make-network-process\u0026rsquo;时KEYWORD的值是否为VALUE\n下面是一些例子\n   KEYWORD VALUE PAIRS 说明     (:nowait t) Non-`nil\u0026rsquo; if non-blocking connect is supported.   (:type datagram) Non-`nil\u0026rsquo; if datagrams are supported.   (:family local) Non-`nil\u0026rsquo; if local (a.k.a. \u0026ldquo;UNIX domain\u0026rdquo;) sockets are supported.   (:family ipv6) Non-`nil\u0026rsquo; if IPv6 is supported.   (:service t) Non-`nil\u0026rsquo; if the system can select the port for a server.    也可以使用如下格式的form来测试指定的network选项是否能设置\n(featurep \u0026#39;make-network-process \u0026#39;KEYWORD) 其他Network函数 这里的函数,需要操作系统的支持.\n  (network-interface-list)\n该函数返回当前机器中各网卡的描述列表.\n该列表的格式为一个由\u0026rsquo;(NAME . ADDRESS)组成的alist\n(network-interface-list) ;; (\u0026#34;wlan3\u0026#34; . [192 168 8 113 0]) (\u0026#34;lo\u0026#34; . [127 0 0 1 0])   (network-interface-info interface-name)\n该函数返回指定网卡的信息.\n该信息是一个格式格式为\u0026rsquo;(ADDR BROADECAST-ADDR NETMASK HARDWARE-ADDR FLAGS)的list\n(network-interface-info \u0026#34;wlan3\u0026#34;) ;; ( ;; [192 168 8 113 0] ;; [192 168 8 255 0] ;; [255 255 255 0 0] ;; (1 . [8 16 120 53 33 177]) ;; (multicast running broadcast up))   (format-network-address address \u0026amp;optional omit-port)\n该函数将lisp格式的网络地址转换为字符串表示\n参数OMIT-PORT表示转换时是否不带端口信息\n  Serial Port Process 通过`make-serial-process\u0026rsquo;创建serial port process可以与serial port通讯\nserial port process可以通过`serial-process-configure\u0026rsquo;实时的修改配置,而不用关闭后重新连接.\n (make-serial-process \u0026amp;rest args)  该函数创建serial port process及其相关连的buffer. 在内部会使用函数`serial-process-configure\u0026rsquo;进行真正的配置工作\nargs可以是如下keyword参数:\n  :port PORT\nserial port的名称(Unix下为/dev/ttyS0,Win下为COM1或\\\\.\\COM10)\n  :speed SPEED\nserial port的速率\n  :name NAME\nprocess的名称,可能会添加后缀以保证唯一\n  :buffer BUFFER-OR-NAME\n相关连的buffer,若忽略该参数则与:name的参数值一样\n  :coding CODING\n读取的编码格式,参数格式为\u0026rsquo;(DECODING . ENCODING)\n  :noquery QUERY-FLAG\n初始化process的query flag. 决定被关闭时是否提示用户确认\n  :stop BOOL\n创建的process是否一开始就处于stopped状态,这是process不能接受数据,但是可以发送数据\n  :filter FILTER\n设置rocess filter function\n  :sentinel SENTINEL\n设置process的sentinel\n  :plist PLIST\n设置process的初始plist\n  :bytesize BYTESIZE\n设置每个byte包含多少bit,可以为7或8. 默认为8\n  :parity PARITY\n可以为nil,\u0026lsquo;odd或\u0026rsquo;even\n  :stopbits STOPBITS\n每个byte中用于终止传输的stopbit的位数. 可以是1或2. 默认为1\n  :flowcontrol FLOWCONTROL\nflow的类型决定了如何使用该链接. 可以是nil(不使用流控制特性),\u0026lsquo;hw(使用RTS/CTS硬件流控制),\u0026lsquo;sw(使用XON/XOFF软件流控制)\n  可以通过函数`process-conntact\u0026rsquo;查看那些参数可以被修改.\n (serial-process-configure \u0026amp;rest args)  重新设置serial port process的属性\n操作系统相关 Emacs启动说明 Emacs启动流程   搜索`load-path\u0026rsquo;中的各个目录,看是否存在`subdirs.el\u0026rsquo;这个文件,有则执行该文件.\n`subdirs.el\u0026rsquo;这个文件正常情况下是由Emacs在安装时自动生成的,它的作用是加载目录中的各个子目录到`load-path\u0026rsquo;中,并且递归执行子目录中的`subdirs.el\u0026rsquo;文件\n  在`load-path\u0026rsquo;中的各目录中寻找`leim-list.el\u0026rsquo;并加载\n`leim-list.el\u0026rsquo;这个文件被用来注册输入法. 并且Emacs在搜索`leim-list.el\u0026rsquo;时会跳过那些存放Emacs自带库的目录.\n  设置变量`before-init-time\u0026rsquo;的值为当前时间. 设置变量`after-init-time\u0026rsquo;为nil,表示Emacs还未初始化完成.\n  根据`LANG\u0026rsquo;环境变量设置language environment 和 the terminal coding system\n  对命令行参数进行基本的处理,这一步处理掉的是emacs本身支持的那些参数.\n  若不是运行在batch模式下,Emacs根据`initial-window-system\u0026rsquo;的值来为不同的窗口系统进行不同的初始化.\n某个窗口系统分别加载哪个初始化函数,是根据变量`window-system-initialization-alist\u0026rsquo;来决定的.\n存放初始化函数的文件路径应该为`term/窗口系统类型-win.el\u0026rsquo;中\n  触发`before-init-hook\u0026rsquo;\n  在可以的情况下,创建图形化的frame.\n若设置了参数`\u0026ndash;batch\u0026rsquo;或`\u0026ndash;daemon\u0026rsquo;或`\u0026ndash;script\u0026rsquo;则直接跳过这一步\n  初始化最初的frame的显示界面,如果需要的话,还会设置菜单栏和工具栏.\n若系统支持图形化的frame,则不管当前frame是否为图形化的frame,都会去设置工具栏,因为在后面的操作中有可能再次创建图形化frame\n  使用函数`custom-reevaluate-setting\u0026rsquo;来重新初始化变量`custom-delayed-init-variables\u0026rsquo;中的各成员的值.\n  若`site-start\u0026rsquo;库存在,则加载之.\n但若设置了参数`-Q\u0026rsquo;或`\u0026ndash;no-site-file\u0026rsquo;则跳过这一步\n  加载用户的初始化文件,用户初始化文件可能是`~/.emacs\u0026rsquo;,`~/.emacs.el\u0026rsquo;,`~/.emacs.d/init.el\u0026rsquo;\n但若设置了参数`-q\u0026rsquo;,`-Q\u0026rsquo;或`\u0026ndash;batch\u0026rsquo;则跳过这一步\n  若`default\u0026rsquo;库存在,则加载之.\n但若变量`inhibit-default-init\u0026rsquo;为非nil,或设置了参数`-q\u0026rsquo;,`\u0026ndash;batch\u0026rsquo;则跳过这一步\n  尝试从变量`abbrev-file-name\u0026rsquo;变量指定的文件中加载缩写配置信息.\n若设置了参数`\u0026ndash;batch\u0026rsquo;,则跳过这一步\n  若`package-enable-at-startup\u0026rsquo;为非nil,则Emacs调用函数`package-initialize\u0026rsquo;来激活所有的已安装的第三方Emacs Lisp包. 具体参见Packaging Basics\n  设置变量`after-init-time\u0026rsquo;的时间为当前时间,表示初始化过程已经完成\n  触发`after-init-hook\u0026rsquo;\n  若`*scratch*\u0026rsquo; buffer存在,且出于Fundamental mode下,则根据变量`initial-major-mode\u0026rsquo;的值却换Major Mode\n  若在文本终端环境启动的Emacs,则还会加载与终端相关的lisp library,并触发`tty-setup-hook'\n  若`inhibit-startup-echo-area-message\u0026rsquo;为nil,则在echo area显示初始信息\n  处理尚未被处理的命令行参数,这一步处理的是用户自定义的参数\n  若设置了参数`\u0026ndash;batch\u0026rsquo;则此时退出\n  若`initial-buffer-choice\u0026rsquo;为字符串,则访问该字符串所表示的文件/目录\n若为函数,则不带参数调用该函数,并根据返回结果选择显示哪个buffer\n若`*scratch*' buffer存在且无内容,则插入`initial-scratch-message\u0026rsquo;变量值到buffer中\n  触发`emacs-startup-hook'\n  调用`frame-notice-user-settings',该函数根据初始化文件修改选中的frame参数\n  触发`window-setup-hook'\n  显示`startup screen' buffer\n但若`inhibit-startup-screen\u0026rsquo;或`inital-buffer-choice\u0026rsquo;为非nil,或设置了`\u0026ndash;no-splash'/`-Q\u0026rsquo;命令行参数,则跳过这一步\n  若设置了选项`\u0026ndash;daemon',则调用`server-start\u0026rsquo;函数,并从控制终端相分离(参见Emacs Server)\n  若Emacs由X Session Manager调起,则会调用`emacs-session-restore\u0026rsquo;函数,调用参数为之前X Session的ID\n  Emacs相关初始化文件 用户初始化文件可能是`~/.emacs',`~/.emacs.el',`~/.emacs.d/init.el'\n有些Emacs会有一个名为`default.el\u0026rsquo;的默认初始化文件,若在`load-path\u0026rsquo;中能找到该文件的话,则当启动Emacs,会加载该文件.\n个人用户的初始化文件优先级比`default.el\u0026rsquo;的要高, 若在加载个人初始化文件时将`inhibit-default-init\u0026rsquo;设置非nil,则不再加载`default.el\u0026rsquo;了\n当然`-q\u0026rsquo;和`-Q\u0026rsquo;参数,使得Emacs既不加载个人初始化文件,也不加载默认初始化文件\n还有一个配置site相关的初始化文件叫做`site-start.el',Emacs在加载用户初始化文件前会加载该文件,但你可以通过参数`\u0026ndash;no-site-file\u0026rsquo;来跳过加载该文件\n  配置项site-run-file\n该变量指定了与site相关配置的初始化文件的文件名,默认为`site-start'\nThe only way you can change it with real effect is to do so before\n  配置项`inhibit-default-init'\n该变量指定是否不加载默认初始化文件`default.el',默认为nil表示加载\n  before-init-hook\n在加载所有的初始化文件(`site-start.el',个人初始化文件,`default.el')前触发\n  after-init-hook\n加载完所有的初始化文件后,在加载与终端相关library前(若在文本终端下启动的Emacs)或处理命令行参数前触发\n  emacs-startup-hook\n在处理完命令行参数后触发\n若在batch模式下,Emacs不触发该hook\n  window-setup-hook\n类似`emacs-startup-hook',但是它触发的时间要晚一点,在设置完frame参数之后触发\n  user-init-file\n该参数的值为用户初始化文件的绝对路径名. 若实际加载的初始化文件为.elc文件,则该值为相应的源代码路径\n  user-emacs-directory\n该参数的值为`.emacs.d\u0026rsquo;目录的路径. 除了MS-DOS平台,其他平台上该值都是`~/.emacs.d'\n  终端相关的library Emacs在不同类型的终端下启动时,都会加载不同的终端相关的library. 该library的名字由`term-file-prefix\u0026rsquo;变量的值(默认为\u0026quot;term/\u0026quot;)与终端类型(通常由环境变量`TERM\u0026rsquo;表示)组合而成.\n该terminal-specific librar的作用常用来使得Emacs能够识别special keys. 若操作系统的Termcap或Terminfo项无法完全识别所有的终端功能键,则可以需要修改变量`input-decode-map\u0026rsquo;的值\n若终端类型名中包含`-\u0026lsquo;或`',且使用改名字查找library时未找到,则会尝试去除终端名中最后那个`\u0026lsquo;或`-\u0026lsquo;部分后,作为终端名称在此查询library.\n可以在初始化文件中通过设置`term-file-prefix\u0026rsquo;为nil,以阻止Emacs加载terminal specific library\n在Emacs完成初始化文本终端后,会触发`tty-setup-hook\u0026rsquo;,You could use this hook to define initializations for terminals that do not have their own libraries.\n  term-file-prefix\n若变量为nil表示不加载终端初始化文件. 否则Emacs加载名为 (load (concat term-file-prefix (getenv \u0026quot;TERM\u0026quot;)) 的文件作为初始化终端的脚本.\n  tty-setup-hook\n该hook在Emacs初始化万一个新文本终端后触发.(This applies when Emacs starts up in non-windowed mode, and when making a tty ‘emacsclient’ connection.)\n  (suspend-tty \u0026amp;optional TTY)\n参数TTY为Emacs使用的终端. 该函数挂起指定的终端,此时使用该终端的Frame依然存在,但是Emacs并不再从该终端读取任何输入,也不再更新使用该终端的frame.\n参数TTY可以使一个终端对象,也可以是一个frame(表示该frame所在的终端),或nil(表示当前frame所在的终端)\n若TTY已经出于挂起状态,该函数不做任何事情.\n该函数还会触发`suspend-tty-functions\u0026rsquo;,以终端对象作为参数来调用其中的每个函数.\n  (resume-tty \u0026amp;optional tty)\n参数TTY为之前挂起的终端设备,该函数恢复该终端,并触发`resume-tty-functions\u0026rsquo;,同样以终端对象作为参数来调用其中的每个函数.\n若TTY不处于挂起状态,则该函数不做任何事\nIf the same device is already used by another Emacs terminal, this function signals an error.\n  (controlling-tty-p \u0026amp;optional tty)\n判断TTY是否为控制终端.\n参数TTY可能是终端对象,frame(表示该frame所在的终端),或nil(表示当前frame所在的终端)\n  Emacs是如何处理命令行参数的 当使用emacs \u0026ndash;script xxx.el args时,为了获取command-line参数,可以在xxx.el中使用变量`argv`获取参数列表\n  (command-line)\n该函数解析调用Emacs时的command line,处理该command line,加载用户初始化文件,然后显示启动信息\n  command-line-processed\n该变量标识了,comand line是否已经被处理过了, 若处理过了则该值为t\n当通过`dump-emacs\u0026rsquo;函数来redump Emacs时,常常会先将该变量设为nil,这样可以让新dumped Emacs会去再一次处理它的command-line arguments\n  command-switch-alist 该变量是素为`(option . handler-function)\u0026lsquo;的alist. 这里\n  option为command-line argument中的`-option\u0026rsquo;参数(带-),为字符串格式\n  handler-function为相应的处理函数名,它接收option为参数\n  若command line option后还带了其他参数,则在handler-function中可以通过变量`command-line-args-left\u0026rsquo;来获取剩余的命令行参数\n  command-line-args 传递给Emacs的完整command-line argument列表\n  command-line-args-left 尚未处理的command-line argument列表. 自定义函数有时需要修改该变量\n  command-line-functions 该变量是一系列函数的列表,这些函数用来处理无法识别的command-line参数.\n每次处理一个没有特殊意义的command line argument时,该变量中的函数都会被依次调用, 直到有一个函数返回非nil的值\n这些函数被调用时并不传递参数,但在这些函数内可以通过变量`argi\u0026rsquo;获取当前待处理的command-line argument. 可以通过变量`command-line-args-left\u0026rsquo;获取尚未被处理的command line arguments.\n若某函数除了当前待处理的函数,同时也把后面的参数給处理过了,则需要把后面那些被处理过的参数从`command-line-args-left\u0026rsquo;中删除\n若某函数已经处理了当前代处理的参数,则一定记得返回非nil值. 若所有的函数都返回nil,该参数会被认为是Emacs要打开的文件名称\n  退出Emacs 退出Emacs   命令(kill-emacs \u0026amp;optional exit-data)\n该命令触发`kill-emacs-hook\u0026rsquo;,并退出Emacs进程\n参数`EXIT-DATA\u0026rsquo;若为整数,则表示Emacs进程的退出码\n参数`EXIT-DATA\u0026rsquo;若为字符串,则表示Emacs退出时输出的内容\n  kill-emacs-hook\n该hook在`kill-emacs\u0026rsquo;真正退出Emacs进程前被触发\n由于`kill-emacs\u0026rsquo;被调用的时候可能已经与用户失去了交互,因此该hook的参数不能包含与用户交互的语句.\n若需要在退出时与用户交互,使用下面的`kill-emacs-query-functions'\n  kill-emacs-query-functions\n当`save-buffers-kill-terminal'(C-x C-c)尝试退出Emacs时,它会触发该hook.\n在该hook的函数中可以继续询问用户确认是否退出. 若该hook中任何一个函数返回nil,则`save-buffer-kill-emacs\u0026rsquo;并不会真正退出Emacs,并且也不执行hook之后的函数.\n直接调用`kill-emacs\u0026rsquo;并不会触发该hook\n  挂起Emacs 在 文本终端(图形终端下无效) 中调用Emacs的情况下,可以对Emacs执行挂起操作(对于不支持挂起操作的shell来说,该功能只是临时再启动一个shell而已).\n  命令(suspend-emacs \u0026amp;optional string)\n该函数阻塞并挂起Emacs并将控制权交回给它的父进程. 当重新激活Emacs后,该函数返回nil\n该函数仅当Emacs是在控制终端下启动时才有用.to relinquish control of other tty devices, use‘suspend-tty’\n在挂起Emacs之前,你必须删除该Emacs在其他终端上的frame,否则该函数会抛出异常. 参见Multiple Terminals\n若参数string为非nil,则字符串中的每个字符都会发送到上层shell,作为 终端输入(注意:不是作为进程输出) 该输入会被shell读取并执行\n在挂起Emacs前,`suspend-emacs\u0026rsquo;会触发`suspend-hook'.在恢复Emacs后,`suspend-emacs\u0026rsquo;会触发`suspend-resume-hook'\n  suspend-hook\nEmacs挂起前触发\n  suspend-resume-hook\nEmacs恢复后触发\n  命令(suspend-frame)\n挂起当前frame.\n若出于图形界面下,则它调用函数`iconify-frame\u0026rsquo;最小化frame.\n若出于文本界面下,则根据当前frame是否出于控制终端下,而调用`suspend-emacs\u0026rsquo;或`suspend-tty'\n  操作系统环境相关  system-configureation  the standard GNU configuration name for the hardware/software configuration of your system,字符串类型\n system-type  表示操作系统类型的symbol\n  \u0026lsquo;aix\n  \u0026lsquo;berkeley-unix\n  \u0026lsquo;cygwin\n  \u0026lsquo;darwin\n  \u0026lsquo;gnu\n  \u0026lsquo;gnu/linux\n  \u0026lsquo;gnu/kfreebsd\n  hpux\n  irix\n  ms-dos\n  usg-unix-v\n  windows-nt\n  配置项mail-host-address\n  email地址,若该参数为非nil,则会用来替代`system-name\u0026rsquo;作为email地址.\n 命令(getenv var \u0026amp;optional frame)  获取环境变量VAR的值.若找不到对应的环境变量,返回nil\n参数VAR为字符串\n在Emacs中环境变量存放在变量`process-environment\u0026rsquo;中\n 命令(setenv variable \u0026amp;optional value substitute)  该命令设置环境变量VARIABLE的值为VALUE,返回VARIABLE的新值或nil(表示从环境中删除该变量)\n参数VARIABLE为字符串类型,VALUE可以为nil或字符串\n若VALUE为nil或忽略(interactively with prefix argument)时,`setenv\u0026rsquo;从环境变量中删除VARIABLE, 这时`setenv\u0026rsquo;返回被删除的VARIABLE\n若参数SUBSTITUTE为非nil,Emacs调用函数`substitute-env-vars\u0026rsquo;来扩展环境变量的值为VALUE(什么意思??)\n process-environment  保持了系统变量的值,`getenv\u0026rsquo;和`setenv\u0026rsquo;都是通过设置改变量的值进行的.\n在实际应用中,经常会用let form临时改变该参数的值\n若参数中包括了重复的元素,则只有地一个元素生效\n initial-environment  改变了存储的是Emacs从父进程中集成到的环境变量\n path-separator  在搜索路径变量(PATH)中分隔各路径的分隔符. unix类操作系统为\u0026quot;:\u0026quot;,win下为\u0026quot;;\u0026quot;\n (parse-colon-path path)  接受搜索路径的字符串($PATH的值),并根据path-separator进行分割,返回各个目录组成的list\n(parse-colon-path \u0026#34;:/foo:/bar\u0026#34;) ;; =\u0026gt; (nil \u0026#34;/foo/\u0026#34; \u0026#34;/bar/\u0026#34;)  invocation-name  调用的Emacs可执行文件的名称,不包括目录名称\n invocation-directory  调用的Emacs,可执行文件所在的目录,若无法决定,则返回nil\n installation-directory  若为非nil,则指定了当Emacs无法在标准安装路径下找`lib-src\u0026rsquo;和`etc\u0026rsquo;子目录时,Emacs应该到在哪个目录下查找`lib-src\u0026rsquo;和`etc\u0026rsquo;子目录.\n (load-average \u0026amp;optional use-float)  返回最近1分钟,5分钟和15分钟的系统负载\n默认情况下该函数返回的值为百分比,但若参数use-float为非nil,则直接使用小数代替\n(load-average) ;; =\u0026gt; (169 48 36) (load-average t) ;; =\u0026gt; (1.69 0.48 0.36)  (emacs-pid)  emacs的pid\n tty-erase-char  该变量存储的是在Emacs启动前,系统d额终端驱动所选择的删除键\n用户信息  (user-login-name \u0026amp;optional uid) / user-login-name  获取username\n若环境变量`LOGNAME\u0026rsquo;或`USER\u0026rsquo;有值,则返回该值. 否则根据 effective UID(而不是real UID) 计算该值\n (user-real-login-name) / user-real-login-name  该函数根据Emacs的real UID计算用户名,而不管`LOGNAME\u0026rsquo;,`USER\u0026rsquo;和effective UID\n (user-full-name \u0026amp;optional uid) / user-full-name  该函数获取用户的全名\n若环境变量`NAME\u0026rsquo;有值,则返回它.\n若Emacs进程的uid不属于任何已知用户,则返回\u0026quot;unkown\u0026quot;\n参数uid可以为nil,或一个表示uid的数字或一个表示登录名的字符串. 若根据指定的uid无法找到名称,则返回nil\n (user-real-uid)  用户的real uid,若uid太大了超过整数的范围,则可能使用浮点数\n (user-uid)  用户的effective uid\n (group-gid)  Emacs进程的effective GID\n (group-real-gid)  Emacs进程的real GID\n (system-users)  列出该系统所有的用户名列表.\n若Emacs不能获取到这些信息,则返回只包含`user-real-login-name\u0026rsquo;的列表\n(system-users) ;;(\u0026#34;cl-builder\u0026#34; \u0026#34;dictd\u0026#34; \u0026#34;statd\u0026#34; \u0026#34;dnsmasq\u0026#34; \u0026#34;memcache\u0026#34; \u0026#34;sshd\u0026#34; \u0026#34;ftp\u0026#34; \u0026#34;mysql\u0026#34; \u0026#34;Debian-exim\u0026#34; \u0026#34;lujun9972\u0026#34; \u0026#34;saned\u0026#34; \u0026#34;hplip\u0026#34; \u0026#34;speech-dispatcher\u0026#34; \u0026#34;rtkit\u0026#34; \u0026#34;pulse\u0026#34; \u0026#34;kernoops\u0026#34; \u0026#34;usbmux\u0026#34; \u0026#34;avahi\u0026#34; \u0026#34;avahi-autoipd\u0026#34; \u0026#34;whoopsie\u0026#34; \u0026#34;lightdm\u0026#34; \u0026#34;colord\u0026#34; \u0026#34;messagebus\u0026#34; \u0026#34;syslog\u0026#34; \u0026#34;libuuid\u0026#34; \u0026#34;nobody\u0026#34; \u0026#34;gnats\u0026#34; \u0026#34;irc\u0026#34; \u0026#34;list\u0026#34; \u0026#34;backup\u0026#34; \u0026#34;www-data\u0026#34; \u0026#34;proxy\u0026#34; \u0026#34;uucp\u0026#34; \u0026#34;news\u0026#34; \u0026#34;mail\u0026#34; \u0026#34;lp\u0026#34; \u0026#34;man\u0026#34; \u0026#34;games\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;sys\u0026#34; \u0026#34;bin\u0026#34; \u0026#34;daemon\u0026#34; \u0026#34;root\u0026#34;)  (system-groups)  系统中所有的用户组列表.\n若Emacs不能获取到这些信息,则返回nil\n(system-groups) ;;(\u0026#34;cl-builder\u0026#34; \u0026#34;dictd\u0026#34; \u0026#34;memcache\u0026#34; \u0026#34;ftp\u0026#34; \u0026#34;mysql\u0026#34; \u0026#34;winbindd_priv\u0026#34; \u0026#34;Debian-exim\u0026#34; \u0026#34;sambashare\u0026#34; \u0026#34;lujun9972\u0026#34; \u0026#34;saned\u0026#34; \u0026#34;rtkit\u0026#34; \u0026#34;utempter\u0026#34; \u0026#34;pulse-access\u0026#34; \u0026#34;pulse\u0026#34; \u0026#34;avahi\u0026#34; \u0026#34;avahi-autoipd\u0026#34; \u0026#34;ssh\u0026#34; \u0026#34;mlocate\u0026#34; \u0026#34;whoopsie\u0026#34; \u0026#34;netdev\u0026#34; \u0026#34;nopasswdlogin\u0026#34; \u0026#34;lightdm\u0026#34; \u0026#34;ssl-cert\u0026#34; \u0026#34;lpadmin\u0026#34; \u0026#34;colord\u0026#34; \u0026#34;scanner\u0026#34; \u0026#34;bluetooth\u0026#34; \u0026#34;messagebus\u0026#34; \u0026#34;fuse\u0026#34; \u0026#34;syslog\u0026#34; \u0026#34;crontab\u0026#34; \u0026#34;libuuid\u0026#34; \u0026#34;nogroup\u0026#34; \u0026#34;users\u0026#34; \u0026#34;games\u0026#34; \u0026#34;staff\u0026#34; \u0026#34;plugdev\u0026#34; \u0026#34;sasl\u0026#34; \u0026#34;video\u0026#34; \u0026#34;utmp\u0026#34; \u0026#34;shadow\u0026#34; \u0026#34;gnats\u0026#34; \u0026#34;src\u0026#34; \u0026#34;irc\u0026#34; \u0026#34;list\u0026#34; \u0026#34;operator\u0026#34; \u0026#34;backup\u0026#34; \u0026#34;www-data\u0026#34; \u0026#34;dip\u0026#34; \u0026#34;audio\u0026#34; \u0026#34;sudo\u0026#34; \u0026#34;tape\u0026#34; \u0026#34;floppy\u0026#34; \u0026#34;cdrom\u0026#34; \u0026#34;voice\u0026#34; \u0026#34;fax\u0026#34; \u0026#34;dialout\u0026#34; \u0026#34;kmem\u0026#34; \u0026#34;proxy\u0026#34; \u0026#34;man\u0026#34; \u0026#34;uucp\u0026#34; \u0026#34;news\u0026#34; \u0026#34;mail\u0026#34; \u0026#34;lp\u0026#34; \u0026#34;disk\u0026#34; \u0026#34;tty\u0026#34; \u0026#34;adm\u0026#34; \u0026#34;sys\u0026#34; \u0026#34;bin\u0026#34; \u0026#34;daemon\u0026#34; \u0026#34;root\u0026#34;) 播放声音  (play-sound sound)  播放指定SOUND.\n参数SOUND的格式为\u0026rsquo;(sound PROPERTIES\u0026hellip;),其中PROPERTIES可以是以下keyword参数\n  :file FILE\n声音文件的地址. sound-file必须是.wav或.au格式的. 可以是绝对路径或相对`data-directory\u0026rsquo;的相对路径\n  :data DATA\n表示使用DATA作为声音的内容,而不用从:file中读取.\n参数DATA必须是包含声音比特流的字符串\n  :volume VOLUME\n指定了音量的大小. 取值范围从0到1\n  :device DEVICE\n指定通过哪台设备播放声音. DEVICE为字符串\n  (play-sound-file file \u0026amp;optional volume device)\n  播放声音文件\n play-sound-functions  在播放声音前,会触发该hook. 每个函数都接受一个参数:描述sound的plist\n (set-message-beep SOUND)  设置beep蜂鸣时的声音.\n参数SOUND可以是nil,\u0026lsquo;asterisk,\u0026lsquo;exclamation,\u0026lsquo;hand,\u0026lsquo;question,\u0026lsquo;ok或\u0026rsquo;silent\nBatch Mode 在启动Emacs时若带了参数`batch\u0026rsquo;会使得Emacs进入batch mode,这种状态下的Emacs不能与用户交互,任何输出到echo area的信息都会输出到Emacs的stdout, 任何从minibufer读取的输入都被链接到Emacs的stdin中.\n该模式常用于使用Emacs来运行某个elisp程序,程序运行完成后,Emacs就退出了.\n noninteractive  该参数指明了Emacs是否运行在Batch Mode下\nSession管理 Emacs支持X Session Management Protocol,该协议用于suspend/restart应用程序. 在X window系统中,一个名为\u0026quot;session manager\u0026quot;的程序负责保持正在运行的程序的状态. 当X server关闭时,session manager会要求应用程序保存它们的状态,并推迟X server关闭直到收到应用程序的回应. 此时应用程序也可能会取消这次关闭.\n当session manager重启挂起的session时,它会引导应用程序分别加载自己保存的状态. session manager是通过给应用程序调用是添加一个特殊的参数来引导应用程序加载状态的. 对于Emacs来说,该参数为\u0026quot;\u0026ndash;smid SESSION\u0026quot;\n emacs-save-session-functions  Emacs通过调用该hook来支持状态的保存.\n当session manager通知Emacs说window系统要关闭时,Emacss会调用该hook中的函数. 每个函数调用是都不带参数,并且会将当前buffer设置为临时buffer. 最终,Emacs保持buffer到文件中,该文件被成为\u0026quot;session file\u0026quot;\n当session manager重启挂起的Emacs时,Emacs会自动通过执行函数`emacs-session-restore\u0026rsquo;来加载session file\n若`emacs-save-session-functions\u0026rsquo;中有函数返回非nil的值,则Emacs会通知Session manager取消这次关闭.\nDesktop Notificatino 若Emacs编译时开启了D-Bus支持,则通过加载`notifications\u0026rsquo;库,Emacs可以给某些操作系统发送\u0026quot;通知\u0026quot;\n (notifications-notify \u0026amp;rest params)  通过D-Bus,使用Freedesktop notification protocol发送通知,该函数返回一个整数作为通知的id\n参数params可以是如下keyword参数\n  :bus BUS\nD-Bus bus. 该参数只有在bus不是`:session\u0026rsquo;时使用\n  :title TITLE\n通知的标题\n  :body TEXT\n通知的内容. 某些notification server甚至支持HTML标签\n  :app-name NAME\n发送通知的应用程序名称. 默认为`notifications-application-name\u0026rsquo;\n  :replaces-id ID\n表示该通知要替代指定id的原先通知. ID必须是之前`notifications-notify\u0026rsquo;调用的返回值\n  :app-icon ICON-FILE\n通知的图标文件. 若ICON-FILE为nil则不显示图标. 默认为`notifications-application-icon\u0026rsquo;\n  :actions (KEY TITLE KEY TITLE\u0026hellip;)\n一系列要应用的动作. KEY和TITLE都是字符串. 其中TITLE会在通知上以按钮的形式展现.\n若要设置默认动作(通常该动作在点击notification时触发)的key为\u0026quot;default\u0026quot;.\n  :timeout TIMEOUT\n显示多少毫秒后自动关闭. 默认值-1表示超时时间遵照notification server的设置. 0表示无限时间\n  :urgency URGENCY\n紧急的级别. 可以是\u0026rsquo;low,\u0026lsquo;normal或\u0026rsquo;critical\n  :action-items\n若设置了该关键字,则TITLE string of the action也被解释为icon name\n  :category CATEGORY\n通知的类型,字符串格式\n  :desktop-entry FILENAME\nThis specifies the name of the desktop filename representing the calling program, like `\u0026ldquo;emacs\u0026rdquo;\u0026rsquo;.\n  :image-data (WIDTH HEIGHT ROWSTRIDE HAS-ALPHA BITS CHANNELS DATA)\n这是一个raw data 图像格式描述了宽,高,rowstride,是否有alpha通道,每个sample的比特数,通道和图像数据\n  :image-path PATH\nPATH为一个URI(目前只支持\u0026quot;file\u0026quot;类型)或\u0026quot;$XDG_DATA_DIRS/icon\u0026quot;目录下的某个icon theme的名称\n  :sound-file FILENAME\n弹出通知时,播放声音文件\n  :sound-name NAME\n\u0026ldquo;$XDG_DATA_DIRS/sound\u0026quot;目录下定义的sound theme\n  :suppress-sound\n若设置了,则不播放任何声音.\n  :resident\n若设置了该参数,则即使对该通知做了动作,该通知也不会自动关闭,除非明确的对该通知发出关闭操作\n  :transient\n若设置了该参数,则server会认为该通知是暂时的,而忽略server的持久化能力(?When set the server will treat the notification as transient and by-pass the server\u0026rsquo;s persistence capability, if it should exist?)\n  :x POSITION / :y POSITION\n定义通知在屏幕上的显示位置\n  :on-action FUNCTION\n当按下了表示action的按钮时,会调用该函数. 该函数接受两个参数:notification id和action key\n  :on-close FUNCTION\n当通知因为超时或人为关闭时调用该函数. 该函数接受两个参数:notification id和关闭的REASON.\n函数中的REASON参数可以是:\n \u0026lsquo;expired  由于超时而关闭\n \u0026lsquo;dismissed  被人为关闭\n \u0026lsquo;close-notification  通过调用`notifications-close-notification\u0026rsquo;函数来关闭\n \u0026lsquo;undefined  notification server未告知原因\n(defun my-on-action-function (id key) (message \u0026#34;Message %d, key \\\u0026#34;%s\\\u0026#34; pressed\u0026#34; id key)) ;; =\u0026gt; my-on-action-function (defun my-on-close-function (id reason) (message \u0026#34;Message %d, closed due to \\\u0026#34;%s\\\u0026#34;\u0026#34; id reason)) ;; =\u0026gt; my-on-close-function (notifications-notify :title \u0026#34;Title\u0026#34; :body \u0026#34;This is \u0026lt;b\u0026gt;important\u0026lt;/b\u0026gt;.\u0026#34; :actions \u0026#39;(\u0026#34;Confirm\u0026#34; \u0026#34;I agree\u0026#34; \u0026#34;Refuse\u0026#34; \u0026#34;I disagree\u0026#34;) :on-action \u0026#39;my-on-action-function :on-close \u0026#39;my-on-close-function) ;; =\u0026gt; 22 这时会弹出一个message window. 按下 \u0026#34;I agree\u0026#34; ;; =\u0026gt; Message 22, key \u0026#34;Confirm\u0026#34; pressed ;; Message 22, closed due to \u0026#34;dismissed\u0026#34;   (notifications-close-notification notification-id \u0026amp;optional bus)\n关闭指定id的通知. 参数BUS可以是一个表示D-Bus连接的字符串.默认为:session\n  (noifications-get-capabilities \u0026amp;optional bus)\n返回notification server支持的特性的列表.\n它的返回值是一个由sybmol组成的list:\n :actions  The server will provide the specified actions to the user\n :body  支持定义Body的内容\n :body-hyperlinks  body中支持超链接\n :body-images  body中支持嵌入图片\n :body-markup  支持在body中嵌入标记\n :icon-muti  server会把图片数组中的每帧整合成一个动画\n :icon-static  server只显示图片数组中的地一个帧图片,该参数与:icon-multi互斥\n persistence  支持通知的持久化\n :sound  支持播放声音\n  (notifications-get-server-information)\n以字符串列表的形式返回notification server的信息.\n返回值的格式为\u0026rsquo;(NAME VENDOR VERSION SPEC-VERSION). 其中:\n  NAME 为server的产品名称\n  VENDOR 为vendor名称. 常见的有\u0026quot;KDE\u0026quot;和\u0026quot;GNOME\u0026rdquo;\n  VERSION 为server的版本号\n  SPEC-VERSION 为The specification version the server is compliant with\n    File Notification 若编译Emacs时链接了`gfilenotify\u0026rsquo;,`inotify\u0026rsquo;,`w32notify\u0026rsquo;或其他对应的库,通过加载`filenotify\u0026rsquo;库,Emacs可以监视文件系统中文件的改变.\n (file-notify-add-watch file flag callback)  为文件FILE添加监视器. 该函数返回添加的监视器的descriptor.\n若FILE无法被监视,则该函数抛出错误`file-notify-error\u0026rsquo;\n注意: 有些文件系统不能监视文件是否发生改变. 因此该函数返回非nil的值并不一定表示文件的改变一定会通知到Emacs\n参数FLAG为一个列表,指明了要监视FILE的哪些改变:\n  \u0026lsquo;change\n文件内容改变\n  \u0026lsquo;attribute-change\n文件属性改变\n  参数FILE可以是某个文件,也可以是目录. 若FILE为目录,则会监视该目录下的所有文件,但不递归监视子目录.\n当监视的事件发生时,Emacs会调用CALLBACK函数,并传递EVENT作为参数. 其中EVENT的格式为: \u0026lsquo;(DESCRIPTOR ACTION FILE [FILE1])\n其中DESCRIPTOR即为监视器的描述符\nACTION为事件描述,它的可能值有:\n \u0026lsquo;created \u0026lsquo;deleted \u0026lsquo;changed \u0026lsquo;renamed \u0026lsquo;attribute-changed  FILE和FILE1为事件发生的文件名称.\n下面是一个例子\n(require \u0026#39;filenotify) ;; =\u0026gt; filenotify (defun my-notify-callback (event) (message \u0026#34;Event %S\u0026#34; event)) ;; =\u0026gt; my-notify-callback (file-notify-add-watch \u0026#34;/tmp\u0026#34; \u0026#39;(change attribute-change) \u0026#39;my-notify-callback) ;; =\u0026gt; 35025468 (write-region \u0026#34;foo\u0026#34; nil \u0026#34;/tmp/foo\u0026#34;) ;; =\u0026gt; Event (35025468 created \u0026#34;/tmp/.#foo\u0026#34;) ;; Event (35025468 created \u0026#34;/tmp/foo\u0026#34;) ;; Event (35025468 changed \u0026#34;/tmp/foo\u0026#34;) ;; Event (35025468 deleted \u0026#34;/tmp/.#foo\u0026#34;) (write-region \u0026#34;bla\u0026#34; nil \u0026#34;/tmp/foo\u0026#34;) ;; =\u0026gt; Event (35025468 created \u0026#34;/tmp/.#foo\u0026#34;) ;; Event (35025468 changed \u0026#34;/tmp/foo\u0026#34;) [2 times] ;; Event (35025468 deleted \u0026#34;/tmp/.#foo\u0026#34;) (set-file-modes \u0026#34;/tmp/foo\u0026#34; (default-file-modes)) ;; =\u0026gt; Event (35025468 attribute-changed \u0026#34;/tmp/foo\u0026#34;) 根据不同的底层库的实现不同,rename操作可能被认为是一个rename操作或一个delete+create操作\nIt can be expected, when a directory is watched, and both FILE and FILE1 belong to this directory. Otherwise, the actions `deleted\u0026rsquo; and `created\u0026rsquo; could be returned in a random order.\n(rename-file \u0026#34;/tmp/foo\u0026#34; \u0026#34;/tmp/bla\u0026#34;) ;; =\u0026gt; Event (35025468 renamed \u0026#34;/tmp/foo\u0026#34; \u0026#34;/tmp/bla\u0026#34;) (file-notify-add-watch \u0026#34;/var/tmp\u0026#34; \u0026#39;(change attribute-change) \u0026#39;my-notify-callback) ;; =\u0026gt; 35025504 (rename-file \u0026#34;/tmp/bla\u0026#34; \u0026#34;/var/tmp/bla\u0026#34;) ;; =\u0026gt; ;; gfilenotify ;; Event (35025468 renamed \u0026#34;/tmp/bla\u0026#34; \u0026#34;/var/tmp/bla\u0026#34;) ;; =\u0026gt; ;; inotify ;; Event (35025504 created \u0026#34;/var/tmp/bla\u0026#34;) ;; Event (35025468 deleted \u0026#34;/tmp/bla\u0026#34;)  (file-notify-rm-watch descriptor)  删除指定的监视器\n动态加载 Emacs supports such on-demand loading of support libraries for some of its features.\n需要注意: 不是所有的特性都能使用这种方式动态加载\n dynamic-library-alist  该参数是一个由动态库和对应的动态库文件组成的alist.\n该alist中每个元素的格式为\u0026rsquo;(LIBRARY FILES\u0026hellip;)\n例如:\n(setq dynamic-library-alist \u0026#39;((xpm \u0026#34;libxpm.dll\u0026#34; \u0026#34;xpm4.dll\u0026#34; \u0026#34;libXpm-nox4.dll\u0026#34;) (png \u0026#34;libpng12d.dll\u0026#34; \u0026#34;libpng12.dll\u0026#34; \u0026#34;libpng.dll\u0026#34; \u0026#34;libpng13d.dll\u0026#34; \u0026#34;libpng13.dll\u0026#34;) (jpeg \u0026#34;jpeg62.dll\u0026#34; \u0026#34;libjpeg.dll\u0026#34; \u0026#34;jpeg-62.dll\u0026#34; \u0026#34;jpeg.dll\u0026#34;) (tiff \u0026#34;libtiff3.dll\u0026#34; \u0026#34;libtiff.dll\u0026#34;) (gif \u0026#34;giflib4.dll\u0026#34; \u0026#34;libungif4.dll\u0026#34; \u0026#34;libungif.dll\u0026#34;) (svg \u0026#34;librsvg-2-2.dll\u0026#34;) (gdk-pixbuf \u0026#34;libgdk_pixbuf-2.0-0.dll\u0026#34;) (glib \u0026#34;libglib-2.0-0.dll\u0026#34;) (gobject \u0026#34;libgobject-2.0-0.dll\u0026#34;))) 定时器 Emacs只有在空闲时才会调用定时器,即在等待输入,`site-for\u0026rsquo;函数和`read-event\u0026rsquo;函数时才会触发定时器.\nEmacs会在触发定时器前将`inhibit-quit\u0026rsquo;设置为t,这是因为从定时器函数中推出很容易产生不一致状态.\n通过定时器函数修改buffer会导致undo命令分不清哪些改动是人工改动的,哪些改动是触发器函数修改的. 因此一般不再定时器函数中修改buffer,若要修改,注意在修改buffer前和修改buffer后调用一次`undo-boundary\u0026rsquo;函数\n定时器函数也应该避免调用会导致Emacs等待的函数,因为这样的话又会导致其他定时器函数的处罚,可能产生无法预期的后果. 若真要等待一段时间后再执行,请再分配一个新的定时器来处罚\nIf a timer function calls functions that can change the match data, it should save and restore the match data\n 命令(run-at-time time repeat function \u0026amp;rest args)  设置等时间为TIME时,用参数ARGS调用FUNCTON函数.\n若参数repeat为某个数字,则会每隔repeat秒后执行一次. 若repeat为nil表示只执行一次\n参数TIME可以是一个相对时间或一个绝对时间:\n Absolute times may be specified using a string with a limited variety of formats, and are taken to be times today, even if already in the past. The recognized forms are `XXXX\u0026rsquo;, `X:XX\u0026rsquo;, or `XX:XX\u0026rsquo; (military time), and `XXam\u0026rsquo;, `XXAM\u0026rsquo;, `XXpm\u0026rsquo;, `XXPM\u0026rsquo;, `XX:XXam\u0026rsquo;, `XX:XXAM\u0026rsquo;, `XX:XXpm\u0026rsquo;, or `XX:XXPM\u0026rsquo;. A period can be used instead of a colon to separate the hour and minute parts.\nTo specify a relative time as a string, use numbers followed by units. For example:\n`1 min\u0026rsquo; denotes 1 minute from now.\n`1 min 5 sec\u0026rsquo; denotes 65 seconds from now.\n`1 min 2 sec 3 hour 4 day 5 week 6 fortnight 7 month 8 year' denotes exactly 103 months, 123 days, and 10862 seconds from now.\nFor relative time values, Emacs considers a month to be exactly thirty days, and a year to be exactly 365.25 days.\nNot all convenient formats are strings. If TIME is a number (integer or floating point), that specifies a relative time measured in seconds. The result of `encode-time' can also be used to specify an absolute value for TIME.\nIn most cases, REPEAT has no effect on when first call takes place\u0026ndash;TIME alone specifies that. There is one exception: if TIME is `t', then the timer runs whenever the time is a multiple of REPEAT seconds after the epoch. This is useful for functions like `display-time'.\nThe function `run-at-time' returns a timer value that identifies the particular scheduled future action. You can use this value to call `cancel-timer' (see below).\n  配置项timer-max-repeats  由于Emacs只有在空闲时才会执行定时器,这时有可能会推迟定时器的执行. 但推迟定时器执行的动作不会对下一次定时器执行的时间产生影响. 即使说,若下一次定时器函数触发的时间并不是在上一次执行时间的基础上累加的. 因此推迟的时间太长,很可能会致使连续几次执行定时器函数.\n该变量则限定了一次性定时器函数所能执行的最大的循环次数\n 命令(run-with-idle-time secs repeat function \u0026amp;rest args)  设置一个定时器,该定时器在下次Emacs空闲了SECS秒后执行\n参数SECS可以是数字,也可以是`current-dile-time\u0026rsquo;返回的对象\n若参数REPEAT为nil表示定时器只触发一次. 若为非nil表示 每次Emacs空闲时间超过SECS秒后都触发一次\n Do not write an idle timer function containing a loop which does a certain amount of processing each time around, and exits when `(input-pending-p)' is non-`nil'. This approach seems very natural but has two problems:\n It blocks out all process output (since Emacs accepts process  output only while waiting).\n It blocks out any idle timers that ought to run during that time.  Similarly, do not write an idle timer function that sets up another idle timer (including the same idle timer) with SECS argument less than or equal to the current idleness time. Such a timer will run almost immediately, and continue running again and again, instead of waiting for the next time Emacs becomes idle. The correct approach is to reschedule with an appropriate increment of the current value of the idleness time, as described below.\n  (current-idle-time)  若Emacs处于空闲状态,该函数返回Emacs空闲的时间. 格式与`current0time\u0026rsquo;一致,为(SEC-HIGH SEC-LOW MICROSEC PICOSEC\n若Emacs不处于idle状态,`current-idle-time\u0026rsquo;返回nil\n (cancel-timer timer)  取消定时器\n 宏(with-timeout (seconds timeout-forms\u0026hellip;) bodys\u0026hellip;)  执行bodys,但设置了超时时间为SECONDS秒.\n若BODY在SECONDS秒内执行完成,则`with-timeout\u0026rsquo;返回正常的bodys执行结果.\n但若BODY在执行期间超时了,则会执行timeout-forms,并返回timeout-forms的执行结果\n该宏的内部使用定时器来完成超时功能,因此若Emacs执行bodys的过程中,没有等待输入的情况,则超时的功能没什么作用.\nDired-mode相关函数  获取dired中marked file  使用函数`dired-get-marked-files`\n执行命令  执行shell命令并等待shell命令结束  (shell-command \u0026ldquo;shell命令\u0026rdquo;)\n 执行shell命令,等待shell命令结束,并获得命令的输出  (shell-command-to-string \u0026ldquo;shell命令\u0026rdquo;)\n 使用外部命令对所选择Region进行处理  shell-command-on-region\n 执行shell命令,但是不等待shell命令结束  start-process\nstart-process-shell-command\ncall-process-region\nRegister函数  将内容复制到Register中  (copy-to-register ?1 startPos endPos)\n 从Register中取出内容  (insert-register ?1 t)\nOrg相关函数  取entry属性 (org-entry-get nil \u0026ldquo;属性名\u0026rdquo; 是否继承属性) 取entry的tag list (org-get-tags) 取entry的TODO state org-get-tags 判断哪些state是完成状态 org-done-keywords 跳转到headline (org-back-to-heading) 判断是否处于clockin状态 org-clock-clocking-in clock in (org-clock-in) clock out (org-clock-out) 当前clock entry的headline org-clock-heading clock out触发的hook org-clock-out-hook 更新mode-line的内容 (org-clock-update-mode-line)  版本信息  变量emacs-version 变量emacs-major-version 变量emacs-minor-version  wait function wait function用于等待一段时间或等待input.\n (sit-for seconds \u0026amp;optional nodisp)  sit-for等待一段时间或直到收到某个input event. 在这段时间内Emacs会实时更新屏幕显示.\n若等待不是由收到input而中断的,则返回t,否则返回nil\n参数seconds可以是浮点数. (sit-for 0)等价于(redisplay),它只是立即更新屏幕显示.\n若参数nodisp为非nil,则sit-for在等价期间不会更新屏幕显示.\n在Emacs处于batch mode时,`sit-for\u0026rsquo;不能被interrupt event中断,这时等价于`sleep-for'\n (sleep-for seconds \u0026amp;optional millisec)  该函数等价seconds秒,等待期间不会被input event打断,也不会更新屏幕显示. 它总是返回nil\n参数seconds可以为浮点数.\n参数millisec表示在等待seconds秒后,再等待millisec毫秒\nPackage相关说明 Package的分类 package可以分为单文件package和多文件package. 其中单文件package在package archive中以单个elisp文件形式存在,而多文件package以tar文件形式存在.\n单文件Package 单文件package中elisp文件必须遵循elisp library header conventions 下面是一个例子\n;;; superfrobnicator.el --- Frobnicate and bifurcate flanges ;; Copyright (C) 2011 Free Software Foundation, Inc. ;; Author: J. R. Hacker \u0026lt;jrh@example.com\u0026gt; ;; Version: 1.3 ;; Package-Requires: ((flange \u0026#34;1.0\u0026#34;)) ;; Keywords: multimedia, frobnicate ;; URL: http://example.com/jrhacker/superfrobnicate ;;; Commentary: ;; This package provides a minor mode to frobnicate and/or ;; bifurcate any flanges you desire. To activate it, just type package的名称与elisp文件的base name必须一致. package名称被写到第一行. 在上例中为\u0026quot;superfrobnicator\u0026quot;\n单行描述也放在第一行,在上例中为\u0026quot;Frobnicate and bifurcate flange\u0026quot;\npackage的版本号,通过`Package-Version' header表示,若不存在`Package-Version' header则通过`Version' header标识. 该属性必须存在. 在上例中为1.3\n若文件中有`;;; Commentary:\u0026lsquo;部分,则该部分内容作为package的详细描述.\n若文件中有`Package-Requires\u0026rsquo; header,则该部分标识了package的依赖包有哪些. 若没有该header表示package不依赖其他包.\n`Keywords\u0026rsquo;与`URL\u0026rsquo;也是可选的,但一般建议添加这两个header. `describe-package\u0026rsquo;函数会展示这两个header中的值. `Keywords' header应该至少包含一个`finder-known-keywrods\u0026rsquo;中的标准keyword\n多文件Package 多文件package不像单文件package那样有那么多的规范.\n多文件package在package archive中以一个tar文件的形式存在. 该tar文件的名称必须是`package名-package版本.tar'.\n多文件package的content directory中必须有一个名为`package名-pkg.el\u0026rsquo;的文件. 该文件的内容为一个`define-package\u0026rsquo;函数的调用form. `define-package\u0026rsquo;函数定义了package的版本,单行描述和依赖包.\n若content directory中包含名为`README\u0026rsquo;的文件,则该文件的内容作为package的详细描述\n若content directory中包含名为`dir\u0026rsquo;的文件,则该文件被认为是通过命令`install-info\u0026rsquo;生成的Info directory文件. 同时,相关的Info文件也必须在content directory中. 这中情况下,当激活该package后,Emacs会自动将content directory添加到`Info-directory-list\u0026rsquo;中.\n不要在package中包含任何.elc文件,它们是由package安装时自动生成的.且无法控制各文件编译的顺序\n不要包含名为`package名-autoloads.el\u0026rsquo;的文件,它也是由package安装时自动生成的.\n若package中包含其他格式的文件(例如图片等),则在elisp源代码中,可以使用`load-file-name\u0026rsquo;变量值来引用存放这些文件的目录. 例如\n(defconst superfrobnicator-base (file-name-directory load-file-name)) (defun superfrobnicator-fetch-image (file) (expand-file-name file superfrobnicator-base))    (define-package name version \u0026amp;optional docstring requirements)\n该函数定义了一个名为`NAME\u0026rsquo;的package.\n参数`VERSION\u0026rsquo;为一个表示版本的字符串,该字符串的格式必须被`version-to-list\u0026rsquo;所认识.\n参数`DOCSTRING\u0026rsquo;为单行描述\n参数`REQUIREMENTS\u0026rsquo;为一个由依赖包和最低版本组成的list. 该list的每个元素应该是(DEP-NAME-symbol DEP-VERSION-string)\n  Package的属性 每个package都具有如下一些属性:\n  Name\npacakge name,常在程序中作为变量/函数名的前缀.\n  Version\n版本号,其格式必须被函数`version-to-list\u0026rsquo;所知. 每次release package都应该增加该版本号属性\n  单行简洁描述\n该描述应该只占一行,最好不超过36个字符. 该描述会在list package时展示\n  详细描述\n常常包含该package的用处,以及使用方法. 该描述会在`describe-package\u0026rsquo;中展示\n  Dependencies\n依赖关系, 该属性值为其他package的list. 该list中的每个元素可以是一个表示package的symbol或一个(package min-version)的列表.\n  package的安装说明 通过`pacakge-install-file\u0026rsquo;可以安装一个package. 安装package包含以下几个步骤:\n  在`package-user-dir\u0026rsquo;目录下创建一个名为`package名称-package版本\u0026rsquo;的目录.\n该目录用于存放package的内容的,因此也被称为\u0026quot;content direcotry\u0026quot;\n  Emacs搜索content directory中的所有elisp文件,并查找里面的autoload magic comments\n这些autoload定义被保存在名为`package名称-autoloads.el\u0026rsquo;的文件中.\n这些autoload定义通常用来自动加载package中定义的供用户使用的主要command,但也能用来作其他事情,例如王`auto-mode-alist\u0026rsquo;中添加内容\n  Emacs编译package中的所有elisp文件\n  package的加载过程 Emacs启动过程中,当Emacs加载完初始化完init file及abbrev file后,在触发`after-init-hook\u0026rsquo;前,Emacs会自动调用`package-initialize\u0026rsquo;函数来加载安装的package.\n但是Emacs加载package的过程,在变量`package-enable-at-startup\u0026rsquo;为nil时会被禁止.\nEmacs加载package的过程由两个步骤组成\n  添加package的content directory到`load-path\u0026rsquo;中\n  执行`package名-autoloads.el\u0026rsquo;中的autoload定义.\n  (package-initialize \u0026amp;optional no-activate) 该函数初始化Emacs用于记录哪些package已经安装的内部变量并加载这些package.\n用户配置项`package-load-list\u0026rsquo;指明了哪些package会被加载,默认是所有已经安装的package.\n参数`NO-ACTIVATE\u0026rsquo;若为非nil,则表示只更新已安装package的记录,而不加载这些package\nPackage Archives   配置项package-archives\n该配置项为一个alist,指明了Emacs包管理系统从哪些archive中搜索package\n该alist的每个元素的格式为(ID . LOCATION),这里ID为表示archive名称的字符串,LOCATION为表示archive地址的字符串. 目前LOCATION只能为http url或一个本地目录的路径.\n一个package archive只是一个包含了package源代码文件及其相关文件的目录而已. 若希望可以通过http获取该archive,则需要把该目录放在web server上.\n  一种设置和更新package archive的比较方便的方式是使用库`package-x',该库是Emacs自带的,但是默认情况下并不加载.\n`package-x\u0026rsquo;的相关命令与变量如下:\n  配置项pacakge-archive-upload-base\n该变量的值应为一个目录的名称,它将作为package archive的base location.\n该变量的值必须是一个 绝对路径.\n若package archive不在本地,可以使用类似`/ssh:foo@example.com:/var/www/packages/' 的形式来设置\n  (package-upload-file filename)\n该命令上传FILENAME到`package-archive-upload-base\u0026rsquo;中.\nFILENAME必须是单文件package(el文件),多多文件package(tar文件),否则会抛出错误.\n若`package-archive-upload-base\u0026rsquo;中的路径非法,则会提示用户重新输入,若路径不存在,则会自动创建该目录\n  (package-upload-buffer)\n类似`package-upload-file',只不过是将当前buffer的内容上传上去.\n该buffer必须访问一个单文件package(el文件)或多文件pacakge(tar文件),否则会抛出错误\n  ","permalink":"https://zakudriver.github.io/posts/elisp%E6%96%87%E6%A1%A3/","summary":"有三种方式可以加载文件：  load autoload require  使用eval-after-load可以推迟一段代码的执行 (eval-after-load \u0026ldquo;触发条件的文件\u0026rdquo; 待执行的代码) 这里，第一个参数的值必须跟上面三种方式加载文件时的值一模一样\nemacs中的变量作用域 buffer-local变量 声明buffer-local变量  make-variable-buffer-local  各个缓冲区都有各自的buffer-local变量\n make-local-variable  当前缓冲区产生一个局部变量,其他缓冲区仍然使用全局变量(推荐使用)\nbuffer相关函数    with-current-buffer\n;使其中的body表达式在指定的缓冲区里执行(使用指定buffer的配置信息执行body表达式) (with-current-buffer buffer body)      get-buffer\n;得到缓冲区名字的对应缓冲区对象,如果没有这个名字的缓冲区,返回nil (get-buffer buffer-name)      default-value\n;访问符号的全局变量的值 (default-value symbol)      setq-default\n;修改符号作为全局变量的值 (setq-default symbol-name)      local-variable-p\n;测试变量是不是buffer-local的 (local-variable-p symbol [buffer对象])      buffer-local-value","title":"elisp文档"},{"content":"interactive 参数的含义 若一个函数带有交互模式声明，则它是一个命令函数。即可以通过 M-x(execute-command) 来调用。\n声明格式 (defun kumo-interactive-func () (interactive \u0026#34;code-string\u0026#34;) ;; do something...) 种类  Completion: 提供补全。TAB，SPC 和 RET 完成补全。 Existing: 必须是存在的对象名。不接受无效名称。如果输入无效则不会退出 minibuffer。 Default: 如果未输入则使用默认值。 No I/O: 不读取任何输入。因此不会使用提示符。 Prompt: 放在提示符或\\n之前。 Special: 只能放在交互式字符参数前。  含义   接收多个输入以 \\n 来分隔。\n  *: 如果当前buffer处于read-only-mode时提示。 [Special]\n  @: 在第一个鼠标事件触发的window调用。[Special]\n  ^: 通过 shift 调用前需要标记区域，没有公共 shift 调用则停止标记。[Special]\n  a: 一个函数定义的符号名。[Existing, Completion, Prompt]\n(defun with-func-arg (arg) (interactive \u0026#34;aEnter a function:\u0026#34;) (funcall arg))   b: buffer名（已存在）。[Existing, Completion, Default, Prompt]\n  B: buffer名（可以不存在）。[Completion, Default, Prompt]\n  c: 字符。（接收任意输入，不用回车，不能使用输入法）。[Prompt]\n  C: 一个interactive函数的符号名。即满足(commandp xx)为t。[Existing, Completion, Prompt]\n  d: 光标位置，提供 int 类型的参数。[No I/O]\n  D: 目录。[Existing, Completion, Default, Prompt]\n  e: 必须绑定一个非键盘事件。提供event的list形式参数。Input Events [No I/O]\n(defun with-not-keyboard-event-arg (arg) (interactive \u0026#34;e\u0026#34;) (print arg)) ;; ((down-mouse-1 (#\u0026lt;window 130 on a.el\u0026gt; 2845 (664 . 365) 460355375 nil 2845 (94 . 15) nil (664 . 19) (7 . 23)))) (global-set-key (kbd \u0026#34;\u0026lt;down-mouse-1\u0026gt;\u0026#34;) \u0026#39;with-not-keyboard-event-arg)   f: 文件名（已存在）。[Existing, Completion, Default, Prompt]\n  F: 文件名（可以不存在）。[Completion, Default, Prompt]\n  G: 文件名（可以不存在），如果只输入目录名不含有文件名则使用目录名。[Completion, Default, Prompt]\n  i: 总是提供nil作为参数。[No I/O]\n  k: 按键序列。一直读取知道触发按键映射的指令，或直到没定义的按键序列。提供 string 或 vector 的参数。k 只会读取down-event事件，而忽律之后的up-event(主要是指鼠标点击后松开的event)。可以使用 U code 读取up-event事件。[Prompt]\n(kbd \u0026#34;C-x\u0026#34;) ⇒ \u0026#34;\\C-x\u0026#34; (kbd \u0026#34;C-x C-f\u0026#34;) ⇒ \u0026#34;\\C-x\\C-f\u0026#34; (kbd \u0026#34;C-x 4 C-f\u0026#34;) ⇒ \u0026#34;\\C-x4\\C-f\u0026#34; (kbd \u0026#34;X\u0026#34;) ⇒ \u0026#34;X\u0026#34; (kbd \u0026#34;RET\u0026#34;) ⇒ \u0026#34;\\^M\u0026#34; (kbd \u0026#34;C-c SPC\u0026#34;) ⇒ \u0026#34;\\C-c \u0026#34; (kbd \u0026#34;\u0026lt;f1\u0026gt; SPC\u0026#34;) ⇒ [f1 32] (kbd \u0026#34;C-M-\u0026lt;down\u0026gt;\u0026#34;) ⇒ [C-M-down]   K: 和 k 类似。改变已定义的按键序列。\n  m: mark位置。提供 int 类型的参数。[No I/O]\n  M: 任意文本。使用当前 buffer 的输入法在 minibuffer 中读取，并作为 string 返回。[Prompt]\n  n: int 类型参数。如果输入的不是 int 会提示再次输入。n 之前几乎不使用前缀参数。[Prompt]\n  N: 读取数字前缀参数。如果没有前缀参数则读取一个 int 作为参数。Prefix Command Arguments [Prompt]\n  p: 数字前缀参数。也可以不用p参数，直接在代码中判断 current-prefix-arg 的值。[No I/O]\n(defun with-num-arg (arg) (interactive \u0026#34;p\u0026#34;) (print arg)) ;; 4 (numberp arg) t (defun with-expression-arg (arg) (interactive (list (prefix-numeric-value current-prefix-arg))) (print arg)) ;; 4 (numberp arg) t ;; Same as \u0026#39;with-num-arg   P: 原始前缀参数。[No I/O]\n(defun with-num-arg (arg) (interactive \u0026#34;P\u0026#34;) (print arg)) ;; (4) (lisp arg) t   r: region 的开始/结束位置。提供两个参数(beg end)，唯一提供两个参数的code。如果调用该命令时没有触发 region 则会报错[No I/O]\n  s: 任意文本。读入 minibuffer 并作为 string 返回。使用 C-j 或 RET 终止输入。[Prompt]\n  S: 在 minibuffer 中读取输入的 interned symbol 名。使用 C-j 或 RET 终止输入。[Prompt]\n  U: 一个按键序列或者 nil。可以在 k 或 K 之后使用，以获取在 k 或 K 读取down-event后被忽略的up-event(如果有。主要是指鼠标点击后松开的event)。如果没有up-event被忽略则提供 nil 参数。[No I/O]\n  v: 一个用户声明的变量。即满足(custom-variable-p)为t。[Existing, Completion, Prompt]\n  x: 一个 list。不会被 evaluated。使用C-j 或 RET 终止输入。[Prompt]\n(defun with-list-arg (arg) (interactive \u0026#34;x\u0026#34;) (print arg)) ;; M-x with-list-arg is invoked; input (+ 1 2), print \u0026#34;(+ 1 2)\u0026#34;   x: 一个 list。会被 evaluated。使用C-j 或 RET 终止输入。[Prompt]\n(defun with-list-arg (arg) (interactive \u0026#34;X\u0026#34;) (print arg)) ;; M-x with-list-arg is invoked; input (+ 1 2), print \u0026#34;3\u0026#34;   z: 一个 code system 名(symbol)。如果输入为无效 code system，则参数为 nil。 [Completion, Existing, Prompt]\n(defun save-buffer-as-utf8 (coding-system) \u0026#34;Revert a buffer with `CODING-SYSTEM\u0026#39; and save as UTF-8.\u0026#34; (interactive \u0026#34;zCoding system for visited file (default nil):\u0026#34;) (revert-buffer-with-coding-system coding-system) (set-buffer-file-coding-system \u0026#39;utf-8))   Z: 一个 code system 名(symbol)。仅当该命令有前缀参数时，否则参数为 nil。 [Completion, Existing, Prompt]\n  ","permalink":"https://zakudriver.github.io/posts/elisp%E4%B8%AD%E7%9A%84interactive%E5%8F%82%E6%95%B0/","summary":"interactive 参数的含义 若一个函数带有交互模式声明，则它是一个命令函数。即可以通过 M-x(execute-command) 来调用。\n声明格式 (defun kumo-interactive-func () (interactive \u0026#34;code-string\u0026#34;) ;; do something...) 种类  Completion: 提供补全。TAB，SPC 和 RET 完成补全。 Existing: 必须是存在的对象名。不接受无效名称。如果输入无效则不会退出 minibuffer。 Default: 如果未输入则使用默认值。 No I/O: 不读取任何输入。因此不会使用提示符。 Prompt: 放在提示符或\\n之前。 Special: 只能放在交互式字符参数前。  含义   接收多个输入以 \\n 来分隔。\n  *: 如果当前buffer处于read-only-mode时提示。 [Special]\n  @: 在第一个鼠标事件触发的window调用。[Special]\n  ^: 通过 shift 调用前需要标记区域，没有公共 shift 调用则停止标记。[Special]\n  a: 一个函数定义的符号名。[Existing, Completion, Prompt]\n(defun with-func-arg (arg) (interactive \u0026#34;aEnter a function:\u0026#34;) (funcall arg))   b: buffer名（已存在）。[Existing, Completion, Default, Prompt]","title":"Elisp中的interactive参数"},{"content":"要点  会计政策的改变； 会计事务所出具 “标准无保留意见”； 上市时间长于5年； 某科目出现大比例变化，查看附注； 与同行对比；  关注的重点  财务会计报告 董事会报告 重要事项  财务会计报告    货币资金\n 货币资金余额比短期负债小很多； 货币资金充裕，却借了很多有息甚至高息负债； 定期存款很多，其他货币资金很多，流动资金却严重缺乏； 其他货币资金数额巨大，但没有合理解释；       经营相关资产\n 应收票据，银行承兑汇票\u0026gt;商业承兑汇票； 应收账款，增长幅度及坏账准备计提政策； 其他应收款，越小越好； 存货，存货和营业成本的合理比例；       生产相关资产\n 固定资产，年年折旧，折旧算费用； 在建工程，迟迟不转固定资产一般有鬼； 折旧 == 摊销； 无形资产，研发费用 = 机会+风险。房企，土地算存货而非无形资产 利润高的公司更愿意把研发支出都记入费用中，这样可以减少当期税收支出；反之计入无形资产凸显财报好看； 商誉：若一家企业的获利能力超过可辨认净资产的正常获利能力，超出的部分，一定是另外一种资产带来的，这个资产就被叫作“商誉”。没有进行过收购的企业商誉栏目为0。商誉不用摊销； 长期待摊费用，越小越好； 递延所得税资产，税务局收的税大于公司酸的应交税款； 递延所得税负债，税务局收的税小于公司算的应交税款； 企业净资产与真实相差甚远，如资产折旧或商誉价值；       投资相关资产\n 交易性金融资产，不折旧。以卖出产生利润收税；产生递延所得税资产和负债的重要源头。公允价值变动计入利润表； 持有至到期投资，按实际利率计算的投资收益，减值损失； 可供出售金融资产，汇兑损益，股利或利息，减值损失等公允价值变动加入净资产； 长期股权投资，分红影响利润，或经营盈亏影响利润； 买入返售金融资产，规避监管的抵押贷款； 投资性房地产，公允价值对利润和净资产影响巨大；       负债和所有人权益\n 负债，关注有息负债和现金及等价物及总资产比例； 股本和资本公积，面值算股本，股东投入超过面值的部分算资本公积； 盈余公积，法定或自愿留下来的用于扩大再生产的钱； 未分配利润，资金支配自由度高，有未分配利润不等于有现金可分；       资产负债表 企业所控制资源的多寡，决定了企业持续经营喝成长的能力\n 资产=负债+所有者权益； 负债率，同行业比较。有息负债不宜占总资产5成以上； 四个指标。生产资产/总资产，应收/总资产，货币资金/有息负债，非主业资产/总资产； 生产资产（固定资产、在建工程、工程物资以及无形资产里的土地）； 轻资产公司优于重资产公司，当期税前纯利润总额/生产资产，远高于社会资本平均回报率（按银行贷款标准利率的两倍毛估） 应收（资产负债表里应收科目-应收票据里的银行承兑汇票）/总资产，同行比较，越小越好，不宜超过三成； 货币资金/有息负债，是否有债务危机，货币资金应该覆盖有息负债； 非主业资产/总资产，是否将注意力放在所在行业。比值增大说明行业内已经很难有较大投资潜力；       利润表 企业当前经营的成果\n P（股价）=PE（市盈率）*E（每股收益）； 戴维斯双击，10倍市盈率以下，经营业绩增长率10-15%的企业； 收入确认规则； 利润三因素，毛利率（茅台模式）、周转率（沃尔玛模式）、经营杠杆（银行模式）； 主营业务单一为主； 资产减值损失，不提或少提增加当期利润，多提减少当期利润，一次性计提减少后期折旧和摊销从而增加后期财报利润； 营业利润=营业总收入-营业总成本（销售费用+管理费用+财务费用+资产减值损失+-（公允价值变动损益+投资收益+汇兑收益））； 净利润=营业利润+营业外收支净额-所得税； 经营现金流净额/净利润 常年大于1最佳； 毛利润=营业收入-营业成本，毛利率=毛利润/营业收入，毛利率最好高于40%； 费用率=三费（销售费用+管理费用+财务费用）/营业总收入； 费用/毛利润 超过70%关注价值不大； 营业利润率=营业利润/营业收入； 确认净利润是否变成现金回到公司账户，经营现金流净额/净利润，持续大于1最佳，说明供不应求，先款后货（房企除外，期房产生大量预收款）；       现金流量表 企业对资金的筹措和管控能力\n 一家企业，没有利润，也可以活得很滋润。过去20年，美国在线零售商亚马逊公司，一直以负利润或零利润状态经营。这没有妨碍它为美国、中国乃至全世界的消费者提供优质服务，也没妨碍它的股票自1997年上市至今，上涨超过200倍。\n  现金流量表是对货币资金科目下“现金及现金等价物”变化的展开‘ 现金活动：筹资活动现金流、投资活动现金流、经营活动现金流； 销售商品、提供劳务收到的现金/营业收入*1.17。大于1说明销售的大部分款项收到了，经营良好； 自由现金流=经营活动现金流净额-投资活动现金流出净额； 债务性筹资活动利率越高越危险；警惕货币资金不少但债务性活动筹资借款利率高的企业； 经营活动产生的现金流量净额\u0026gt;净利润\u0026gt;0； 销售商品、提供劳务收到的现金\u0026gt;=营业收入； 投资活动产生的现金流量净额\u0026lt;0，且主要投入新项目； 现金及现金等价物净增加额\u0026gt;0，可放款为排除分红因素； 期末现金及现金等价物余额+应收票据中的银行承兑汇票\u0026gt;=有息负债；     经营现金流净额 投资现金流净额 筹资现金流净额 -     + - - 可持续性   + - + 视项目前景、资金支持   + + - 低PE高股息         财务指标分析\n   安全性分析\n 流动比率=流动资产/流动负债，流动比率一般在2左右； 速动比率=速动资产（流动资产-存货）/流动负债，速动比率一般在1左右； 比率过高说明流动资产未能有效利用，太低说明有短期偿债风险； 安全性指标：现金及现金等价物/有息负债\u0026gt;=1 或放宽为 （货币资金+金融资产净值）/有息负债\u0026gt;=1;含义：变现迅速的资产足以偿还有息负债；       盈利能力分析\n 从收入角度，营业利润率最为重要。  营业利润率=（营业收入-营业成本-三费）/营业收入；   从资产角度，净资产收益率最为重要，总资产收益率是在净资产收益率上考虑了杠杆因素，净资产收益率相同的两家企业，总资产收益率更高的那家，有更强的盈利能力和更小的风险；  净资产收益率=净利润/平均净资产（期末值和期初值之和除以2）； 总资产收益率=净利润/平均总资产（期末值和期初值之和除以2）；         成长性分析\n 从收入角度，营业收入增长率和营业利润增长率；  营业收入增长率=（本期营业收入-上期营业收入）/上期营业收入； 营业利润增长率=（本期营业利润-上期营业利润）/上期营业利润；   从资产角度，总资产增长率和净资产增长率；  总资产增长率=（本期总资产-上期总资产）/上期总资产 净资产增长率=（本期净资产-上期净资产）/上期净资产   管理层能力（运营能力，固定周期对企业资源利用次数）分析：  平均应收账款=（期初应收账款总额+期末应收账款总额）/2 应收账款周转率=营业收入/平均应收账款 这个比率应该与历史数据比较观察。营业收入增长的同时，应收账款周转率是否下降了。应收账款周转率下降，意味着营业收入的增长，有放松销售政策的因素。反之，营业收入的增长，伴随着应收账款周转率的稳定或提高，意味着营业收入的增长是可靠的。         总体分析\n 净资产收益率（ROE）=净利润/净资产=净资产/销售收入*销售收入/平均总资产*平均总资产/净资产；         财务数据估值\n 现金流折现法，只适用评估产品变化小，需求偏好稳定，具有持续竞争优势的、未来自由现金流可预测的企业；（不适用低市值、初创、科技企业）  自由现金流=经营现金流入净额-投资活动现金流出   清算价值估算法，投资市值低于有形资产账面值的企业，涉及企业财报资产负债表的所有有形资产； 股票价值法，对比可比较性公司，参照当前市盈率、市净率和收入水平，预测目标公司的市盈率、市净率或收入水平，再结合净利润、净资产或销售收入进行估值；    董事会报告    当期经营情况的讨论与分析\n 主营业务分析 行业与产品地区分析 资产负债分析 投资状况分析       公司未来发展的讨论与分析\n需要与行业其他公司对比\n  重要事项  是否有重大事项影响公司的价值判断； 会计事务所改聘；  ","permalink":"https://zakudriver.github.io/posts/%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E8%AF%BB%E8%B4%A2%E6%8A%A5/","summary":"要点  会计政策的改变； 会计事务所出具 “标准无保留意见”； 上市时间长于5年； 某科目出现大比例变化，查看附注； 与同行对比；  关注的重点  财务会计报告 董事会报告 重要事项  财务会计报告    货币资金\n 货币资金余额比短期负债小很多； 货币资金充裕，却借了很多有息甚至高息负债； 定期存款很多，其他货币资金很多，流动资金却严重缺乏； 其他货币资金数额巨大，但没有合理解释；       经营相关资产\n 应收票据，银行承兑汇票\u0026gt;商业承兑汇票； 应收账款，增长幅度及坏账准备计提政策； 其他应收款，越小越好； 存货，存货和营业成本的合理比例；       生产相关资产\n 固定资产，年年折旧，折旧算费用； 在建工程，迟迟不转固定资产一般有鬼； 折旧 == 摊销； 无形资产，研发费用 = 机会+风险。房企，土地算存货而非无形资产 利润高的公司更愿意把研发支出都记入费用中，这样可以减少当期税收支出；反之计入无形资产凸显财报好看； 商誉：若一家企业的获利能力超过可辨认净资产的正常获利能力，超出的部分，一定是另外一种资产带来的，这个资产就被叫作“商誉”。没有进行过收购的企业商誉栏目为0。商誉不用摊销； 长期待摊费用，越小越好； 递延所得税资产，税务局收的税大于公司酸的应交税款； 递延所得税负债，税务局收的税小于公司算的应交税款； 企业净资产与真实相差甚远，如资产折旧或商誉价值；       投资相关资产\n 交易性金融资产，不折旧。以卖出产生利润收税；产生递延所得税资产和负债的重要源头。公允价值变动计入利润表； 持有至到期投资，按实际利率计算的投资收益，减值损失； 可供出售金融资产，汇兑损益，股利或利息，减值损失等公允价值变动加入净资产； 长期股权投资，分红影响利润，或经营盈亏影响利润； 买入返售金融资产，规避监管的抵押贷款； 投资性房地产，公允价值对利润和净资产影响巨大；       负债和所有人权益","title":"手把手教你读财报"},{"content":"package sliceSafe type SliceSafe struct { channel chan int `desc:\u0026#34;即将加入到数据slice的数据\u0026#34;` data []int `desc:\u0026#34;数据slice\u0026#34;` } // 新建一个size大小缓存的active object对象 func New(size int, done func()) *SliceSafe { s := \u0026amp;SliceSafe{ channel: make(chan int, size), data: make([]int, 0), } go func() { s.schedule() done() }() return s } // 把管道中的数据append到slice中 func (s *SliceSafe) schedule() { for v := range s.channel { s.data = append(s.data, v) } } // 增加一个值 func (s *SliceSafe) Add(v int) { s.channel \u0026lt;- v } // 管道使用完关闭 func (s *SliceSafe) Close() { close(s.channel) } // 返回slice func (s *Service) Slice() []int { return s.data } ","permalink":"https://zakudriver.github.io/posts/golang%E5%B9%B6%E5%8F%91%E5%86%99slice/","summary":"package sliceSafe type SliceSafe struct { channel chan int `desc:\u0026#34;即将加入到数据slice的数据\u0026#34;` data []int `desc:\u0026#34;数据slice\u0026#34;` } // 新建一个size大小缓存的active object对象 func New(size int, done func()) *SliceSafe { s := \u0026amp;SliceSafe{ channel: make(chan int, size), data: make([]int, 0), } go func() { s.schedule() done() }() return s } // 把管道中的数据append到slice中 func (s *SliceSafe) schedule() { for v := range s.channel { s.data = append(s.data, v) } } // 增加一个值 func (s *SliceSafe) Add(v int) { s.","title":"golang并发写slice"},{"content":"函数参数类型 type TFuncParameterType\u0026lt;T\u0026gt; = T extends (arg: infer P) =\u0026gt; void ? P : string; // e.g function func(arg: string) {} type TParamsType = TFuncParameterType\u0026lt;typeof func\u0026gt;; // string 函数返回值类型 type TFuncReturnType\u0026lt;T\u0026gt; = T extends (arg: any) =\u0026gt; infer P ? P : string; // e.g function func(arg: string): number {} type TReturnType = TFuncReturnType\u0026lt;typeof func\u0026gt;; // number 元祖成员作为键约束 const keys = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;] as const; type TKeysMap = Record\u0026lt;typeof keys[number], string\u0026gt; // KeysMap: { a: string; b: string; c: string; } 数组元素类型 type ArrayElement\u0026lt;T extends readonly unknown[]\u0026gt; = T extends readonly (infer P)[] ? P : never; // e.g const arr = [0, 1]; type TArr = ArrayElement\u0026lt;typeof arr\u0026gt; // number 值类型覆写 type Overwrite\u0026lt;T, R\u0026gt; = Omit\u0026lt;T, keyof R\u0026gt; \u0026amp; R; // e.g interface IA { a: number; b: string; } type TA = Overwrite\u0026lt;IA, {a: string}\u0026gt; // {a: string; b:string} 键覆写 type OverwriteKey\u0026lt;T, K extends keyof T, P extends keyof any\u0026gt; = Omit\u0026lt;T, K\u0026gt; \u0026amp; { [S in P]: T[K] }; // e.g interface IA { a: number; b: string; } type TA = OverwriteKey\u0026lt;IA, \u0026#34;a\u0026#34;, \u0026#34;c\u0026#34;\u0026gt; // {c: number; b:string} 元祖作为键约束 type TuplesAsKey\u0026lt;T extends readonly any[], P\u0026gt; = { [K in T[number]]: P; }; // e.g const keys = [\u0026#34;x\u0026#34;, \u0026#34;y\u0026#34;] as const; type TA = TuplesAsKey\u0026lt;typeof keys, string\u0026gt;; // {x: string, y: string} 函数类型省略this type OmitThisParameter\u0026lt;T\u0026gt; = unknown extends ThisParameterType\u0026lt;T\u0026gt; ? T : T extends (...args: infer A) =\u0026gt; infer R ? (...args: A) =\u0026gt; R : number; // e.g const func = (this: void, arg: string) =\u0026gt; {}; type TFunc = OmitThisParameter\u0026lt;typeof func\u0026gt;; // type TFunc = (arg: string) =\u0026gt; void 继承父类方法调用返回子类 class Foo { static instance: any; static getInstance\u0026lt;T extends typeof Foo\u0026gt;(this: T): InstanceType\u0026lt;T\u0026gt; { if (this.instance) { return this.instance as InstanceType\u0026lt;T\u0026gt;; } return new this() as InstanceType\u0026lt;T\u0026gt;; } } class Bar extends Foo {} Bar.getInstance(); // Bar 元祖类型 type _TupleOf\u0026lt;T, N extends number, R extends unknown[]\u0026gt; = R[\u0026#34;length\u0026#34;] extends N ? R : _TupleOf\u0026lt;T, N, [T, ...R]\u0026gt;; type Tuple\u0026lt;T, N extends number\u0026gt; = N extends N ? (number extends N ? T[] : _TupleOf\u0026lt;T, N, []\u0026gt;) : never; // e.g type TTuple = Tuple\u0026lt;string, 4\u0026gt;; // [string, string, string. string] 函数第二个参数类型有第一个参数决定(第一个参数是Key，第二个参数是Value) export class Foo { private _data = { a: 1, b: \u0026#34;2\u0026#34;, }; public set\u0026lt;K extends keyof Foo[\u0026#34;_data\u0026#34;]\u0026gt;(key: K, value: Foo[\u0026#34;_data\u0026#34;][K]): void { this._data[key] = value; } } 元祖转联合类型 const arr = \u0026lt;const\u0026gt;[\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;baz\u0026#34;]; type Ts = typeof arr[number]; // \u0026#34;foo\u0026#34; | \u0026#34;bar\u0026#34; | \u0026#34;baz\u0026#34; 联合类型转元祖 type UnionToIntersection\u0026lt;U\u0026gt; = (U extends any ? (k: U) =\u0026gt; void : never) extends (k: infer I) =\u0026gt; void ? I : never; type LastOf\u0026lt;T\u0026gt; = UnionToIntersection\u0026lt;T extends any ? () =\u0026gt; T : never\u0026gt; extends () =\u0026gt; infer R ? R : never; type Push\u0026lt;T extends any[], V\u0026gt; = [...T, V]; type TuplifyUnion\u0026lt;T, L = LastOf\u0026lt;T\u0026gt;, N = [T] extends [never] ? true : false\u0026gt; = true extends N ? [] : Push\u0026lt;TuplifyUnion\u0026lt;Exclude\u0026lt;T, L\u0026gt;\u0026gt;, L\u0026gt;; type Tabc = \u0026#34;a\u0026#34; | \u0026#34;b\u0026#34; | \u0026#34;c\u0026#34;; type TTuple = TuplifyUnion\u0026lt;abc\u0026gt;; // [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;] 键值对的键构建联合类型 const kv = { foo: 1, bar: 2, baz: 3, } as const; type Ts = keyof typeof kv; // \u0026#34;foo\u0026#34; | \u0026#34;bar\u0026#34; | \u0026#34;baz;\u0026#34; 键值对的值构建联合类型 const kv = { foo: 1, bar: 2, baz: 3, } as const; type Ts = typeof kv[keyof typeof kv]; // 1 | 2 | 3 数组项的某一字段值构建联合类型 const kvs = [ { name: \u0026#34;foo\u0026#34;, other: \u0026#34;something\u0026#34; }, { name: \u0026#34;bar\u0026#34;, other: \u0026#34;something\u0026#34; }, { name: \u0026#34;baz\u0026#34;, other: \u0026#34;something\u0026#34; }, ] as const; type Ts = typeof kvs[number][\u0026#34;name\u0026#34;]; // \u0026#34;foo\u0026#34; | \u0026#34;bar\u0026#34; | \u0026#34;baz\u0026#34; ","permalink":"https://zakudriver.github.io/posts/typescript%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B3%9B%E5%9E%8B/","summary":"函数参数类型 type TFuncParameterType\u0026lt;T\u0026gt; = T extends (arg: infer P) =\u0026gt; void ? P : string; // e.g function func(arg: string) {} type TParamsType = TFuncParameterType\u0026lt;typeof func\u0026gt;; // string 函数返回值类型 type TFuncReturnType\u0026lt;T\u0026gt; = T extends (arg: any) =\u0026gt; infer P ? P : string; // e.g function func(arg: string): number {} type TReturnType = TFuncReturnType\u0026lt;typeof func\u0026gt;; // number 元祖成员作为键约束 const keys = [\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;] as const; type TKeysMap = Record\u0026lt;typeof keys[number], string\u0026gt; // KeysMap: { a: string; b: string; c: string; } 数组元素类型 type ArrayElement\u0026lt;T extends readonly unknown[]\u0026gt; = T extends readonly (infer P)[] ?","title":"typescript常用的泛型"},{"content":"// 复制文字 // copyText(\u0026#39;h5实现一键复制到粘贴板 兼容ios\u0026#39;) /*兼容性补充： 移动端： 安卓手机: 微信（chrome）和几个手机浏览器都可以用。 苹果手机: 微信里面和sarafi浏览器里也都可以， PC: sarafi版本必须在10.2以上，其他浏览器可以. */ export function copyText(text: string | number) { // number类型没有 .length 不能执行selectText 需要转化成字符串  const textString = text.toString(); let input: HTMLInputElement | null = document.querySelector(\u0026#39;#copy-input\u0026#39;); if (!input) { input = document.createElement(\u0026#39;input\u0026#39;); input.id = \u0026#39;copy-input\u0026#39;; input.readOnly = true; // 防止ios聚焦触发键盘事件  input.style.position = \u0026#39;absolute\u0026#39;; input.style.left = \u0026#39;-1000px\u0026#39;; input.style.zIndex = \u0026#39;-1000\u0026#39;; document.body.appendChild(input); } input.value = textString; // ios必须先选中文字且不支持 input.select();  selectText(input, 0, textString.length); if (document.execCommand(\u0026#39;copy\u0026#39;)) { document.execCommand(\u0026#39;copy\u0026#39;); alert(\u0026#39;It has copy the code to the clipboard\u0026#39;); } else { console.error(\u0026#39;不兼容\u0026#39;); } input.blur(); } // input自带的select()方法在苹果端无法进行选择，所以需要自己去写一个类似的方法 function selectText(textbox: HTMLInputElement | any, startIndex: number, stopIndex: number) { if (textbox.createTextRange) { // ie  const range = textbox.createTextRange(); range.collapse(true); range.moveStart(\u0026#39;character\u0026#39;, startIndex); // 起始光标  range.moveEnd(\u0026#39;character\u0026#39;, stopIndex - startIndex); // 结束光标  range.select(); // 不兼容苹果  } else { // firefox/chrome  textbox.setSelectionRange(startIndex, stopIndex); textbox.focus(); } } ","permalink":"https://zakudriver.github.io/posts/h5%E5%A4%8D%E5%88%B6%E6%96%87%E5%AD%97%E5%88%B0%E5%89%AA%E5%88%87%E6%9D%BF/","summary":"// 复制文字 // copyText(\u0026#39;h5实现一键复制到粘贴板 兼容ios\u0026#39;) /*兼容性补充： 移动端： 安卓手机: 微信（chrome）和几个手机浏览器都可以用。 苹果手机: 微信里面和sarafi浏览器里也都可以， PC: sarafi版本必须在10.2以上，其他浏览器可以. */ export function copyText(text: string | number) { // number类型没有 .length 不能执行selectText 需要转化成字符串  const textString = text.toString(); let input: HTMLInputElement | null = document.querySelector(\u0026#39;#copy-input\u0026#39;); if (!input) { input = document.createElement(\u0026#39;input\u0026#39;); input.id = \u0026#39;copy-input\u0026#39;; input.readOnly = true; // 防止ios聚焦触发键盘事件  input.style.position = \u0026#39;absolute\u0026#39;; input.style.left = \u0026#39;-1000px\u0026#39;; input.style.zIndex = \u0026#39;-1000\u0026#39;; document.body.appendChild(input); } input.value = textString; // ios必须先选中文字且不支持 input.select();  selectText(input, 0, textString.","title":"H5复制文字到剪切板"},{"content":"从今天起这里多了一只白色，高冷的看门喵。视线会一直跟着你的鼠标，鼠标靠近它就可以撸了！\n目前只设定让它在PC出现，在移动端显示有些突兀。\n 养猫攻略  喵喵基于 live2d 绘图技术，在前端使用canvas绘制。\n  使用hexo搭建的站点可以直接使用 hexo-helper-live2d 快速养猫 使用 live2d-widget.js 源码导入  打包源码 # 拉取源码 $ git clone https://github.com/xiazeyu/live2d-widget.js.git # 下载依赖 $ yarn # 打包源码 $ npm run build:prod lib文件夹里就是打包成果。\n在hugo中使用   将打包后的lib路径中的 L2Dwidget.min.js 文件放到hugo根目录的 static/js 目录中。\n  在这儿下载喜欢的 live2d 模型放到hugo根目录的 static/live2d_models 目录中。\n  在当前使用的主题模板中导入和执行以上代码。一般是在 hugo/themes/xx/layouts/partials/script.html 中，这个文件是页面导入的script部分(虽是html文件，但是编辑时不能使用prettier-js格式化，会破坏hugo的模板语法)。\n\u0026lt;script src=\u0026#34;/js/L2Dwidget.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; /** ​ * The init function ​ * @param {Object} [userConfig] User\u0026#39;s custom config 用户自定义设置 ​ * @param {String} [userConfig.model.jsonPath = \u0026#39;\u0026#39;] Path to Live2D model\u0026#39;s main json eg. `https://test.com/miku.model.json` model主文件路径 ​ * @param {Number} [userConfig.model.scale = 1] Scale between the model and the canvas 模型与canvas的缩放 ​ * @param {Number} [userConfig.display.superSample = 2] rate for super sampling rate 超采样等级 ​ * @param {Number} [userConfig.display.width = 150] Width to the canvas which shows the model canvas的长度 ​ * @param {Number} [userConfig.display.height = 300] Height to the canvas which shows the model canvas的高度 ​ * @param {String} [userConfig.display.position = \u0026#39;right\u0026#39;] Left of right side to show 显示位置：左或右 ​ * @param {Number} [userConfig.display.hOffset = 0] Horizontal offset of the canvas canvas水平偏移 ​ * @param {Number} [userConfig.display.vOffset = -20] Vertical offset of the canvas canvas垂直偏移 ​ * @param {Boolean} [userConfig.mobile.show = true] Whether to show on mobile device 是否在移动设备上显示 ​ * @param {Number} [userConfig.mobile.scale = 0.5] Scale on mobile device 移动设备上的缩放 ​ * @param {String} [userConfig.name.canvas = \u0026#39;live2dcanvas\u0026#39;] ID name of the canvas canvas元素的ID ​ * @param {String} [userConfig.name.div = \u0026#39;live2d-widget\u0026#39;] ID name of the div div元素的ID ​ * @param {Number} [userConfig.react.opacity = 0.7] opacity 透明度 ​ * @param {Boolean} [userConfig.dev.border = false] Whether to show border around the canvas 在canvas周围显示边界 ​ * @param {Boolean} [userConfig.dialog.enable = false] Display dialog 显示人物对话框 ​ * @param {Boolean} [userConfig.dialog.hitokoto = false] Enable hitokoto 使用一言API ​ * @return {null} */ L2Dwidget.init({ model: { jsonPath: \u0026#39;/live2d_models/tororo/tororo.model.json\u0026#39;, scale: 1, }, display: { superSample: 1, width: 150, height: 300, position: \u0026#39;left\u0026#39;, hOffset: 60, vOffset: 0 }, mobile: { show: false, scale: 0.5, }, react: { opacity: 0.8 } }); \u0026lt;/script\u0026gt;   大功告成 有猫了有猫了\n","permalink":"https://zakudriver.github.io/posts/%E5%9C%A8%E5%8D%9A%E5%AE%A2%E5%85%BB%E4%B8%80%E5%8F%AA%E7%8C%AB/","summary":"从今天起这里多了一只白色，高冷的看门喵。视线会一直跟着你的鼠标，鼠标靠近它就可以撸了！\n目前只设定让它在PC出现，在移动端显示有些突兀。\n 养猫攻略  喵喵基于 live2d 绘图技术，在前端使用canvas绘制。\n  使用hexo搭建的站点可以直接使用 hexo-helper-live2d 快速养猫 使用 live2d-widget.js 源码导入  打包源码 # 拉取源码 $ git clone https://github.com/xiazeyu/live2d-widget.js.git # 下载依赖 $ yarn # 打包源码 $ npm run build:prod lib文件夹里就是打包成果。\n在hugo中使用   将打包后的lib路径中的 L2Dwidget.min.js 文件放到hugo根目录的 static/js 目录中。\n  在这儿下载喜欢的 live2d 模型放到hugo根目录的 static/live2d_models 目录中。\n  在当前使用的主题模板中导入和执行以上代码。一般是在 hugo/themes/xx/layouts/partials/script.html 中，这个文件是页面导入的script部分(虽是html文件，但是编辑时不能使用prettier-js格式化，会破坏hugo的模板语法)。\n\u0026lt;script src=\u0026#34;/js/L2Dwidget.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; /** ​ * The init function ​ * @param {Object} [userConfig] User\u0026#39;s custom config 用户自定义设置 ​ * @param {String} [userConfig.","title":"在博客养一只猫"},{"content":"使用emacs作为hugo博客的客户端  Hugo 生成博客的静态页面虽然已经很方便了，ox-hugo 自动md -\u0026gt; org也很便捷了，但写作和发布博客需要经过若干命令行操作才能完成。没有客户端界面直观。\n 目前写作和发布的流程 新建org文件 -\u0026gt; balabala并自动转md -\u0026gt; 命令行: $ hugo // 生成静态页面 -\u0026gt; magit stage/commit/push -\u0026gt; 完成 hugo 的 major-mode 插件: easy-hugo  easy-hugo 是 emacs 上的 hugo 博客管理的插件。支持markdown or org-mode or AsciiDoc or reStructuredText or mmark or html 等格式文档，多博客多站点，以及多平台部署。\n   easy-hugo 配置 (use-package easy-hugo :commands easy-hugo :bind (:map easy-hugo-mode-map (\u0026#34;SPC\u0026#34; . general-simulate-C-c) (\u0026#34;G\u0026#34; . kumo-easy-hugo-github-deploy)) :custom (easy-hugo-org-header t) (easy-hugo-basedir kumo/easy-hugo-basedir) (easy-hugo-postdir kumo/easy-hugo-postdir) (easy-hugo-url kumo/easy-hugo-url) (easy-hugo-preview-url kumo/easy-hugo-preview-url) (easy-hugo-github-deploy-script kumo/easy-hugo-github-deploy-script) (easy-hugo-default-ext \u0026#34;.org\u0026#34;) :hook (easy-hugo-mode . (lambda () (evil-set-initial-state \u0026#39;easy-hugo-mode \u0026#39;emacs))) )  需要配置 easy-hugo 的 basedir/postdir/preview-url/deploy-script 等等。方便 easy-hugo 读取出博客列表、部署脚本，以及执行一键预览等。\n 部署脚本 #!/bin/sh  # If a command fails then the deploy stops set -e printf \u0026#34;\\033[0;32mDeploying updates to GitHub...\\033[0m\\n\u0026#34; # Build the project. hugo # if using a theme, replace with `hugo -t \u0026lt;YOURTHEME\u0026gt;` # Go To Public folder cd public # Add changes to git. git add . # Commit changes. msg=\u0026#34;rebuilding site $(date)\u0026#34; if [ -n \u0026#34;$*\u0026#34; ]; then msg=\u0026#34;$*\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. git push origin master -f    配置的一些坑\n 由于我使用了evil-mode，所以 easy-hugo-mode-map 的原生键位是不能用了。只有在 easy-hugo-mode 中屏蔽 evil-mode.   :hook (easy-hugo-mode . (lambda () (evil-set-initial-state \u0026#39;easy-hugo-mode \u0026#39;emacs)))  屏蔽 evil-mode 同时也屏蔽了 general 的触发键 SPC。 emacs 上没有了 SPC 就像走路蒙着双眼\u0026hellip;   :bind (:map easy-hugo-mode-map (\u0026#34;SPC\u0026#34; . general-simulate-C-c))  easy-hugo 原生的 github page 部署函数不支持交互式shell脚本，导致 git push 时不能输入密码。需要自己写个函数来替换它。   这里使用 C-q 而不是 q 退出 async-shell-command 的 buffer。因为万一账号或密码中带有 \u0026ldquo;q\u0026rdquo; 就不好了\u0026hellip;😅\n :bind (:map easy-hugo-mode-map (\u0026#34;G\u0026#34; . kumo-easy-hugo-github-deploy)) (defun kumo-easy-hugo-github-deploy () \u0026#34;Easy-Hugo deploy github page.\u0026#34; (interactive) (let* ((output-buffer (get-buffer-create kumo/easy-hugo-github-deploy-buffer-name)) (command-window (async-shell-command (expand-file-name (concat kumo/easy-hugo-basedir kumo/easy-hugo-github-deploy-script)) output-buffer nil))) (select-window command-window) (local-set-key (kbd \u0026#34;C-q\u0026#34;) \u0026#39;kill-buffer-and-window)))   现在的写作和发布的流程 呼出 easy-hugo -\u0026gt; n键 新建org balabala并自动转md -\u0026gt; G键 发布部署 博客总算能有一个像样的管理界面了😅\n现在写作/发布可以直接依托 emacs，并且都不需要键入一个命令行。\n","permalink":"https://zakudriver.github.io/posts/emacs%E7%AE%A1%E7%90%86%E5%8D%9A%E5%AE%A2%E5%86%99%E4%BD%9C%E6%B5%81%E7%A8%8B/","summary":"使用emacs作为hugo博客的客户端  Hugo 生成博客的静态页面虽然已经很方便了，ox-hugo 自动md -\u0026gt; org也很便捷了，但写作和发布博客需要经过若干命令行操作才能完成。没有客户端界面直观。\n 目前写作和发布的流程 新建org文件 -\u0026gt; balabala并自动转md -\u0026gt; 命令行: $ hugo // 生成静态页面 -\u0026gt; magit stage/commit/push -\u0026gt; 完成 hugo 的 major-mode 插件: easy-hugo  easy-hugo 是 emacs 上的 hugo 博客管理的插件。支持markdown or org-mode or AsciiDoc or reStructuredText or mmark or html 等格式文档，多博客多站点，以及多平台部署。\n   easy-hugo 配置 (use-package easy-hugo :commands easy-hugo :bind (:map easy-hugo-mode-map (\u0026#34;SPC\u0026#34; . general-simulate-C-c) (\u0026#34;G\u0026#34; . kumo-easy-hugo-github-deploy)) :custom (easy-hugo-org-header t) (easy-hugo-basedir kumo/easy-hugo-basedir) (easy-hugo-postdir kumo/easy-hugo-postdir) (easy-hugo-url kumo/easy-hugo-url) (easy-hugo-preview-url kumo/easy-hugo-preview-url) (easy-hugo-github-deploy-script kumo/easy-hugo-github-deploy-script) (easy-hugo-default-ext \u0026#34;.","title":"emacs管理博客写作流程"},{"content":"redis发布订阅 相比rabbitmq等专业消息队列的缺陷: 没有相应的机制保证消息的可靠消费，如果发布者发布一条消息，而没有对应的订阅者的话，这条消息将丢失，不会存在内存中。\n package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/gomodule/redigo/redis\u0026#34; ) // ConsumeFunc consumes message at the channel. type ConsumeFunc func(channel string, message []byte) error // RedisClient represents a redis client with connection pool. type RedisClient struct { pool *redis.Pool } // NewRedisClient returns a RedisClient. func NewRedisClient(addr string, passwd string) *RedisClient { pool := \u0026amp;redis.Pool{ MaxIdle: 10, IdleTimeout: 300 * time.Second, Dial: func() (redis.Conn, error) { c, err := redis.Dial(\u0026#34;tcp\u0026#34;, addr, redis.DialPassword(passwd), redis.DialDatabase(0)) if err != nil { return nil, err } return c, nil }, TestOnBorrow: func(c redis.Conn, t time.Time) error { if time.Since(t) \u0026lt; time.Minute { return nil } _, err := c.Do(\u0026#34;PING\u0026#34;) return err }, } log.Printf(\u0026#34;new redis pool at %s\u0026#34;, addr) client := \u0026amp;RedisClient{ pool: pool, } return client } // Close closes connection pool. func (r *RedisClient) Close() error { err := r.pool.Close() return err } // Publish publishes message to channel. func (r *RedisClient) Publish(channel, message string) (int, error) { c := r.pool.Get() defer c.Close() n, err := redis.Int(c.Do(\u0026#34;PUBLISH\u0026#34;, channel, message)) if err != nil { return 0, fmt.Errorf(\u0026#34;redis publish %s %s, err: %v\u0026#34;, channel, message, err) } return n, nil } // Subscribe subscribes messages at the channels. func (r *RedisClient) Subscribe(ctx context.Context, consume ConsumeFunc, channel ...string) error { psc := redis.PubSubConn{Conn: r.pool.Get()} log.Printf(\u0026#34;redis pubsub subscribe channel: %v\u0026#34;, channel) if err := psc.Subscribe(redis.Args{}.AddFlat(channel)...); err != nil { return err } done := make(chan error, 1) // start a new goroutine to receive message  go func() { defer psc.Close() for { switch msg := psc.Receive().(type) { case error: done \u0026lt;- fmt.Errorf(\u0026#34;redis pubsub receive err: %v\u0026#34;, msg) return case redis.Message: if err := consume(msg.Channel, msg.Data); err != nil { done \u0026lt;- err return } case redis.Subscription: if msg.Count == 0 { // all channels are unsubscribed  done \u0026lt;- nil return } } } }() ch \u0026lt;- 0 // health check  tick := time.NewTicker(time.Minute) defer tick.Stop() for { select { case \u0026lt;-ctx.Done(): if err := psc.Unsubscribe(); err != nil { return fmt.Errorf(\u0026#34;redis pubsub unsubscribe err: %v\u0026#34;, err) } return nil case err := \u0026lt;-done: return err case \u0026lt;-tick.C: if err := psc.Ping(\u0026#34;\u0026#34;); err != nil { return err } log.Println(\u0026#34;over\u0026#34;) return nil } } } func myConsumer(channel string, message []byte) error { log.Printf(\u0026#34;receive message[%s] at the channel[%s]\\n\u0026#34;, string(message), channel) return nil } // ch 用于保证发布线程在订阅线程启动成功后才开始发布消息 var ch = make(chan int) func main() { redisClient := NewRedisClient(\u0026#34;127.0.0.1:6300\u0026#34;, \u0026#34;zyhua1122\u0026#34;) defer redisClient.Close() go func() { var subscriber int \u0026lt;-ch for i := 0; i \u0026lt; 3; i++ { subscriber, _ = redisClient.Publish(\u0026#34;testx\u0026#34;, \u0026#34;hello world\u0026#34;+strconv.Itoa(i)) log.Printf(\u0026#34;there is %d subscriber.\\n\u0026#34;, subscriber) } }() ctx, cancel := context.WithCancel(context.Background()) err := redisClient.Subscribe(ctx, func(channel string, message []byte) error { log.Printf(\u0026#34;receive message[%s] at the channel[%s]\\n\u0026#34;, string(message), channel) if string(message) == \u0026#34;goodbye\u0026#34; { cancel() } return nil }, \u0026#34;testx\u0026#34;) if err != nil { fmt.Printf(\u0026#34;get error: %v\\n\u0026#34;, err) } return } ","permalink":"https://zakudriver.github.io/posts/redis%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/","summary":"redis发布订阅 相比rabbitmq等专业消息队列的缺陷: 没有相应的机制保证消息的可靠消费，如果发布者发布一条消息，而没有对应的订阅者的话，这条消息将丢失，不会存在内存中。\n package main import ( \u0026#34;context\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;strconv\u0026#34; \u0026#34;time\u0026#34; \u0026#34;github.com/gomodule/redigo/redis\u0026#34; ) // ConsumeFunc consumes message at the channel. type ConsumeFunc func(channel string, message []byte) error // RedisClient represents a redis client with connection pool. type RedisClient struct { pool *redis.Pool } // NewRedisClient returns a RedisClient. func NewRedisClient(addr string, passwd string) *RedisClient { pool := \u0026amp;redis.Pool{ MaxIdle: 10, IdleTimeout: 300 * time.Second, Dial: func() (redis.Conn, error) { c, err := redis.","title":"redis发布订阅"},{"content":"package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) type Glimit struct { n int c chan struct{} } func New(n int) *Glimit { return \u0026amp;Glimit{ n: n, c: make(chan struct{}, n), } } func (g *Glimit) Run(f func()) { g.c \u0026lt;- struct{}{} go func() { f() \u0026lt;-g.c }() } var wg = sync.WaitGroup{} func main() { number := 10 g := New(2) for i := 0; i \u0026lt; number; i++ { wg.Add(1) value := i g.Run(func() { // 做一些业务逻辑处理  fmt.Printf(\u0026#34;go func: %d\\n\u0026#34;, value) time.Sleep(time.Second) wg.Done() }) } wg.Wait() } ","permalink":"https://zakudriver.github.io/posts/%E9%99%90%E5%88%B6goroutine%E6%95%B0%E9%87%8F/","summary":"package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) type Glimit struct { n int c chan struct{} } func New(n int) *Glimit { return \u0026amp;Glimit{ n: n, c: make(chan struct{}, n), } } func (g *Glimit) Run(f func()) { g.c \u0026lt;- struct{}{} go func() { f() \u0026lt;-g.c }() } var wg = sync.WaitGroup{} func main() { number := 10 g := New(2) for i := 0; i \u0026lt; number; i++ { wg.","title":"限制goroutine数量"},{"content":"小对象要合并 函数频繁创建的简单的对象，直接返回对象，效果比返回指针效果要好 类型转换要注意，官方用法消耗特别大。 package string_util import ( \u0026#34;unsafe\u0026#34; ) func str2bytes(s string) []byte { x := (*[2]uintptr)(unsafe.Pointer(\u0026amp;s)) h := [3]uintptr{x[0], x[1], x[1]} return *(*[]byte)(unsafe.Pointer(\u0026amp;h)) } func bytes2str(b []byte) string { return *(*string)(unsafe.Pointer(\u0026amp;b)) } 避免反复创建slice，map func(r*Reader)Read()([]byte,error) // 此函数没有形参，每次调用的时候返回一个[]byte。 func(r*Reader)Read(buf[]byte)(int,error) // 此函数个函数在每次迪调用的时候，会重用形参声明。  避免使用\u0026quot;+\u0026ldquo;拼接字符串 package string_utils import ( \u0026#34;strings\u0026#34; ) func strAppend(s string, ss ...string) string { var r strings.Builder r.WriteString(s) for _, v := range ss { r.WriteString(v) } return r.String() } ","permalink":"https://zakudriver.github.io/posts/gc%E4%BC%98%E5%8C%96/","summary":"小对象要合并 函数频繁创建的简单的对象，直接返回对象，效果比返回指针效果要好 类型转换要注意，官方用法消耗特别大。 package string_util import ( \u0026#34;unsafe\u0026#34; ) func str2bytes(s string) []byte { x := (*[2]uintptr)(unsafe.Pointer(\u0026amp;s)) h := [3]uintptr{x[0], x[1], x[1]} return *(*[]byte)(unsafe.Pointer(\u0026amp;h)) } func bytes2str(b []byte) string { return *(*string)(unsafe.Pointer(\u0026amp;b)) } 避免反复创建slice，map func(r*Reader)Read()([]byte,error) // 此函数没有形参，每次调用的时候返回一个[]byte。 func(r*Reader)Read(buf[]byte)(int,error) // 此函数个函数在每次迪调用的时候，会重用形参声明。  避免使用\u0026quot;+\u0026ldquo;拼接字符串 package string_utils import ( \u0026#34;strings\u0026#34; ) func strAppend(s string, ss ...string) string { var r strings.Builder r.WriteString(s) for _, v := range ss { r.WriteString(v) } return r.String() } ","title":"golang gc优化"},{"content":"package util-time import ( \u0026#34;strconv\u0026#34; \u0026#34;time\u0026#34; ) // 获取当前的时间 - 字符串 func GetCurrentDate() string { return time.Now().Format(\u0026#34;2006/01/02 15:04:05\u0026#34;) } // 获取当前的时间 - Unix时间戳 func GetCurrentUnix() int64 { return time.Now().Unix() } // 获取当前的时间 - 毫秒级时间戳 func GetCurrentMilliUnix() int64 { return time.Now().UnixNano() / 1000000 } // 获取当前的时间 - 纳秒级时间戳 func GetCurrentNanoUnix() int64 { return time.Now().UnixNano() } func GetCurrentTime() string { var cstSh, _ = time.LoadLocation(\u0026#34;Asia/Shanghai\u0026#34;) t := time.Now().In(cstSh).Format(\u0026#34;2006/01/02/ 15:04:05\u0026#34;) return t } func GetCurrentHour() int { var cstSh, _ = time.LoadLocation(\u0026#34;Asia/Shanghai\u0026#34;) t,_ := strconv.Atoi(time.Now().In(cstSh).Format(\u0026#34;2006010215\u0026#34;)) return t } func GetCurrentDay() int { var cstSh, _ = time.LoadLocation(\u0026#34;Asia/Shanghai\u0026#34;) t,_ := strconv.Atoi(time.Now().In(cstSh).Format(\u0026#34;20060102\u0026#34;)) return t } func GetLastDay() int { var cstSh, _ = time.LoadLocation(\u0026#34;Asia/Shanghai\u0026#34;) nTime := time.Now() t,_ := strconv.Atoi(nTime.AddDate(0,0,-1).In(cstSh).Format(\u0026#34;20060102\u0026#34;)) return t } func GetlastHour() int { nTime := time.Now() lastTime := nTime.Add(time.Hour * -1) t,_ := strconv.Atoi(lastTime.Format(\u0026#34;2006010215\u0026#34;)) return t } ","permalink":"https://zakudriver.github.io/posts/time/","summary":"package util-time import ( \u0026#34;strconv\u0026#34; \u0026#34;time\u0026#34; ) // 获取当前的时间 - 字符串 func GetCurrentDate() string { return time.Now().Format(\u0026#34;2006/01/02 15:04:05\u0026#34;) } // 获取当前的时间 - Unix时间戳 func GetCurrentUnix() int64 { return time.Now().Unix() } // 获取当前的时间 - 毫秒级时间戳 func GetCurrentMilliUnix() int64 { return time.Now().UnixNano() / 1000000 } // 获取当前的时间 - 纳秒级时间戳 func GetCurrentNanoUnix() int64 { return time.Now().UnixNano() } func GetCurrentTime() string { var cstSh, _ = time.LoadLocation(\u0026#34;Asia/Shanghai\u0026#34;) t := time.Now().In(cstSh).Format(\u0026#34;2006/01/02/ 15:04:05\u0026#34;) return t } func GetCurrentHour() int { var cstSh, _ = time.","title":"golang time工具函数"},{"content":"GDT(Global Descriptor Table)全局描述符表 GDT是一个以 段描述符 为表项的数组类型的数据结构，在内存中线性存放。每个段描述符占 8 个字节。\nGDTR寄存器存放GDT表的基地址和表长界限(高32位存放GDT基址，低16为存放GDT限长)。 指令LGDT和SGDT分别用于加载和保存GDTR寄存器的内容。在机器刚加电或处理器复位后，基地址被默认地设置为0，而长度值被设置成0xFFFF。在保护模式初始化过程中必须给GDTR加载一个新值。\n段选择子(Segement Selector) 由GDTR访问全局描述符表是通过“段选择子”(实模式下的段寄存器)来完成的。段选择子是一个16位的寄存器(同实模式下的段寄存器相同)。\n段选择子共16bit，由三部分组成: 描述符索引(index)、TI、请求特权级(RPL)  描述符索引(index): 在描述符表中定位一个段描述符。 TI: 描述符表指示器， TI＝0 时，表示描述符在 GDT 中； TI＝1 时，描述符在 LDT 中。 RPL: 请求特权级，表示给出当前选择子访问的内存段的特权级别。每一个段都有一个特定的级别。每当一个程序试图访问某一个段时，就将该程序所拥有的特权级与要访问的特权级进行比较，以决定能否访问该段。系统约定，CPU只能访问同一特权级或级别较低特权级的段。  因为每个描述符占 8 字节，因此描述符在表内的偏移地址是索引号乘以 8 处理器在执行任何改变段选择器的指令时(比如 pop、 mov、jmp far、 call far、 iret、 retf)，就将指令中提供的索引号乘以 8 作为偏移地址，同 GDTR 中提供的线性基地址相加，以访问 GDT。 在表内找到的描述符，并加载到不可见的描述符高速缓存部分。此后每当有访问内存的指令时，就不再访问 GDT 中的描述符，直接用当前段寄存器描述符高速缓存器提供线性基地址。\n段描述符(Segment Descriptor) 每个段描述符占 8 个字节。由三部分组成: 线性基地址、段界限和段的访问属性。\n    G: 粒度位，用于解释段界限的含义。当 G 位是\u0026quot;0\u0026quot;时，段界限以字节为单位。此时，段的扩展范围是从 1 字节到 1 兆字节（ 1B～1MB），因为描述符中的界限值是 20 位的。 相反，如果该位是\u0026quot;1\u0026quot;，那么，段界限是以 4KB 为单位的。这样，段的扩展范围是从 4KB到 4GB。\n  D/B: \u0026ldquo;默认的操作数大小\u0026rdquo;(Default Operation Size)或者\u0026quot;默认的堆栈指针大小\u0026quot;，又或者\u0026quot;上部边界\u0026quot;标志。 设立该标志位，主要是为了能够在 32 位处理器上兼容运行 16 位保护模式的程序。D＝0 表示指令中的偏移地址或者操作数是 16 位的； D＝1，指示 32 位的偏移地址或者操作数。\n  L: 64 位代码段标志。保留此位给 64 位处理器使用。32位将此位置\u0026quot;0\u0026quot;。\n  AVL: 保留位。可以被系统软件使用。\n  P: 段存在位(Segment Present)。 P 位用于指示描述符所对应的段是否存在。 一般来说，描述符所指示的段都位于内存中。但是，当内存空间紧张时，有可能只是建立了描述符，对应的内存空间并不存在，这时，就应当把描述符的 P 位清零，表示段并不存在。P 位是由处理器负责检查的。 每当通过描述符访问内存中的段时，如果 P 位是\u0026quot;0\u0026quot;，处理器就会产生一个异常中断。\n  DPL: 描述符的特权级(Descriptor Privilege Level， DPL)。这两位用于指定段的特权级。 共有 4 种处理器支持的特权级别，分别是 0、 1、 2、 3，其中 0 是最高特权级别， 3 是最低特权级别。刚进入保护模式时执行的代码具有最高特权级 0(可以看成是从处理器那里继承来的)，这些代码通常都是操作系统代码(内核段)，因此它的特权级别最高。 每当操作系统加载一个用户程序时，它通常都会指定一个稍低的特权级(用户段)，比如 3 特权级。不同特权级别的程序是互相隔离的，其互访是严格限制的，而且有些处理器指令(特权指令)只能由 0 特权级的程序来执行，为的就是安全。这里再次点明了为何叫保护模式。\n  S: 用于指定描述符的类型(Descriptor Type)。当该位是\u0026quot;0\u0026quot;时，表示是一个系统段；为\u0026quot;1\u0026quot;时，表示是一个代码段或者数据段(堆栈段也是特殊的数据段)。\n  TYPE: 共 4 位，用于指示描述符的子类型，或者说是类别。\n  描述符类型   对于数据段来说， 这 4 位分别是 X、 E、 W、 A 位；而对于代码段来说，这 4 位则分别是 X、 C、 R、 A 位。\n数据段  X: 表示是否可以执行（ eXecutable）。数据段总是不可执行的，X＝0。 E: 针对数据段。E 位指示段的扩展方向。 E＝0 是向上扩展的，也就是向高地址方向扩展的，是普通的数据段； E＝1 是向下扩展的，也就是向低地址方向扩展的，通常是堆栈段。 W: 段的读写属性，W＝0 的段是不允许写入的，否则会引发处理器异常中断； W＝1的段是可以正常写入的。 A: 已访问位，用于指示它所指向的段最近是否被访问过。在描述符创建的时候，应该清零。之后，每当该段被访问时，处理器自动将该位置\u0026quot;1\u0026quot;。  代码段   X: 表示是否可以执行(eXecutable)。代码段总是可以执行的 X＝1。\n  C: 是否为特权级依从的(Conforming)。 C＝0 表示非依从的代码段，这样的代码段可以从与它特权级相同的代码段调用，或者通过门调用； C＝1 表示允许从低特权级的程序转移到该段执行。\n  R: 是否允许读出。代码段总是可以执行的，但是，为了防止程序被破坏，它是不能写入的。至于是否有读出的可能，由 R 位指定。 R＝0 表示不能读出，如果企图去读一个 R＝0 的代码段，会引发处理器异常中断； 如果 R＝1，则代码段是可以读出的，即可以把这个段的内容当成 ROM 一样使用。\n 也许有人会问，既然代码段是不可读的，那处理器怎么从里面取指令执行呢？事实上，这里的R属性并非用来限制处理器， 而是用来限制程序和指令的行为。\n   A: 已访问位，用于指示它所指向的段最近是否被访问过。在描述符创建的时候，应该清零。之后，每当该段被访问时，处理器自动将该位置\u0026quot;1\u0026quot;。\n  ","permalink":"https://zakudriver.github.io/posts/gdtldt/","summary":"GDT(Global Descriptor Table)全局描述符表 GDT是一个以 段描述符 为表项的数组类型的数据结构，在内存中线性存放。每个段描述符占 8 个字节。\nGDTR寄存器存放GDT表的基地址和表长界限(高32位存放GDT基址，低16为存放GDT限长)。 指令LGDT和SGDT分别用于加载和保存GDTR寄存器的内容。在机器刚加电或处理器复位后，基地址被默认地设置为0，而长度值被设置成0xFFFF。在保护模式初始化过程中必须给GDTR加载一个新值。\n段选择子(Segement Selector) 由GDTR访问全局描述符表是通过“段选择子”(实模式下的段寄存器)来完成的。段选择子是一个16位的寄存器(同实模式下的段寄存器相同)。\n段选择子共16bit，由三部分组成: 描述符索引(index)、TI、请求特权级(RPL)  描述符索引(index): 在描述符表中定位一个段描述符。 TI: 描述符表指示器， TI＝0 时，表示描述符在 GDT 中； TI＝1 时，描述符在 LDT 中。 RPL: 请求特权级，表示给出当前选择子访问的内存段的特权级别。每一个段都有一个特定的级别。每当一个程序试图访问某一个段时，就将该程序所拥有的特权级与要访问的特权级进行比较，以决定能否访问该段。系统约定，CPU只能访问同一特权级或级别较低特权级的段。  因为每个描述符占 8 字节，因此描述符在表内的偏移地址是索引号乘以 8 处理器在执行任何改变段选择器的指令时(比如 pop、 mov、jmp far、 call far、 iret、 retf)，就将指令中提供的索引号乘以 8 作为偏移地址，同 GDTR 中提供的线性基地址相加，以访问 GDT。 在表内找到的描述符，并加载到不可见的描述符高速缓存部分。此后每当有访问内存的指令时，就不再访问 GDT 中的描述符，直接用当前段寄存器描述符高速缓存器提供线性基地址。\n段描述符(Segment Descriptor) 每个段描述符占 8 个字节。由三部分组成: 线性基地址、段界限和段的访问属性。\n    G: 粒度位，用于解释段界限的含义。当 G 位是\u0026quot;0\u0026quot;时，段界限以字节为单位。此时，段的扩展范围是从 1 字节到 1 兆字节（ 1B～1MB），因为描述符中的界限值是 20 位的。 相反，如果该位是\u0026quot;1\u0026quot;，那么，段界限是以 4KB 为单位的。这样，段的扩展范围是从 4KB到 4GB。","title":"GDT\u0026LDT"},{"content":"func Home() (string, error) { user, err := user.Current() if nil == err { return user.HomeDir, nil } // cross compile support  if runtime.GOOS == \u0026#34;windows\u0026#34; { return homeWindows() } // Unix-like system, so just assume Unix  return homeUnix() } func homeUnix() (string, error) { // First prefer the HOME environmental variable  if home := os.Getenv(\u0026#34;HOME\u0026#34;); home != \u0026#34;\u0026#34; { return home, nil } // If that fails, try the shell  var stdout bytes.Buffer cmd := exec.Command(\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;eval echo ~$USER\u0026#34;) cmd.Stdout = \u0026amp;stdout if err := cmd.Run(); err != nil { return \u0026#34;\u0026#34;, err } result := strings.TrimSpace(stdout.String()) if result == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;blank output when reading home directory\u0026#34;) } return result, nil } func homeWindows() (string, error) { drive := os.Getenv(\u0026#34;HOMEDRIVE\u0026#34;) path := os.Getenv(\u0026#34;HOMEPATH\u0026#34;) home := drive + path if drive == \u0026#34;\u0026#34; || path == \u0026#34;\u0026#34; { home = os.Getenv(\u0026#34;USERPROFILE\u0026#34;) } if home == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;HOMEDRIVE, HOMEPATH, and USERPROFILE are blank\u0026#34;) } return home, nil } ","permalink":"https://zakudriver.github.io/posts/%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7home%E7%9B%AE%E5%BD%95%E8%B7%AF%E5%BE%84/","summary":"func Home() (string, error) { user, err := user.Current() if nil == err { return user.HomeDir, nil } // cross compile support  if runtime.GOOS == \u0026#34;windows\u0026#34; { return homeWindows() } // Unix-like system, so just assume Unix  return homeUnix() } func homeUnix() (string, error) { // First prefer the HOME environmental variable  if home := os.Getenv(\u0026#34;HOME\u0026#34;); home != \u0026#34;\u0026#34; { return home, nil } // If that fails, try the shell  var stdout bytes.","title":"获取用户home目录路径"},{"content":"标签(Label) 指向一大块的首地址。 使用方法: LABEL_NAME: XXX XXX\n局部Label 以(点)开头，比如.begin，.1，.2。在不同的段中可以使用相同的带点开头的LABEL，不能重复。最好只用在代码段中。\n变量 函数变量 指的是一个SUB_RUTIN的首地址。 比如DispStr，使用的时候是call DispStr，然后在声明时候因为它本来就是一个地址，就是用上面标签的同样的声明方式。 DispStr:（注意后面有冒号）\n普通变量 使用equ生成的纯的变量(宏) 比如：TopOfStack equ $ - LABEL_STACK - 1\n使用db dd dw生成的变量(地址) 生成的各种变量分别指向的是不同的数据类型(冒号可加可不加) 比如： _dwDispPos: dd (80 * 6 + 0) * 2\n","permalink":"https://zakudriver.github.io/posts/%E5%8F%98%E9%87%8F%E5%92%8C%E6%A0%87%E7%AD%BE/","summary":"标签(Label) 指向一大块的首地址。 使用方法: LABEL_NAME: XXX XXX\n局部Label 以(点)开头，比如.begin，.1，.2。在不同的段中可以使用相同的带点开头的LABEL，不能重复。最好只用在代码段中。\n变量 函数变量 指的是一个SUB_RUTIN的首地址。 比如DispStr，使用的时候是call DispStr，然后在声明时候因为它本来就是一个地址，就是用上面标签的同样的声明方式。 DispStr:（注意后面有冒号）\n普通变量 使用equ生成的纯的变量(宏) 比如：TopOfStack equ $ - LABEL_STACK - 1\n使用db dd dw生成的变量(地址) 生成的各种变量分别指向的是不同的数据类型(冒号可加可不加) 比如： _dwDispPos: dd (80 * 6 + 0) * 2","title":"变量和标签"},{"content":"Mac   首先需安装cmake和llvm\nbrew install cmake llvm   emacs里执行M-x irony-install-server得到安装执行命令\ncmake -DCMAKE_INSTALL_PREFIX\\=/Users/kumotyou/.emacs.d/irony/ \\ /Users/kumotyou/.emacs.d/elpa/irony-20200130.849/server \\ \u0026amp;\u0026amp; cmake --build . --use-stderr --config Release --target install   添加环境变量\n-DCMAKE_PREFIX_PATH=/usr/local/opt/llvm -DCMAKE_INSTALL_RPATH_USE_LINK_PATH=ON -DLIBCLANG_INCLUDE_DIR=/usr/local/opt/llvm/include -DLIBCLANG_LIBRARY=/usr/local/opt/llvm/lib/libclang.dylib   最终编译命令\ncmake -DCMAKE_INSTALL_PREFIX\\=/Users/kumotyou/.emacs.d/irony/ \\ -DCMAKE_PREFIX_PATH=/usr/local/opt/llvm \\ -DCMAKE_INSTALL_RPATH_USE_LINK_PATH=ON \\ -DLIBCLANG_INCLUDE_DIR=/usr/local/opt/llvm/include \\ -DLIBCLANG_LIBRARY=/usr/local/opt/llvm/lib/libclang.dylib \\ /Users/kumotyou/.emacs.d/elpa/irony-20200130.849/server \\ \u0026amp;\u0026amp; cmake --build . --use-stderr --config Release --target install   Ubuntu   拉取ccls源码, 并进入ccls根目录\ngit clone https://github.com/MaskRay/ccls cd ccls   拉取第三方依赖. (主要是rapidjson)\ngit submodule update --init --recursive   下载llvm的二进制包并解压\nwget -c http://releases.llvm.org/9.0.0/clang+llvm-9.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz tar xf clang+llvm-9.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz   在根目录下执行cmake 执行结果保存到Release文件夹中\ncmake -H. -BRelease -DCMAKE_BUILD_TYPE=Release -DCMAKE_PREFIX_PATH=/path/to/clang+llvm-9.0.0-x86_64-linux-gnu-ubuntu-18.04 cmake --build Release   开始编译\ncd Release make -j4 #使用4线程编译   编译完成, 安装\nsudo make install   ","permalink":"https://zakudriver.github.io/posts/irony-server-install/","summary":"Mac   首先需安装cmake和llvm\nbrew install cmake llvm   emacs里执行M-x irony-install-server得到安装执行命令\ncmake -DCMAKE_INSTALL_PREFIX\\=/Users/kumotyou/.emacs.d/irony/ \\ /Users/kumotyou/.emacs.d/elpa/irony-20200130.849/server \\ \u0026amp;\u0026amp; cmake --build . --use-stderr --config Release --target install   添加环境变量\n-DCMAKE_PREFIX_PATH=/usr/local/opt/llvm -DCMAKE_INSTALL_RPATH_USE_LINK_PATH=ON -DLIBCLANG_INCLUDE_DIR=/usr/local/opt/llvm/include -DLIBCLANG_LIBRARY=/usr/local/opt/llvm/lib/libclang.dylib   最终编译命令\ncmake -DCMAKE_INSTALL_PREFIX\\=/Users/kumotyou/.emacs.d/irony/ \\ -DCMAKE_PREFIX_PATH=/usr/local/opt/llvm \\ -DCMAKE_INSTALL_RPATH_USE_LINK_PATH=ON \\ -DLIBCLANG_INCLUDE_DIR=/usr/local/opt/llvm/include \\ -DLIBCLANG_LIBRARY=/usr/local/opt/llvm/lib/libclang.dylib \\ /Users/kumotyou/.emacs.d/elpa/irony-20200130.849/server \\ \u0026amp;\u0026amp; cmake --build . --use-stderr --config Release --target install   Ubuntu   拉取ccls源码, 并进入ccls根目录\ngit clone https://github.com/MaskRay/ccls cd ccls   拉取第三方依赖.","title":"irony-server-install"},{"content":"############################################################### # Configuration file for Bochs ############################################################### # how much memory the emulated machine will have megs: 32 # filename of ROM images romimage: file=/usr/local/share/bochs/BIOS-bochs-latest vgaromimage: file=/usr/local/share/bochs/VGABIOS-lgpl-latest # what disk images will be used floppya: 1_44=a.img, status=inserted # choose the boot disk. boot: floppy # where do we send log messages? # log: bochsout.txt # disable the mouse mouse: enabled=0 # enable key mapping, using US layout as default. # keyboard_mapping: enabled=1, map=/usr/local/share/bochs/keymaps/x11-pc-us.map keyboard: keymap=/usr/local/share/bochs/keymaps/x11-pc-us.map ","permalink":"https://zakudriver.github.io/posts/bochsrc/","summary":"############################################################### # Configuration file for Bochs ############################################################### # how much memory the emulated machine will have megs: 32 # filename of ROM images romimage: file=/usr/local/share/bochs/BIOS-bochs-latest vgaromimage: file=/usr/local/share/bochs/VGABIOS-lgpl-latest # what disk images will be used floppya: 1_44=a.img, status=inserted # choose the boot disk. boot: floppy # where do we send log messages? # log: bochsout.txt # disable the mouse mouse: enabled=0 # enable key mapping, using US layout as default. # keyboard_mapping: enabled=1, map=/usr/local/share/bochs/keymaps/x11-pc-us.","title":"bochsrc"},{"content":"ld: dynamic main executables must link with libSystem.dylib for architecture x86_64 # -lSystem ld a.o -o a -lSystem ","permalink":"https://zakudriver.github.io/posts/mac%E7%BC%96%E8%AF%91nasm%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/","summary":"ld: dynamic main executables must link with libSystem.dylib for architecture x86_64 # -lSystem ld a.o -o a -lSystem ","title":"mac编译nasm问题汇总"},{"content":" 汇编语言和CPU息息相关，但是不能把汇编语言完全等同于CPU的机器指令。 不同架构的CPU指令并不相同，如x86，powerpc，arm各有各的指令系统；甚至同一种架构的CPU有几套指令集，典型的如arm除了有32位的指令集外，还有一套16位的thumb指令集。但是作为开发语言的汇编，本质上是一套语法规则和助记符的集合，它可以包容不同的指令集。 如果从CPU体系来划分，常见的汇编有两种：IBM PC汇编和ARM汇编。 IBM PC汇编也就是Intel的汇编，因为IBM 最早推出PC机，后来的体系很多都要和它兼容，所以也使用了相同的汇编语言。ARM压根没考虑过兼容，它的指令集和x86完全是两个体系，所以汇编语言也独立发展出一套。 CPU只是限定了机器码，作为开发语言的汇编，其实还和编译器息息相关。汇编语言出现的早，没有像C语言一样定义出标准，所以编译器的厂商各搞一套。到现在，最有名的也是两家：MASM和GNU ASM。 前者是微软的，只支持x86，用在DOS/Windows平台中；后者是开源产品，主要用在Linux中，基本上支持大部分的CPU架构。这两者的区别在于伪指令的不同，伪指令是用来告诉编译器如何工作的，和编译器相关，和CPU无关。 其实汇编的编译相当简单，这两套伪指令只是符号不相同，含义是大同小异，明白了一种，看另一种就很容易了。\n CPU体系分类  IBM PC汇编 ARM汇编  汇编格式分类 Intel格式 windows平台常见，后者最早由贝尔实验室推出，用于Unix中\nAT\u0026amp;T格式 GUN汇编器的缺省格式\n GNU的汇编器和调试器gdb对这两种格式都支持，可以随便切换。MASM只支持Intel格式。Intel格式和AT\u0026amp;T格式的区别只是符号系统的区别，这与x86和arm的区别可不一样，后者是CPU体系的区别。\n内嵌汇编 用于C语言和汇编语言混合编程的，所以和编译器也关系紧密。\n GNU的内嵌汇编 (不是很容易看懂，需要专门学习) MASM的内嵌汇编 (MASM的内嵌汇编和普通汇编的区别则不大)  ","permalink":"https://zakudriver.github.io/posts/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A7%8D%E7%B1%BB/","summary":" 汇编语言和CPU息息相关，但是不能把汇编语言完全等同于CPU的机器指令。 不同架构的CPU指令并不相同，如x86，powerpc，arm各有各的指令系统；甚至同一种架构的CPU有几套指令集，典型的如arm除了有32位的指令集外，还有一套16位的thumb指令集。但是作为开发语言的汇编，本质上是一套语法规则和助记符的集合，它可以包容不同的指令集。 如果从CPU体系来划分，常见的汇编有两种：IBM PC汇编和ARM汇编。 IBM PC汇编也就是Intel的汇编，因为IBM 最早推出PC机，后来的体系很多都要和它兼容，所以也使用了相同的汇编语言。ARM压根没考虑过兼容，它的指令集和x86完全是两个体系，所以汇编语言也独立发展出一套。 CPU只是限定了机器码，作为开发语言的汇编，其实还和编译器息息相关。汇编语言出现的早，没有像C语言一样定义出标准，所以编译器的厂商各搞一套。到现在，最有名的也是两家：MASM和GNU ASM。 前者是微软的，只支持x86，用在DOS/Windows平台中；后者是开源产品，主要用在Linux中，基本上支持大部分的CPU架构。这两者的区别在于伪指令的不同，伪指令是用来告诉编译器如何工作的，和编译器相关，和CPU无关。 其实汇编的编译相当简单，这两套伪指令只是符号不相同，含义是大同小异，明白了一种，看另一种就很容易了。\n CPU体系分类  IBM PC汇编 ARM汇编  汇编格式分类 Intel格式 windows平台常见，后者最早由贝尔实验室推出，用于Unix中\nAT\u0026amp;T格式 GUN汇编器的缺省格式\n GNU的汇编器和调试器gdb对这两种格式都支持，可以随便切换。MASM只支持Intel格式。Intel格式和AT\u0026amp;T格式的区别只是符号系统的区别，这与x86和arm的区别可不一样，后者是CPU体系的区别。\n内嵌汇编 用于C语言和汇编语言混合编程的，所以和编译器也关系紧密。\n GNU的内嵌汇编 (不是很容易看懂，需要专门学习) MASM的内嵌汇编 (MASM的内嵌汇编和普通汇编的区别则不大)  ","title":"汇编语言种类"},{"content":"docker-compose 配置 version: \u0026#39;3\u0026#39; services: # mysql blog_mysql: image: mysql restart: always ports: - \u0026#39;3306:3306\u0026#39; environment: - MYSQL_ROOT_PASSWORD=xxxx volumes: - \u0026#39;/data/mysql:/var/lib/mysql\u0026#39; docker 安装完mysql 后客户端无法访问 进入镜像中的mysql docker exec -it container_id /bin/bash 登录mysql mysql -u root -p 修改root账号, 可以通过任何客户端连接 ALTER USER \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;xxxxx\u0026#39;; ","permalink":"https://zakudriver.github.io/posts/docker%E9%83%A8%E7%BD%B2mysql%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/","summary":"docker-compose 配置 version: \u0026#39;3\u0026#39; services: # mysql blog_mysql: image: mysql restart: always ports: - \u0026#39;3306:3306\u0026#39; environment: - MYSQL_ROOT_PASSWORD=xxxx volumes: - \u0026#39;/data/mysql:/var/lib/mysql\u0026#39; docker 安装完mysql 后客户端无法访问 进入镜像中的mysql docker exec -it container_id /bin/bash 登录mysql mysql -u root -p 修改root账号, 可以通过任何客户端连接 ALTER USER \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;xxxxx\u0026#39;; ","title":"docker部署mysql问题汇总"},{"content":".flex { flex-shrink: 0; } ","permalink":"https://zakudriver.github.io/posts/flex%E5%AE%BD%E5%BA%A6%E5%A4%B1%E6%95%88/","summary":".flex { flex-shrink: 0; } ","title":"flex宽度失效"},{"content":"context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);  img 规定要使用的图像, 画布或视频. sx 可选. 开始剪切的 x 坐标位置. sy 可选. 开始剪切的 y 坐标位置. swidth 可选. 被剪切图像的宽度. sheight 可选. 被剪切图像的高度. x 在画布上放置图像的 x 坐标位置. y 在画布上放置图像的 y 坐标位置. width 可选. 要使用的图像的宽度.(伸展或缩小图像) height 可选. 要使用的图像的高度.(伸展或缩小图像)  ","permalink":"https://zakudriver.github.io/posts/canvas-drawimage/","summary":"context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);  img 规定要使用的图像, 画布或视频. sx 可选. 开始剪切的 x 坐标位置. sy 可选. 开始剪切的 y 坐标位置. swidth 可选. 被剪切图像的宽度. sheight 可选. 被剪切图像的高度. x 在画布上放置图像的 x 坐标位置. y 在画布上放置图像的 y 坐标位置. width 可选. 要使用的图像的宽度.(伸展或缩小图像) height 可选. 要使用的图像的高度.(伸展或缩小图像)  ","title":"canvas-drawImage"},{"content":"#!/usr/bin/env bash  # Print nyan cat # https://github.com/steckel/Git-Nyan-Graph/blob/master/nyan.sh # If you want big animated version: `telnet miku.acm.uiuc.edu` e=\u0026#39;\\033\u0026#39; RESET=\u0026#34;$e[0m\u0026#34; BOLD=\u0026#34;$e[1m\u0026#34; CYAN=\u0026#34;$e[0;96m\u0026#34; RED=\u0026#34;$e[0;91m\u0026#34; YELLOW=\u0026#34;$e[0;93m\u0026#34; GREEN=\u0026#34;$e[0;92m\u0026#34; echo if [ $[$RANDOM%2] -eq \u0026#34;0\u0026#34; ]; then echo -en $RED\u0026#39;`·.,¸,.·*·.\u0026#39; echo -e $RESET$BOLD\u0026#39;╭━━━━╮\u0026#39;$RESET echo -en $YELLOW\u0026#39;`·.,¸,.·*·.\u0026#39; echo -e $RESET$BOLD\u0026#39;|::: /\\_/\\\\\u0026#39;$RESET echo -en $GREEN\u0026#39;`·.,¸,.·*·.\u0026#39; echo -e $RESET$BOLD\u0026#39;|:::( ◕ᴥ◕)\u0026#39;$RESET echo -en $CYAN\u0026#39;`·.,¸,.·*·.\u0026#39; echo -e $RESET$BOLD\u0026#39;u-u━━-u--u\u0026#39;$RESET else echo -en $RED\u0026#39;-_-_-_-_-_-_-_\u0026#39; echo -e $RESET$BOLD\u0026#39;,------,\u0026#39;$RESET echo -en $YELLOW\u0026#39;_-_-_-_-_-_-_-\u0026#39; echo -e $RESET$BOLD\u0026#39;| /\\_/\\\\\u0026#39;$RESET echo -en $GREEN\u0026#39;-_-_-_-_-_-_-\u0026#39; echo -e $RESET$BOLD\u0026#39;~|__( ^ .^)\u0026#39;$RESET echo -en $CYAN\u0026#39;-_-_-_-_-_-_-\u0026#39; echo -e $RESET$BOLD\u0026#39;\u0026#34;\u0026#34; \u0026#34;\u0026#34;\u0026#39;$RESET fi echo   ","permalink":"https://zakudriver.github.io/posts/nyan/","summary":"#!/usr/bin/env bash  # Print nyan cat # https://github.com/steckel/Git-Nyan-Graph/blob/master/nyan.sh # If you want big animated version: `telnet miku.acm.uiuc.edu` e=\u0026#39;\\033\u0026#39; RESET=\u0026#34;$e[0m\u0026#34; BOLD=\u0026#34;$e[1m\u0026#34; CYAN=\u0026#34;$e[0;96m\u0026#34; RED=\u0026#34;$e[0;91m\u0026#34; YELLOW=\u0026#34;$e[0;93m\u0026#34; GREEN=\u0026#34;$e[0;92m\u0026#34; echo if [ $[$RANDOM%2] -eq \u0026#34;0\u0026#34; ]; then echo -en $RED\u0026#39;`·.,¸,.·*·.\u0026#39; echo -e $RESET$BOLD\u0026#39;╭━━━━╮\u0026#39;$RESET echo -en $YELLOW\u0026#39;`·.,¸,.·*·.\u0026#39; echo -e $RESET$BOLD\u0026#39;|::: /\\_/\\\\\u0026#39;$RESET echo -en $GREEN\u0026#39;`·.,¸,.·*·.\u0026#39; echo -e $RESET$BOLD\u0026#39;|:::( ◕ᴥ◕)\u0026#39;$RESET echo -en $CYAN\u0026#39;`·.,¸,.·*·.\u0026#39; echo -e $RESET$BOLD\u0026#39;u-u━━-u--u\u0026#39;$RESET else echo -en $RED\u0026#39;-_-_-_-_-_-_-_\u0026#39; echo -e $RESET$BOLD\u0026#39;,------,\u0026#39;$RESET echo -en $YELLOW\u0026#39;_-_-_-_-_-_-_-\u0026#39; echo -e $RESET$BOLD\u0026#39;| /\\_/\\\\\u0026#39;$RESET echo -en $GREEN\u0026#39;-_-_-_-_-_-_-\u0026#39; echo -e $RESET$BOLD\u0026#39;~|__( ^ .","title":"nyan"},{"content":"c++ #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;using namespace std; class Stack { private: vector\u0026lt;int\u0026gt; data; public: void push(int x) { data.push_back(x); } bool isEmpty() { return data.empty(); } int top() { return data.back(); } bool pop() { if (isEmpty()) { return false; } data.pop_back(); return true; } }; int main() { Stack s; s.push(1); s.push(2); s.push(3); for (int i = 0; i \u0026lt; 4; ++i) { if (!s.isEmpty()) { cout \u0026lt;\u0026lt; s.top() \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; (s.pop() ? \u0026#34;true\u0026#34; : \u0026#34;false\u0026#34;) \u0026lt;\u0026lt; endl; } } go package stack type Data interface{} type Stack struct { data []Data } func (s *Stack) Push(value Data) { s.data = append(s.data, value) } func (s *Stack) IsEmpty() bool { return len(s.data) == 0 } func (s *Stack) Top() Data { if s.IsEmpty() { return -1 } return s.data[len(s.data)-1] } func (s *Stack) Pop() bool { if s.IsEmpty() { return false } s.data = s.data[:len(s.data)-1] return true } ","permalink":"https://zakudriver.github.io/posts/stack/","summary":"c++ #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;using namespace std; class Stack { private: vector\u0026lt;int\u0026gt; data; public: void push(int x) { data.push_back(x); } bool isEmpty() { return data.empty(); } int top() { return data.back(); } bool pop() { if (isEmpty()) { return false; } data.pop_back(); return true; } }; int main() { Stack s; s.push(1); s.push(2); s.push(3); for (int i = 0; i \u0026lt; 4; ++i) { if (!s.isEmpty()) { cout \u0026lt;\u0026lt; s.top() \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; (s.","title":"Stack"},{"content":"C++ #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;using namespace std; typedef int Data; class ArrayQueue { private: vector\u0026lt;Data\u0026gt; data; int p_start; public: ArrayQueue() { p_start = 0; } bool enQueue(int x) { data.push_back(x); return true; } bool deQueue() { if (isEmpty()) { return false; } p_start++; return true; }; int Front() { return data[p_start]; }; bool isEmpty() { return p_start \u0026gt;= data.size(); } }; class CircularQueue { private: vector\u0026lt;Data\u0026gt; data; int head; int tail; int size; public: CircularQueue(int k) { data.resize(k); head = -1; tail = -1; size = k; } bool enQueue(int value) { if (isFull()) { return false; } if (isEmpty()) { head = 0; } tail = (tail + 1) % size; data[tail] = value; return true; } bool deQueue() { if (isEmpty()) { return false; } if (head == tail) { head = -1; tail = -1; return true; } head = (head + 1) % size; return true; } int Front() { if (isEmpty()) { return -1; } return data[head]; } int Rear() { if (isEmpty()) { return -1; } return data[tail]; } bool isEmpty() { return head == -1; } bool isFull() { return ((tail + 1) % size) == head; } }; int main() { ArrayQueue q; q.enQueue(5); q.enQueue(3); if (!q.isEmpty()) { cout \u0026lt;\u0026lt; q.Front() \u0026lt;\u0026lt; endl; } q.deQueue(); if (!q.isEmpty()) { cout \u0026lt;\u0026lt; q.Front() \u0026lt;\u0026lt; endl; } q.deQueue(); if (!q.isEmpty()) { cout \u0026lt;\u0026lt; q.Front() \u0026lt;\u0026lt; endl; } } go package queue type Data int type CircularQueue struct { data []Data head int tail int size int } func Constructor(k int) CircularQueue { return CircularQueue{ data: make([]Data, k), head: -1, tail: -1, size: k, } } func (q *CircularQueue) EnQueue(value Data) bool { if q.IsFull() { return false } if q.IsEmpty() { q.head = 0 } q.tail = (q.tail + 1) % q.size q.data[q.tail] = value return true } func (q *CircularQueue) DeQueue() bool { if q.IsEmpty() { return false } if q.head == q.tail { q.head = -1 q.tail = -1 return true } q.head = (q.head + 1) % q.size return true } func (q *CircularQueue) Front() int { if q.IsEmpty() { return -1 } return q.data[q.head] } func (q *CircularQueue) Rear() int { if q.IsEmpty() { return -1 } return q.data[q.tail] } func (q *CircularQueue) IsEmpty() bool { return q.head == -1 } func (q *CircularQueue) IsFull() bool { return (q.tail+1)%q.size == -1 } ","permalink":"https://zakudriver.github.io/posts/queue/","summary":"C++ #include \u0026lt;iostream\u0026gt;#include \u0026lt;vector\u0026gt;using namespace std; typedef int Data; class ArrayQueue { private: vector\u0026lt;Data\u0026gt; data; int p_start; public: ArrayQueue() { p_start = 0; } bool enQueue(int x) { data.push_back(x); return true; } bool deQueue() { if (isEmpty()) { return false; } p_start++; return true; }; int Front() { return data[p_start]; }; bool isEmpty() { return p_start \u0026gt;= data.size(); } }; class CircularQueue { private: vector\u0026lt;Data\u0026gt; data; int head; int tail; int size; public: CircularQueue(int k) { data.","title":"Queue"},{"content":"// js 表情emoji转码 // 发送请求时将uft16转为utf-8 function utf16toEntities(str) { var patt = /[\\ud800-\\udbff][\\udc00-\\udfff]/g; // 检测utf16字符正则  return str.replace(patt, function(char) { var H, L, code; if (char.length === 2) { H = char.charCodeAt(0); // 取出高位  L = char.charCodeAt(1); // 取出低位  code = (H - 0xd800) * 0x400 + 0x10000 + L - 0xdc00; // 转换算法  return \u0026#39;\u0026amp;#\u0026#39; + code + \u0026#39;;\u0026#39;; } else { return char; } }); } // 收到后端的数据时展示emoji function entitiesToUtf16(str) { return str.replace(/\u0026amp;#(\\d+);/g, function(match, dec) { let H = Math.floor((dec - 0x10000) / 0x400) + 0xd800; let L = (Math.floor(dec - 0x10000) % 0x400) + 0xdc00; return String.fromCharCode(H, L); }); } ","permalink":"https://zakudriver.github.io/posts/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BAemoji/","summary":"// js 表情emoji转码 // 发送请求时将uft16转为utf-8 function utf16toEntities(str) { var patt = /[\\ud800-\\udbff][\\udc00-\\udfff]/g; // 检测utf16字符正则  return str.replace(patt, function(char) { var H, L, code; if (char.length === 2) { H = char.charCodeAt(0); // 取出高位  L = char.charCodeAt(1); // 取出低位  code = (H - 0xd800) * 0x400 + 0x10000 + L - 0xdc00; // 转换算法  return \u0026#39;\u0026amp;#\u0026#39; + code + \u0026#39;;\u0026#39;; } else { return char; } }); } // 收到后端的数据时展示emoji function entitiesToUtf16(str) { return str.","title":"浏览器显示emoji"},{"content":"Go 语言与鸭子类型的关系  If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.\n如果某个东西长得像鸭子, 像鸭子一样游泳, 像鸭子一样嘎嘎叫, 那它就可以被看成是一只鸭子.\n在 Go 语言中, 如果类型的方法集完全包含接口的方法集，则可认为该类型实现了该接口.\n 鸭子类型是一种动态语言的风格, 在这种风格中, 一个对象有效的语义, 不是由继承自特定的类或实现特定的接口, 而是由它\u0026quot;当前方法和属性的集合\u0026quot;决定. Go 作为一种静态语言, 通过接口实现了 鸭子类型, 实际上是 Go 的编译器在其中作了隐匿的转换工作.\n值接收者和指针接收者的区别 package main import \u0026#34;fmt\u0026#34; type Person struct { age int } func (p Person) howOld() int { return p.age } func (p *Person) growUp() { p.age += 1 } func main() { // qcrao 是值类型  qcrao := Person{age: 18} // 值类型 调用接收者也是值类型的方法  fmt.Println(qcrao.howOld()) // 值类型 调用接收者是指针类型的方法  qcrao.growUp() fmt.Println(qcrao.howOld()) // ----------------------  // stefno 是指针类型  stefno := \u0026amp;Person{age: 100} // 指针类型 调用接收者是值类型的方法  fmt.Println(stefno.howOld()) // 指针类型 调用接收者也是指针类型的方法  stefno.growUp() fmt.Println(stefno.howOld()) }    - 值接收者 指针接收者     值类型调用者 方法会使用调用者的一个副本，类似于\u0026quot;传值\u0026quot; 使用值的引用来调用方法, 上例中 qcrao.growUp() 实际上是 (\u0026amp;qcrao).growUp()   指针类型调用者 指针被解引用为值, 上例中, stefno.howOld() 实际上是 (*stefno).howOld() 实际上也是\u0026quot;传值\u0026quot;, 方法里的操作会影响到调用者, 类似于指针传参, 拷贝了一份指针    区别 如果方法的接收者是值类型, 无论调用者是对象还是对象指针, 修改的都是对象的副本, 不影响调用者; 如果方法的接收者是指针类型, 则调用者修改的是指针指向的对象本身.\n使用值接收者还是指针接收者, 不是由该方法是否修改了调用者 (也就是接收者) 来决定, 而是应该基于该类型的本质.\n 如果类型具备\u0026quot;原始的本质\u0026quot;, 也就是说它的成员都是由 Go 语言里内置的原始类型, 如字符串, 整型值等, 那就定义值接收者类型的方法. 像内置的引用类型, 如 slice, map, interface, channel, 这些类型比较特殊, 声明他们的时候, 实际上是创建了一个 header, 对于他们也是直接定义值接收者类型的方法. 这样, 调用函数时, 是直接 copy 了这些类型的 header, 而 header 本身就是为复制设计的. 如果类型具备非原始的本质, 不能被安全地复制, 这种类型总是应该被共享, 那就定义指针接收者的方法. 比如 go 源码里的文件结构体 (struct File) 就不应该被复制, 应该只有一份实体.  iface 和 eface 的区别 iface 和 eface 都是 Go 中描述接口的底层结构体, 区别在于 iface 描述的接口包含方法, 而 eface 则是不包含任何方法的空接口: interface{}.\niface import \u0026#34;unsafe\u0026#34; type iface struct { tab *itab // 接口类型以及实际类型  data unsafe.Pointer // 接口具体的值, 一般而言是一个指向堆内存的指针 } type itab struct { inter *interfacetype _type *_type hash uint32 // copy of _type.hash. Used for type switches.  _ [4]byte fun [1]uintptr // variable sized. 存储的是第一个方法的函数指针，如果有更多的方法，在它之后的内存空间里继续存储. } type interfacetype struct { typ _type pkgpath name mhdr []imethod } type _type struct { // 类型大小  size uintptr ptrdata uintptr // 类型的 hash 值  hash uint32 // 类型的 flag，和反射相关  tflag tflag // 内存对齐相关  align uint8 fieldalign uint8 // 类型的编号，有bool, slice, struct 等等等等  kind uint8 equal func(unsafe.Pointer, unsafe.Pointer) bool // gc 相关  gcdata *byte str nameOff ptrToThis typeOff }   eface type eface struct { _type *_type data unsafe.Pointer } _type _type 是描述 Go 语言中各种数据类型的结构体\ntype _type struct { // 类型大小  size uintptr ptrdata uintptr // 类型的 hash 值  hash uint32 // 类型的 flag，和反射相关  tflag tflag // 内存对齐相关  align uint8 fieldalign uint8 // 类型的编号，有bool, slice, struct 等等等等  kind uint8 equal func(unsafe.Pointer, unsafe.Pointer) bool // gc 相关  gcdata *byte str nameOff ptrToThis typeOff } Go 语言各种数据类型都是在 _type 字段的基础上, 增加一些额外的字段来进行管理的:\ntype arraytype struct { typ _type elem *_type slice *_type len uintptr } type chantype struct { typ _type elem *_type dir uintptr } type slicetype struct { typ _type elem *_type } type functype struct { typ _type inCount uint16 outCount uint16 } type ptrtype struct { typ _type elem *_type } type structfield struct { name name typ *_type offsetAnon uintptr } 这些数据类型的结构体定义, 是反射实现的基础.\n接口的动态类型和动态值 import \u0026#34;unsafe\u0026#34; type iface struct { tab *itab // 接口类型以及实际类型  data unsafe.Pointer // 接口具体的值, 一般而言是一个指向堆内存的指针 } iface 类型包含两个字段:\n tab: 是接口表指针，指向类型信息 data: 是数据指针，则指向具体的数据  接口类型和 nil 作比较 接口值的零值是指动态类型和动态值都为 nil, 这个接口才能被认为 接口值 == nil.\n  package main import \u0026#34;fmt\u0026#34; func main() { var a interface{} fmt.Println(c == nil) // true  var b *string fmt.Println(b == nil) // true  a = b fmt.Println(a == nil) // false } b 赋值给 a 后, a 的动态类型为 *string , 动态值为 nil , 所以 a == nil 为 false .  package main import \u0026#34;fmt\u0026#34; type MyError string func (i MyError) Error() string { return i } func main() { err := HandleError() fmt.Println(err == nil) // false } func HandleError() error { var err *MyError = nil return err } 调用 HandleError 返回 error 接口类型, 动态类型为 *MyError , 动态值为 nil .  打印接口的动态值和类型 package main import ( \u0026#34;unsafe\u0026#34; \u0026#34;fmt\u0026#34; ) type iface struct { itab, data uintptr } func main() { var a interface{} = nil var b interface{} = (*int)(nil) x := 5 var c interface{} = (*int)(\u0026amp;x) ia := *(*iface)(unsafe.Pointer(\u0026amp;a)) ib := *(*iface)(unsafe.Pointer(\u0026amp;b)) ic := *(*iface)(unsafe.Pointer(\u0026amp;c)) fmt.Println(ia) // {0 0}  fmt.Println(ib) // {17426912 0}  fmt.Println(ic) // {17426912 842350714568}  fmt.Println(*(*int)(unsafe.Pointer(ic.data))) // 5 }  a 的动态类型和动态值的地址均为 0, 也就是 nil; b 的动态类型和 c 的动态类型一致, 都是 *int; c 的动态值为 5.  编译器自动检测类型是否实现接口 var _ io.Writer = (*myWriter)(nil) 编译器会由此检查 *myWriter 类型是否实现了 io.Writer 接口.\npackage main import \u0026#34;io\u0026#34; type myWriter string func (w *myWriter) Write(p []byte) (n int, err error) { return } func main() { // 检查 *myWriter 类型是否实现了 io.Writer 接口  var _ io.Writer = (*myWriter)(nil) // 检查 myWriter 类型是否实现了 io.Writer 接口  var _ io.Writer = myWriter{} } src/main.go:15:6: cannot use myWriter literal (type myWriter) as type io.Writer in assignment: myWriter does not implement io.Writer (missing Write method) myWriter 没用实现 io.Writer\n接口类型的赋值 (构造) 和断言 赋值 针对不同类型有以下函数:\n convT2E16, convT2I16 convT2E32, convT2I32 convT2E64, convT2I64 convT2Estring, convT2Istring convT2Eslice, convT2Islice convT2Enoptr, convT2Inoptr\n func convT2I(tab *itab, elem unsafe.Pointer) (i iface) { t := tab._type if raceenabled { raceReadObjectPC(t, elem, getcallerpc(), funcPC(convT2I)) } if msanenabled { msanread(elem, t.size) } x := mallocgc(t.size, t, true) typedmemmove(t, x, elem) i.tab = tab i.data = x return } 把 tab 赋给了 iface 的 tab 字段; data 部分则是在堆上申请了一块内存, 然后将 elem 指向的数据拷贝过去.\n断言 func assertI2I(inter *interfacetype, i iface) (r iface) { tab := i.tab if tab == nil { // explicit conversions require non-nil interface value.  panic(\u0026amp;TypeAssertionError{nil, nil, \u0026amp;inter.typ, \u0026#34;\u0026#34;}) } if tab.inter == inter { r.tab = tab r.data = i.data return } r.tab = getitab(inter, tab._type, false) r.data = i.data return } func assertI2I2(inter *interfacetype, i iface) (r iface, b bool) { tab := i.tab if tab == nil { return } if tab.inter != inter { tab = getitab(inter, tab._type, true) if tab == nil { return } } r.tab = tab r.data = i.data b = true return } func assertE2I(inter *interfacetype, e eface) (r iface) { t := e._type if t == nil { // explicit conversions require non-nil interface value.  panic(\u0026amp;TypeAssertionError{nil, nil, \u0026amp;inter.typ, \u0026#34;\u0026#34;}) } r.tab = getitab(inter, t, false) r.data = e.data return } func assertE2I2(inter *interfacetype, e eface) (r iface, b bool) { t := e._type if t == nil { return } tab := getitab(inter, t, true) if tab == nil { return } r.tab = tab r.data = e.data b = true return } 判断需断言的变量 (iface) 是否满足接口类型 (interfacetype).\nassertI2I 对应 接口断言返回一个参数:\npackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) func main(args) { var a interface{} = errors.New(\u0026#34;error\u0026#34;) err := a.(error) fmt.Println(err.Error()) } assertI2I2 则对应返回两个参数的情况:\npackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) func main(args) { var a interface{} = errors.New(\u0026#34;error\u0026#34;) if err, ok := a.(error); ok { fmt.Println(err.Error()) } } 都在编译阶段编译器判断.\n打印接口类型的hash值 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) type iface struct { tab *itab data unsafe.Pointer } type itab struct { inter uintptr _type uintptr hash uint32 _ [4]byte fun [1]uintptr } func main() { p := Person(Student{age: 18}) iface := (*iface)(unsafe.Pointer(\u0026amp;p)) fmt.Printf(\u0026#34;iface.tab.hash = %#x\\n\u0026#34;, iface.tab.hash) // iface.tab.hash = 0xd4209fda } 类型转换和断言的区别 类型转换 Go 语言中不允许隐式类型转换, 也就是说 = 两边, 不允许出现类型不相同的变量. 类型转换前后的两个类型必须相互兼容.\n \u0026lt;结果类型\u0026gt; := \u0026lt;目标类型\u0026gt; ( \u0026lt;表达式\u0026gt; )\n package main import \u0026#34;fmt\u0026#34; func main() { var i int = 9 var f float64 f = float64(i) fmt.Printf(\u0026#34;%T, %v\\n\u0026#34;, f, f) f = 10.8 a := int(f) fmt.Printf(\u0026#34;%T, %v\\n\u0026#34;, a, a) // s := []int(i) } 断言 空接口 interface{} 没有定义任何函数, 因此 Go 中所有类型都实现了空接口. 当一个函数的形参是 interface{}, 那么在函数中, 需要对形参进行断言, 从而得到它的真实类型.\n \u0026lt;目标类型的值\u0026gt;，\u0026lt;布尔参数\u0026gt; := \u0026lt;表达式\u0026gt;.( 目标类型 ) // 安全类型断言 \u0026lt;目标类型的值\u0026gt; := \u0026lt;表达式\u0026gt;.( 目标类型 )　//非安全类型断言\n package main import \u0026#34;fmt\u0026#34; type Student struct { Name string Age int } func main() { var i interface{} = new(Student) s := i.(*Student) fmt.Println(s) } switch 形式断言\npackage main import \u0026#34;fmt\u0026#34; type Student struct { Name string Age int } func main() { var i interface{} judge(i) } func judge(v interface{}) { fmt.Printf(\u0026#34;%p %v\\n\u0026#34;, \u0026amp;v, v) switch v := v.(type) { case nil: fmt.Printf(\u0026#34;%p %v\\n\u0026#34;, \u0026amp;v, v) fmt.Printf(\u0026#34;nil type[%T] %v\\n\u0026#34;, v, v) case Student: fmt.Printf(\u0026#34;%p %v\\n\u0026#34;, \u0026amp;v, v) fmt.Printf(\u0026#34;Student type[%T] %v\\n\u0026#34;, v, v) case *Student: fmt.Printf(\u0026#34;%p %v\\n\u0026#34;, \u0026amp;v, v) fmt.Printf(\u0026#34;*Student type[%T] %v\\n\u0026#34;, v, v) default: fmt.Printf(\u0026#34;%p %v\\n\u0026#34;, \u0026amp;v, v) fmt.Printf(\u0026#34;unknow\\n\u0026#34;) } } fmt.Println 函数 fmt.Println 函数的参数是 interface{}. 对于内置类型, 函数内部会用穷举法, 得出它的真实类型, 然后转换为字符串打印. 而对于自定义类型, 首先确定该类型是否实现了 String() 方法. 如果实现了, 则直接打印输出 String() 方法的结果; 否则, 会通过反射来遍历对象的成员进行打印.\n因为 Student 结构体没有实现 String() 方法, 所以 fmt.Println 会利用反射挨个打印成员变量:\npackage main import \u0026#34;fmt\u0026#34; type Student struct { Name string Age int } func main() { s := Student{ Name: \u0026#34;zzz\u0026#34;, Age: 18, } fmt.Println(s) // {zzz 18} } 增加一个 String() 方法的实现:\nimport \u0026#34;fmt\u0026#34; func (s Student) String() string { return fmt.Sprintf(\u0026#34;[Name: %s], [Age: %d]\u0026#34;, s.Name, s.Age) // [Name: zzz], [Age: 18] } 修改 String() 方法:\nimport \u0026#34;fmt\u0026#34; func (s *Student) String() string { return fmt.Sprintf(\u0026#34;[Name: %s], [Age: %d]\u0026#34;, s.Name, s.Age) // {zzz 18} } 打印结果并没用调用 String() ,因为:\n 类型 T 只有接受者是 T 的方法; 而类型 *T 拥有接受者是 T 和 *T 的方法. 语法上 T 能直接调 *T 的方法仅仅是 Go 的语法糖.\n 要调用 String() 需要:\nfmt.Println(\u0026amp;s) 接口转换的原理 类型有 m 个方法, 某接口有 n 个方法, 则很容易知道这种判定的时间复杂度为 O(mn); Go 会对方法集的函数按照函数名的字典序进行排序, 所以实际的时间复杂度为 O(m+n).\npackage main import \u0026#34;fmt\u0026#34; type coder interface { code() run() } type runner interface { run() } type Gopher struct { language string } func (g Gopher) code() { return } func (g Gopher) run() { return } func main() { var c coder = Gopher{} var r runner r = c fmt.Println(c, r) } Gopher 类型同时满足 coder 接口和 runner 接口.\nconvI2I 函数将一个 interface 转换成 另一个 interface .\nfunc convI2I(inter *interfacetype, i iface) (r iface) { tab := i.tab if tab == nil { return } if tab.inter == inter { r.tab = tab r.data = i.data return } r.tab = getitab(inter, tab._type, false) r.data = i.data return } inter 表示要转成的接口类型, i 表示一个实体类型. 如果要转换的接口类型和实体类型的接口类型相同就直接返回; 否则就用调用 getitab 函数去匹配满转方法集的接口.\nimport \u0026#34;unsafe\u0026#34; func getitab(inter *interfacetype, typ *_type, canfail bool) *itab { if len(inter.mhdr) == 0 { throw(\u0026#34;internal error - misuse of itab\u0026#34;) } // easy case  if typ.tflag\u0026amp;tflagUncommon == 0 { if canfail { return nil } name := inter.typ.nameOff(inter.mhdr[0].name) panic(\u0026amp;TypeAssertionError{nil, typ, \u0026amp;inter.typ, name.name()}) } var m *itab // First, look in the existing table to see if we can find the itab we need.  // This is by far the most common case, so do it without locks.  // Use atomic to ensure we see any previous writes done by the thread  // that updates the itabTable field (with atomic.Storep in itabAdd).  t := (*itabTableType)(atomic.Loadp(unsafe.Pointer(\u0026amp;itabTable))) if m = t.find(inter, typ); m != nil { goto finish } // Not found. Grab the lock and try again.  lock(\u0026amp;itabLock) if m = itabTable.find(inter, typ); m != nil { unlock(\u0026amp;itabLock) goto finish } // Entry doesn\u0026#39;t exist yet. Make a new entry \u0026amp; add it.  m = (*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*sys.PtrSize, 0, \u0026amp;memstats.other_sys)) m.inter = inter m._type = typ // The hash is used in type switches. However, compiler statically generates itab\u0026#39;s  // for all interface/type pairs used in switches (which are added to itabTable  // in itabsinit). The dynamically-generated itab\u0026#39;s never participate in type switches,  // and thus the hash is irrelevant.  // Note: m.hash is _not_ the hash used for the runtime itabTable hash table.  m.hash = 0 m.init() itabAdd(m) unlock(\u0026amp;itabLock) finish: if m.fun[0] != 0 { return m } if canfail { return nil } // this can only happen if the conversion  // was already done once using the , ok form  // and we have a cached negative result.  // The cached result doesn\u0026#39;t record which  // interface function was missing, so initialize  // the itab again to get the missing function name.  panic(\u0026amp;TypeAssertionError{concrete: typ, asserted: \u0026amp;inter.typ, missingMethod: m.init()}) } getitab 函数会根据 interfacetype 和 _type 去全局的 itab 哈希表中查找, 如果能找到, 则直接返回; 否则, 会根据给定的 interfacetype 和 _type 新生成一个 itab, 并插入到 itab 哈希表, 这样下一次就可以直接拿到 itab.\n这里查找了两次, 并且第二次上锁了, 这是因为如果第一次没找到, 在第二次仍然没有找到相应的 itab 的情况下, 需要新生成一个, 并且写入哈希表, 因此需要加锁. 这样, 其他协程在查找相同的 itab 并且也没有找到时, 第二次查找时, 会被挂住, 之后, 就会查到第一个协程写入哈希表的 itab.\nitabAdd 函数会把 itab 写入到全局itabTable\nimport \u0026#34;unsafe\u0026#34; func itabAdd(m *itab) { // Bugs can lead to calling this while mallocing is set,  // typically because this is called while panicing.  // Crash reliably, rather than only when we need to grow  // the hash table.  if getg().m.mallocing != 0 { throw(\u0026#34;malloc deadlock\u0026#34;) } t := itabTable if t.count \u0026gt;= 3*(t.size/4) { // 75% load factor  // Grow hash table.  // t2 = new(itabTableType) + some additional entries  // We lie and tell malloc we want pointer-free memory because  // all the pointed-to values are not in the heap.  t2 := (*itabTableType)(mallocgc((2+2*t.size)*sys.PtrSize, nil, true)) t2.size = t.size * 2 // Copy over entries.  // Note: while copying, other threads may look for an itab and  // fail to find it. That\u0026#39;s ok, they will then try to get the itab lock  // and as a consequence wait until this copying is complete.  iterate_itabs(t2.add) if t2.count != t.count { throw(\u0026#34;mismatched count during itab table copy\u0026#34;) } // Publish new hash table. Use an atomic write: see comment in getitab.  atomicstorep(unsafe.Pointer(\u0026amp;itabTable), unsafe.Pointer(t2)) // Adopt the new table as our own.  t = itabTable // Note: the old table can be GC\u0026#39;ed here.  } t.add(m) } func iterate_itabs(fn func(*itab)) { // Note: only runs during stop the world or with itabLock held,  // so no other locks/atomics needed.  t := itabTable for i := uintptr(0); i \u0026lt; t.size; i++ { m := *(**itab)(add(unsafe.Pointer(\u0026amp;t.entries), i*sys.PtrSize)) if m != nil { fn(m) } } } 如何用 interface 实现多态 多态是一种运行期的行为, 它有以下几个特点:\n 一种类型具有多种类型的能力 允许不同的对象对同一消息做出灵活的反应 以一种通用的方式对待个使用的对象 非动态语言必须通过继承和接口的方式来实现   package main import \u0026#34;fmt\u0026#34; func main() { s := Student{age: 18} whatJob(\u0026amp;s) growUp(\u0026amp;s) fmt.Println(s) p := Programmer{age: 100} whatJob(p) growUp(p) fmt.Println(p) } func whatJob(p Person) { p.job() } func growUp(p Person) { p.growUp() } type Person interface { job() growUp() } type Student struct { age int } func (p Student) job() { fmt.Println(\u0026#34;I am a student.\u0026#34;) return } func (p *Student) growUp() { p.age += 1 return } type Programmer struct { age int } func (p Programmer) job() { fmt.Println(\u0026#34;I am a programmer.\u0026#34;) return } func (p Programmer) growUp() { p.age += 10 return } Go 接口与 C++ 接口有何异同 接口定义了一种规范, 描述了类的行为和功能, 而不做具体实现.\nC++ 的接口是使用抽象类来实现的, 如果类中至少有一个函数被声明为纯虚函数, 则这个类就是抽象类. 纯虚函数是通过在声明中使用 \u0026ldquo;= 0\u0026rdquo; 来指定的. 例如:\nclass Shape { public: // 纯虚函数  virtual double getArea() = 0; private: string name; // 名称 };  设计抽象类的目的, 是为了给其他类提供一个可以继承的适当的基类. 抽象类不能被用于实例化对象, 它只能作为接口使用. 派生类需要明确地声明它继承自基类, 并且需要实现基类中所有的纯虚函数.\nC++ 定义接口的方式称为“侵入式”, 而 Go 采用的是 “非侵入式”, 不需要显式声明, 只需要实现接口定义的函数, 编译器自动会识别.\nC++ 和 Go 在定义接口方式上的不同, 也导致了底层实现上的不同. C++ 通过虚函数表来实现基类调用派生类的函数; 而 Go 通过 itab 中的 fun 字段来实现接口变量调用实体类型的函数. C++ 中的虚函数表是在编译期生成的; 而 Go 的 itab 中的 fun 字段是在运行期间动态生成的. 原因在于, Go 中实体类型可能会无意中实现 N 多接口, 很多接口并不是本来需要的, 所以不能为类型实现的所有接口都生成一个 itab, 这也是“非侵入式”带来的影响; 这在 C++ 中是不存在的, 因为派生需要显示声明它继承自哪个基类.\n ","permalink":"https://zakudriver.github.io/posts/interface%E7%B1%BB%E5%9E%8B/","summary":"Go 语言与鸭子类型的关系  If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.\n如果某个东西长得像鸭子, 像鸭子一样游泳, 像鸭子一样嘎嘎叫, 那它就可以被看成是一只鸭子.\n在 Go 语言中, 如果类型的方法集完全包含接口的方法集，则可认为该类型实现了该接口.\n 鸭子类型是一种动态语言的风格, 在这种风格中, 一个对象有效的语义, 不是由继承自特定的类或实现特定的接口, 而是由它\u0026quot;当前方法和属性的集合\u0026quot;决定. Go 作为一种静态语言, 通过接口实现了 鸭子类型, 实际上是 Go 的编译器在其中作了隐匿的转换工作.\n值接收者和指针接收者的区别 package main import \u0026#34;fmt\u0026#34; type Person struct { age int } func (p Person) howOld() int { return p.age } func (p *Person) growUp() { p.","title":"interface类型"},{"content":"C++ #include \u0026lt;iostream\u0026gt;using namespace std; typedef int Data; struct Node { Data data; Node *next; Node(Data d = 0, Node *n = NULL) : data(d), next(n){}; }; class LinkedList { public: LinkedList(int len) : len(len), head(NULL){}; bool is_empty(); Data get(int); void insert(int, Data); void remove(int); void modify(int, Data); void print_all(); private: Node *head; int len; void check_index(int); Node *get_by_index(int); }; void LinkedList::check_index(int index) { if (index \u0026gt; len || index \u0026lt; 0) { printf(\u0026#34;error: 索引越界.\u0026#34;); exit(-1); } } Node *LinkedList::get_by_index(int index) { check_index(index); Node *p = head; int i = 0; while (i++ \u0026lt; index) { p = p-\u0026gt;next; } return p; } bool LinkedList::is_empty() { return len == 0; } Data LinkedList::get(int index) { return get_by_index(index)-\u0026gt;data; } void LinkedList::insert(int index, Data value) { check_index(index); Node *n = new Node(value); Node *p = head; if (index == 0) { head = n; head-\u0026gt;next = p; len++; return; } int i = 1; while (p != NULL \u0026amp;\u0026amp; i++ \u0026lt; index) { p = p-\u0026gt;next; } if (p == NULL) { printf(\u0026#34;error: 链表中存在空指针\u0026#34;); return; } n-\u0026gt;next = p-\u0026gt;next; p-\u0026gt;next = n; len++; } void LinkedList::remove(int index) { check_index(index); Node *p = head; while (index-- \u0026gt; 1) { p = p-\u0026gt;next; } p-\u0026gt;next = p-\u0026gt;next-\u0026gt;next; delete p-\u0026gt;next; len--; } void LinkedList::modify(int index, Data value) { get_by_index(index)-\u0026gt;data = value; } void LinkedList::print_all() { Node *p = head; int i = len; while (i-- \u0026gt; 0) { cout \u0026lt;\u0026lt; p-\u0026gt;data \u0026lt;\u0026lt; endl; p = p-\u0026gt;next; } } int main() { LinkedList *l = new LinkedList(0); l-\u0026gt;insert(0, 1); l-\u0026gt;insert(1, 2); l-\u0026gt;insert(1, 3); l-\u0026gt;insert(0, 4); l-\u0026gt;modify(3, 10); l-\u0026gt;print_all(); return 0; } Go package main import \u0026#34;fmt\u0026#34; type Data int type Maper interface { Is_empty() bool Get(int) Data Insert(int, Data) Remove(int) Modify(int, Data) Print_all() } type Node struct { Data next *Node } type LinkedList struct { Len int head *Node } // check_index ... func (l *LinkedList) check_index(index int) { if index \u0026gt; l.Len || index \u0026lt; 0 { panic(\u0026#34;error: 索引越界.\u0026#34;) } } // Is_empty ... func (l *LinkedList) Is_empty() bool { return l.Len == 0 } // Get ... func (l *LinkedList) Get(index int) Data { return l.get(index).Data } // get ... func (l *LinkedList) get(index int) *Node { l.check_index(index) p := l.head i := index for i \u0026lt; index { p = p.next i++ } return p } // Insert ... func (l *LinkedList) Insert(index int, value Data) { l.check_index(index) n := new(Node) n.Data = value p := l.head if index == 0 { l.head = n l.head.next = p l.Len++ return } i := 1 for p != nil \u0026amp;\u0026amp; i \u0026lt; index { p = p.next i++ } if p == nil { panic(\u0026#34;error: 链表中存在空指针\u0026#34;) } n.next = p.next p.next = n l.Len++ } // Remove ... func (l *LinkedList) Remove(index int) { l.check_index(index) p := l.head for index \u0026gt; 1 { p = p.next index-- } p.next = p.next.next l.Len-- } // Modify ... func (l *LinkedList) Modify(index int, value Data) { l.get(index).Data = value } // Print_all ... func (l *LinkedList) Print_all() { p := l.head for i := l.Len; i \u0026gt; 0; i-- { fmt.Println(p.Data) p = p.next } } func main() { var l = new(LinkedList) l.Insert(0, 1) l.Insert(1, 2) l.Insert(1, 3) l.Print_all() } ","permalink":"https://zakudriver.github.io/posts/linkedlist/","summary":"C++ #include \u0026lt;iostream\u0026gt;using namespace std; typedef int Data; struct Node { Data data; Node *next; Node(Data d = 0, Node *n = NULL) : data(d), next(n){}; }; class LinkedList { public: LinkedList(int len) : len(len), head(NULL){}; bool is_empty(); Data get(int); void insert(int, Data); void remove(int); void modify(int, Data); void print_all(); private: Node *head; int len; void check_index(int); Node *get_by_index(int); }; void LinkedList::check_index(int index) { if (index \u0026gt; len || index \u0026lt; 0) { printf(\u0026#34;error: 索引越界.","title":"LinkedList"},{"content":"// 文字超出省略号 .text-overflow { overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } // 文字超出两行省略号, block元素 .text-overflow-2 { word-break: break-all; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; line-clamp: 2; -webkit-box-orient: vertical; } ","permalink":"https://zakudriver.github.io/posts/%E6%96%87%E5%AD%97%E8%B6%85%E5%87%BA%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7/","summary":"// 文字超出省略号 .text-overflow { overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } // 文字超出两行省略号, block元素 .text-overflow-2 { word-break: break-all; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; line-clamp: 2; -webkit-box-orient: vertical; } ","title":"文字超出显示省略号"},{"content":"#include \u0026lt;iostream\u0026gt;#include \u0026lt;stack\u0026gt;#include \u0026lt;stdlib.h\u0026gt;using namespace std; class List { public: List(int len = 10) : len(len) { used = 0; p = (int *)malloc(sizeof(int) * len); } int len; int used; int *p; bool is_full(); bool is_empty(); void push(int); int get(int); void insert(int, int); void remove(int); void print_all(); private: void check_index(int); }; bool List::is_full() { return len == used; } bool List::is_empty() { return used == 0; } void List::check_index(int index) { if (index \u0026gt; len - 1 || index \u0026lt; 0) { printf(\u0026#34;error: 索引越界.\u0026#34;); exit(-1); } } void List::push(int value) { if (used \u0026gt;= len) { printf(\u0026#34;error: 链表已满.\u0026#34;); } p[used] = value; used += 1; }; int List::get(int index) { check_index(index); return p[index]; } void List::insert(int index, int value) { check_index(index); if (index \u0026gt; used) { printf(\u0026#34;error: 索引越界.\u0026#34;); exit(-1); } while (used - index \u0026gt; 0) { used--; p[used] = p[used - 1]; } p[index] = value; used += 1; } void List::remove(int index) { check_index(index); if (index \u0026gt;= used) { printf(\u0026#34;error: 索引越界.\u0026#34;); exit(-1); } used--; for (int i = index; i \u0026lt; used; i++) { p[i] = p[i + 1]; } } void List::print_all() { for (int i = 0; i \u0026lt; used; i++) { cout \u0026lt;\u0026lt; get(i) \u0026lt;\u0026lt; endl; } } int main() { List l(5); l.push(10); l.push(20); l.insert(2, 5); l.remove(0); l.print_all(); return 0; } ","permalink":"https://zakudriver.github.io/posts/list/","summary":"#include \u0026lt;iostream\u0026gt;#include \u0026lt;stack\u0026gt;#include \u0026lt;stdlib.h\u0026gt;using namespace std; class List { public: List(int len = 10) : len(len) { used = 0; p = (int *)malloc(sizeof(int) * len); } int len; int used; int *p; bool is_full(); bool is_empty(); void push(int); int get(int); void insert(int, int); void remove(int); void print_all(); private: void check_index(int); }; bool List::is_full() { return len == used; } bool List::is_empty() { return used == 0; } void List::check_index(int index) { if (index \u0026gt; len - 1 || index \u0026lt; 0) { printf(\u0026#34;error: 索引越界.","title":"List"},{"content":"线程: 执行指令序列 保留了并发的优点, 避免了进程切换的代价. 实质: 映射表不变, PC指针变.\n价值, 用处 浏览器\n 一个线程用来从服务器接收数据 一个线程用来显示文本 一个线程用来处理图片(解压缩) 一个线程用来显示图片  接收数据线程等待时可以切换到另一个线程(如显示文本), 更加高效利用CPU, 程序交互更加人性化.\n线程切换 多线程执行互不干扰, 所以一个线程执行序列对应一个(或套)栈. 线程切换就是切换TCB.\nTCB (Thread Control Block) 保存线程的信息(执行序列的栈). 与PCB相似, 只是比PCB储存的信息少而已.\n用户级线程 用户态切来切去. CPL为3. TCB在用户程序中.\nvoid ThreadCeate(A) { TCB *tcb = malloc(); // 申请内存创建TCB  *stack = malloc(); // 创建栈  *stack = A; // 保存栈  tcb.esp = stack } // 线程切换 void Yield() { TCB2.esp = esp; esp = TCB1.esp; // esp: CPU寄存器  // jmp xxx; // 不需要再jmp xxx, 因为调用Yield时已经把Yield后面执行的内容压栈. } 缺点 一个进程里的某个用户级线程触发系统IO(如网卡, 磁盘等)后系统会切换到其他进程执行. 这个进程其他线程就无法执行.\n核心级线程 多\u0026quot;套\u0026quot;(用户栈 + 内核栈)TCB在内核中. 中断进入内核\n优点 多核心CPU支持, 核心级线程可以并行执行.\n","permalink":"https://zakudriver.github.io/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","summary":"线程: 执行指令序列 保留了并发的优点, 避免了进程切换的代价. 实质: 映射表不变, PC指针变.\n价值, 用处 浏览器\n 一个线程用来从服务器接收数据 一个线程用来显示文本 一个线程用来处理图片(解压缩) 一个线程用来显示图片  接收数据线程等待时可以切换到另一个线程(如显示文本), 更加高效利用CPU, 程序交互更加人性化.\n线程切换 多线程执行互不干扰, 所以一个线程执行序列对应一个(或套)栈. 线程切换就是切换TCB.\nTCB (Thread Control Block) 保存线程的信息(执行序列的栈). 与PCB相似, 只是比PCB储存的信息少而已.\n用户级线程 用户态切来切去. CPL为3. TCB在用户程序中.\nvoid ThreadCeate(A) { TCB *tcb = malloc(); // 申请内存创建TCB  *stack = malloc(); // 创建栈  *stack = A; // 保存栈  tcb.esp = stack } // 线程切换 void Yield() { TCB2.esp = esp; esp = TCB1.","title":"多线程"},{"content":"进程: 进行中的程序 进行中的程序与磁盘中的静态程序不一样. 进程是描述一个运行中的程序. 进程 = 资源(映射表) + 多个执行指令序列(线程) 进程只能在内核. 要分配资源, 访问文件.\n 有开始, 结束 走走停停(切换) 需要记录  为了充分使用CPU 一次IO操作对应数百万(很多很多)次CPU计算操作. 为了充分合理使用CPU, 需要多个进程交替执行. \u0026ndash; [并发]\n多进程是操作系统的核心 操作系统的核心就是记录, 管理, 合理推进多个进程. 使用计算机就是启用多个进程.\n多进程的组织 PCB + 状态 + 队列\nPCB(Proess Control Block) 记录进程信息的数据结构. 便于切回时继续执行.\n状态  就绪态 阻塞态 运行态  就绪态 \u0026mdash;\u0026mdash;\u0026ndash;\u0026gt;\u0026gt; 运行态 \\ / \\ / 阻塞态\n队列  就绪队列 PCB1 \u0026ndash; PCB3 \u0026ndash; PCB5 磁盘等待队列 PCB2 \u0026ndash; PCB4 \u0026ndash; PCB6  多进程的交替 队列 + 调度 + 切换\nvoid schedule() { pNew = getNext(ReadyQueue); // 调度  switch_to(pCur, pNew); // pCur, pNew PCB } 把当前进程保存起来, 切入另一个的进程.\nvoid swtich_to(pCur, pNew) { pCur.ax = CPU.ax; pCur.bx = CPU.bx; // ...  pCur.cs = CPU.cs; pCur.retpc = CPU.pc; CPU.ax = pNew.ax; CPU.bx = pNew.bx; // ...  CPU.cs = pNew.cs; CPU.pc = pNew.retpc; } 多进程的内存管理 通过映射表实现内存地址空间的分离.\n进程1 内存地址[100] \u0026mdash;\u0026gt; 进程1的映射表 \u0026mdash;-\u0026gt; 物理内存 780 进程2 内存地址[100] \u0026mdash;\u0026gt; 进程2的映射表 \u0026mdash;-\u0026gt; 物理内存 1260\n多进程的合作 生产者与消费者 进程同步 不能随意切换进程, 必须同步进程合理切换.\n","permalink":"https://zakudriver.github.io/posts/%E5%A4%9A%E8%BF%9B%E7%A8%8B/","summary":"进程: 进行中的程序 进行中的程序与磁盘中的静态程序不一样. 进程是描述一个运行中的程序. 进程 = 资源(映射表) + 多个执行指令序列(线程) 进程只能在内核. 要分配资源, 访问文件.\n 有开始, 结束 走走停停(切换) 需要记录  为了充分使用CPU 一次IO操作对应数百万(很多很多)次CPU计算操作. 为了充分合理使用CPU, 需要多个进程交替执行. \u0026ndash; [并发]\n多进程是操作系统的核心 操作系统的核心就是记录, 管理, 合理推进多个进程. 使用计算机就是启用多个进程.\n多进程的组织 PCB + 状态 + 队列\nPCB(Proess Control Block) 记录进程信息的数据结构. 便于切回时继续执行.\n状态  就绪态 阻塞态 运行态  就绪态 \u0026mdash;\u0026mdash;\u0026ndash;\u0026gt;\u0026gt; 运行态 \\ / \\ / 阻塞态\n队列  就绪队列 PCB1 \u0026ndash; PCB3 \u0026ndash; PCB5 磁盘等待队列 PCB2 \u0026ndash; PCB4 \u0026ndash; PCB6  多进程的交替 队列 + 调度 + 切换","title":"多进程"},{"content":"// 硬编码一个二进制 trie type BinaryTrie = [ [ [ [ [[[[0, 1], [2, 3]], [[4, 5], [6, 7]]], [[[8, 9], [10, 11]], [[12, 13], [14, 15]]]], [[[[16, 17], [18, 19]], [[20, 21], [22, 23]]], [[[24, 25], [26, 27]], [[28, 29], [30, 31]]]] ], [ [[[[32, 33], [34, 35]], [[36, 37], [38, 39]]], [[[40, 41], [42, 43]], [[44, 45], [46, 47]]]], [[[[48, 49], [50, 51]], [[52, 53], [54, 55]]], [[[56, 57], [58, 59]], [[60, 61], [62, 63]]]] ] ], [ [ [[[[64, 65], [66, 67]], [[68, 69], [70, 71]]], [[[72, 73], [74, 75]], [[76, 77], [78, 79]]]], [[[[80, 81], [82, 83]], [[84, 85], [86, 87]]], [[[88, 89], [90, 91]], [[92, 93], [94, 95]]]] ], [ [[[[96, 97], [98, 99]], [[100, 101], [102, 103]]], [[[104, 105], [106, 107]], [[108, 109], [110, 111]]]], [[[[112, 113], [114, 115]], [[116, 117], [118, 119]]], [[[120, 121], [122, 123]], [[124, 125], [126, 127]]]] ] ] ], [ [ [ [[[[128, 129], [130, 131]], [[132, 133], [134, 135]]], [[[136, 137], [138, 139]], [[140, 141], [142, 143]]]], [[[[144, 145], [146, 147]], [[148, 149], [150, 151]]], [[[152, 153], [154, 155]], [[156, 157], [158, 159]]]] ], [ [[[[160, 161], [162, 163]], [[164, 165], [166, 167]]], [[[168, 169], [170, 171]], [[172, 173], [174, 175]]]], [[[[176, 177], [178, 179]], [[180, 181], [182, 183]]], [[[184, 185], [186, 187]], [[188, 189], [190, 191]]]] ] ], [ [ [[[[192, 193], [194, 195]], [[196, 197], [198, 199]]], [[[200, 201], [202, 203]], [[204, 205], [206, 207]]]], [[[[208, 209], [210, 211]], [[212, 213], [214, 215]]], [[[216, 217], [218, 219]], [[220, 221], [222, 223]]]] ], [ [[[[224, 225], [226, 227]], [[228, 229], [230, 231]]], [[[232, 233], [234, 235]], [[236, 237], [238, 239]]]], [[[[240, 241], [242, 243]], [[244, 245], [246, 247]]], [[[248, 249], [250, 251]], [[252, 253], [254, 255]]]] ] ] ] ]; // 数组操作 type Copy\u0026lt;T, S extends any\u0026gt; = { [P in keyof T]: S[P] }; type Unshift\u0026lt;T, A\u0026gt; = ((a: A, ...b: T extends any[] ? T : never) =\u0026gt; void) extends (...a: infer R) =\u0026gt; void ? R : never; type Push\u0026lt;T, A\u0026gt; = Copy\u0026lt;Unshift\u0026lt;T, any\u0026gt;, T \u0026amp; Record\u0026lt;string, A\u0026gt;\u0026gt;; // 搜索二进制 trie type SearchInTrie\u0026lt;Num, Node, Digits\u0026gt; = { 1: Node extends [infer A, infer B] ? Num extends A ? Push\u0026lt;Digits, 0\u0026gt; : Num extends B ? Push\u0026lt;Digits, 1\u0026gt; : never : never; 0: Node extends [infer A, infer B] ? SearchInTrie\u0026lt;Num, A, Push\u0026lt;Digits, 0\u0026gt;\u0026gt; | SearchInTrie\u0026lt;Num, B, Push\u0026lt;Digits, 1\u0026gt;\u0026gt; : never; }[Node extends [number, number] ? 1 : 0]; // 定义数字类型 type Digit = 0 | 1; type Bits = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7; type Uint8 = Record\u0026lt;Bits, Digit\u0026gt;; // 也可以定义成8个Digit的数组，这样写比较简短  type AsDigit\u0026lt;T\u0026gt; = T extends Digit ? T : never; type AsUint8\u0026lt;T\u0026gt; = T extends Uint8 ? T : never; // 数字转二进制表示 type ToUint8\u0026lt;A extends number\u0026gt; = SearchInTrie\u0026lt;A, BinaryTrie, []\u0026gt;; // 二进制表示转数字 type ToNumber\u0026lt;A extends Uint8\u0026gt; = BinaryTrie[A[0]][A[1]][A[2]][A[3]][A[4]][A[5]][A[6]][A[7]]; // 两个1 bit数相加，C 表示进位 type BitAdd\u0026lt;A extends Digit, B extends Digit, C extends Digit\u0026gt; = [ [[[0, 0], [1, 0]], [[1, 0], [0, 1]]], [[[1, 0], [0, 1]], [[0, 1], [1, 1]]] ][A][B][C]; // 8位数相加 type Uint8Add\u0026lt;A extends Uint8, B extends Uint8\u0026gt; = BitAdd\u0026lt;A[7], B[7], 0\u0026gt; extends [infer S7, infer C] ? BitAdd\u0026lt;A[6], B[6], AsDigit\u0026lt;C\u0026gt;\u0026gt; extends [infer S6, infer C] ? BitAdd\u0026lt;A[5], B[5], AsDigit\u0026lt;C\u0026gt;\u0026gt; extends [infer S5, infer C] ? BitAdd\u0026lt;A[4], B[4], AsDigit\u0026lt;C\u0026gt;\u0026gt; extends [infer S4, infer C] ? BitAdd\u0026lt;A[3], B[3], AsDigit\u0026lt;C\u0026gt;\u0026gt; extends [infer S3, infer C] ? BitAdd\u0026lt;A[2], B[2], AsDigit\u0026lt;C\u0026gt;\u0026gt; extends [infer S2, infer C] ? BitAdd\u0026lt;A[1], B[1], AsDigit\u0026lt;C\u0026gt;\u0026gt; extends [infer S1, infer C] ? BitAdd\u0026lt;A[0], B[0], AsDigit\u0026lt;C\u0026gt;\u0026gt; extends [infer S0, infer C] // ? C extends 1 ? \u0026#34;overflow\u0026#34; :  ? AsUint8\u0026lt;[S0, S1, S2, S3, S4, S5, S6, S7]\u0026gt; : never : never : never : never : never : never : never : never; // 位取反 type Reverse = [1, 0]; type Uint8Reverse\u0026lt;A extends Uint8\u0026gt; = [ Reverse[A[0]], Reverse[A[1]], Reverse[A[2]], Reverse[A[3]], Reverse[A[4]], Reverse[A[5]], Reverse[A[6]], Reverse[A[7]] ]; // 两个特殊数字方便使用 type ZERO = [0, 0, 0, 0, 0, 0, 0, 0]; type ONE = [0, 0, 0, 0, 0, 0, 0, 1]; // 补码 type Uint8Negate\u0026lt;A extends Uint8\u0026gt; = Uint8Add\u0026lt;Uint8Reverse\u0026lt;A\u0026gt;, ONE\u0026gt;; // 8位数相减 type Uint8Sub\u0026lt;A extends Uint8, B extends Uint8\u0026gt; = Uint8Add\u0026lt;A, Uint8Negate\u0026lt;B\u0026gt;\u0026gt;; // 左移 type LShift\u0026lt;A extends Uint8, B extends number, P extends Digit\u0026gt; = B extends 1 ? [A[1], A[2], A[3], A[4], A[5], A[6], A[7], P] : B extends 2 ? [A[2], A[3], A[4], A[5], A[6], A[7], P, P] : B extends 3 ? [A[3], A[4], A[5], A[6], A[7], P, P, P] : B extends 4 ? [A[4], A[5], A[6], A[7], P, P, P, P] : B extends 5 ? [A[5], A[6], A[7], P, P, P, P, P] : B extends 6 ? [A[6], A[7], P, P, P, P, P, P] : B extends 7 ? [A[7], P, P, P, P, P, P, P] : B extends 0 ? A : [P, P, P, P, P, P, P, P]; // 8位数乘1位数 type BitMul\u0026lt;A extends Uint8, B extends Digit, C extends Bits\u0026gt; = B extends 1 ? LShift\u0026lt;A, C, 0\u0026gt; : ZERO; // 8位数相乘 type Uint8Mul\u0026lt;A extends Uint8, B extends Uint8\u0026gt; = Uint8Add\u0026lt;ZERO, BitMul\u0026lt;A, B[7], 0\u0026gt;\u0026gt; extends infer S ? Uint8Add\u0026lt;AsUint8\u0026lt;S\u0026gt;, BitMul\u0026lt;A, B[6], 1\u0026gt;\u0026gt; extends infer S ? Uint8Add\u0026lt;AsUint8\u0026lt;S\u0026gt;, BitMul\u0026lt;A, B[5], 2\u0026gt;\u0026gt; extends infer S ? Uint8Add\u0026lt;AsUint8\u0026lt;S\u0026gt;, BitMul\u0026lt;A, B[4], 3\u0026gt;\u0026gt; extends infer S ? Uint8Add\u0026lt;AsUint8\u0026lt;S\u0026gt;, BitMul\u0026lt;A, B[3], 4\u0026gt;\u0026gt; extends infer S ? Uint8Add\u0026lt;AsUint8\u0026lt;S\u0026gt;, BitMul\u0026lt;A, B[2], 5\u0026gt;\u0026gt; extends infer S ? Uint8Add\u0026lt;AsUint8\u0026lt;S\u0026gt;, BitMul\u0026lt;A, B[1], 6\u0026gt;\u0026gt; extends infer S ? Uint8Add\u0026lt;AsUint8\u0026lt;S\u0026gt;, BitMul\u0026lt;A, B[0], 7\u0026gt;\u0026gt; : never : never : never : never : never : never : never; // 比较结果 type EQ = 0; type GT = 1; type LT = 2; // 1位数比较 type BitCMP\u0026lt;A extends Digit, B extends Digit\u0026gt; = [[EQ, LT], [GT, EQ]][A][B]; // 8位数比较 type Uint8CMP\u0026lt;A extends Uint8, B extends Uint8\u0026gt; = BitCMP\u0026lt;A[0], B[0]\u0026gt; extends GT | LT ? BitCMP\u0026lt;A[0], B[0]\u0026gt; : BitCMP\u0026lt;A[1], B[1]\u0026gt; extends GT | LT ? BitCMP\u0026lt;A[1], B[1]\u0026gt; : BitCMP\u0026lt;A[2], B[2]\u0026gt; extends GT | LT ? BitCMP\u0026lt;A[2], B[2]\u0026gt; : BitCMP\u0026lt;A[3], B[3]\u0026gt; extends GT | LT ? BitCMP\u0026lt;A[3], B[3]\u0026gt; : BitCMP\u0026lt;A[4], B[4]\u0026gt; extends GT | LT ? BitCMP\u0026lt;A[4], B[4]\u0026gt; : BitCMP\u0026lt;A[5], B[5]\u0026gt; extends GT | LT ? BitCMP\u0026lt;A[5], B[5]\u0026gt; : BitCMP\u0026lt;A[6], B[6]\u0026gt; extends GT | LT ? BitCMP\u0026lt;A[6], B[6]\u0026gt; : BitCMP\u0026lt;A[7], B[7]\u0026gt;; // 简单求余 type Remainder\u0026lt;A extends Uint8, B extends Uint8\u0026gt; = Uint8CMP\u0026lt;A, B\u0026gt; extends LT ? [0, A] : [1, Uint8Sub\u0026lt;A, B\u0026gt;]; // 8位数相除 type Uint8Div\u0026lt;A extends Uint8, B extends Uint8\u0026gt; = Remainder\u0026lt;LShift\u0026lt;ZERO, 1, A[0]\u0026gt;, B\u0026gt; extends [infer Q0, infer R] ? Remainder\u0026lt;LShift\u0026lt;AsUint8\u0026lt;R\u0026gt;, 1, A[1]\u0026gt;, B\u0026gt; extends [infer Q1, infer R] ? Remainder\u0026lt;LShift\u0026lt;AsUint8\u0026lt;R\u0026gt;, 1, A[2]\u0026gt;, B\u0026gt; extends [infer Q2, infer R] ? Remainder\u0026lt;LShift\u0026lt;AsUint8\u0026lt;R\u0026gt;, 1, A[3]\u0026gt;, B\u0026gt; extends [infer Q3, infer R] ? Remainder\u0026lt;LShift\u0026lt;AsUint8\u0026lt;R\u0026gt;, 1, A[4]\u0026gt;, B\u0026gt; extends [infer Q4, infer R] ? Remainder\u0026lt;LShift\u0026lt;AsUint8\u0026lt;R\u0026gt;, 1, A[5]\u0026gt;, B\u0026gt; extends [infer Q5, infer R] ? Remainder\u0026lt;LShift\u0026lt;AsUint8\u0026lt;R\u0026gt;, 1, A[6]\u0026gt;, B\u0026gt; extends [infer Q6, infer R] ? Remainder\u0026lt;LShift\u0026lt;AsUint8\u0026lt;R\u0026gt;, 1, A[7]\u0026gt;, B\u0026gt; extends [infer Q7, infer R] ? [AsUint8\u0026lt;[Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7]\u0026gt;, AsUint8\u0026lt;R\u0026gt;] : never : never : never : never : never : never : never : never; // 加 type Add\u0026lt;A extends number, B extends number\u0026gt; = ToNumber\u0026lt;Uint8Add\u0026lt;ToUint8\u0026lt;A\u0026gt;, ToUint8\u0026lt;B\u0026gt;\u0026gt;\u0026gt;; // 减 type Sub\u0026lt;A extends number, B extends number\u0026gt; = ToNumber\u0026lt;Uint8Sub\u0026lt;ToUint8\u0026lt;A\u0026gt;, ToUint8\u0026lt;B\u0026gt;\u0026gt;\u0026gt;; // 乘 type Mul\u0026lt;A extends number, B extends number\u0026gt; = ToNumber\u0026lt;Uint8Mul\u0026lt;ToUint8\u0026lt;A\u0026gt;, ToUint8\u0026lt;B\u0026gt;\u0026gt;\u0026gt;; // 除 type Div\u0026lt;A extends number, B extends number\u0026gt; = B extends 0 ? never : ToNumber\u0026lt;Uint8Div\u0026lt;ToUint8\u0026lt;A\u0026gt;, ToUint8\u0026lt;B\u0026gt;\u0026gt;[0]\u0026gt;; // 取余 type Mod\u0026lt;A extends number, B extends number\u0026gt; = B extends 0 ? never : ToNumber\u0026lt;Uint8Div\u0026lt;ToUint8\u0026lt;A\u0026gt;, ToUint8\u0026lt;B\u0026gt;\u0026gt;[1]\u0026gt;; // 测试 type case1_ShouldBe99 = Add\u0026lt;33, 66\u0026gt;; // 33 + 66 = 99 type case2_ShouldBe0 = Add\u0026lt;255, 1\u0026gt;; // 255 + 1 = 0 (overflow)  const a: case1_ShouldBe99 = 99; type case3_ShouldBe99 = Sub\u0026lt;123, 24\u0026gt;; // 123 - 24 = 99 type case4_ShouldBe255 = Sub\u0026lt;0, 1\u0026gt;; // 0 - 1 = 255 (overflow)  type case5_ShouldBe153 = Mul\u0026lt;17, 9\u0026gt;; // 17 x 9 = 153 type case6_ShouldBe253 = Mul\u0026lt;255, 3\u0026gt;; // 255 x 3 = 253 (overflow)  type case7_ShouldBe33 = Div\u0026lt;100, 3\u0026gt;; // 100 / 3 = 33 type case8_ShouldBeNever = Div\u0026lt;1, 0\u0026gt;; // 1 / 0 = error (divide by 0)  type case9_ShouldBe1 = Mod\u0026lt;100, 3\u0026gt;; // 100 % 3 = 1 type case10_ShouldBeNever = Mod\u0026lt;1, 0\u0026gt;; // 1 % 0 = error (divide by 0) ","permalink":"https://zakudriver.github.io/posts/typescript%E5%85%83%E7%BC%96%E7%A8%8B/","summary":"// 硬编码一个二进制 trie type BinaryTrie = [ [ [ [ [[[[0, 1], [2, 3]], [[4, 5], [6, 7]]], [[[8, 9], [10, 11]], [[12, 13], [14, 15]]]], [[[[16, 17], [18, 19]], [[20, 21], [22, 23]]], [[[24, 25], [26, 27]], [[28, 29], [30, 31]]]] ], [ [[[[32, 33], [34, 35]], [[36, 37], [38, 39]]], [[[40, 41], [42, 43]], [[44, 45], [46, 47]]]], [[[[48, 49], [50, 51]], [[52, 53], [54, 55]]], [[[56, 57], [58, 59]], [[60, 61], [62, 63]]]] ] ], [ [ [[[[64, 65], [66, 67]], [[68, 69], [70, 71]]], [[[72, 73], [74, 75]], [[76, 77], [78, 79]]]], [[[[80, 81], [82, 83]], [[84, 85], [86, 87]]], [[[88, 89], [90, 91]], [[92, 93], [94, 95]]]] ], [ [[[[96, 97], [98, 99]], [[100, 101], [102, 103]]], [[[104, 105], [106, 107]], [[108, 109], [110, 111]]]], [[[[112, 113], [114, 115]], [[116, 117], [118, 119]]], [[[120, 121], [122, 123]], [[124, 125], [126, 127]]]] ] ] ], [ [ [ [[[[128, 129], [130, 131]], [[132, 133], [134, 135]]], [[[136, 137], [138, 139]], [[140, 141], [142, 143]]]], [[[[144, 145], [146, 147]], [[148, 149], [150, 151]]], [[[152, 153], [154, 155]], [[156, 157], [158, 159]]]] ], [ [[[[160, 161], [162, 163]], [[164, 165], [166, 167]]], [[[168, 169], [170, 171]], [[172, 173], [174, 175]]]], [[[[176, 177], [178, 179]], [[180, 181], [182, 183]]], [[[184, 185], [186, 187]], [[188, 189], [190, 191]]]] ] ], [ [ [[[[192, 193], [194, 195]], [[196, 197], [198, 199]]], [[[200, 201], [202, 203]], [[204, 205], [206, 207]]]], [[[[208, 209], [210, 211]], [[212, 213], [214, 215]]], [[[216, 217], [218, 219]], [[220, 221], [222, 223]]]] ], [ [[[[224, 225], [226, 227]], [[228, 229], [230, 231]]], [[[232, 233], [234, 235]], [[236, 237], [238, 239]]]], [[[[240, 241], [242, 243]], [[244, 245], [246, 247]]], [[[248, 249], [250, 251]], [[252, 253], [254, 255]]]] ] ] ] ]; // 数组操作 type Copy\u0026lt;T, S extends any\u0026gt; = { [P in keyof T]: S[P] }; type Unshift\u0026lt;T, A\u0026gt; = ((a: A, .","title":"typescript元编程"},{"content":"# .clang-format BasedOnStyle: LLVM Language:\tCpp IndentWidth : 2 # 开括号(开圆括号、开尖括号、开方括号)后的对齐: Align, DontAlign, AlwaysBreak(总是在开括号后换行) AlignAfterOpenBracket:\tAlign # 大括号换行，只有当BreakBeforeBraces设置为Custom时才有效 BraceWrapping: # class定义后面 AfterClass:\tfalse # 控制语句后面 AfterControlStatement:\tfalse # enum定义后面 AfterEnum:\tfalse # 函数定义后面 AfterFunction:\ttrue # 命名空间定义后面 AfterNamespace:\tfalse # ObjC定义后面 AfterObjCDeclaration:\tfalse # struct定义后面 AfterStruct:\tfalse # union定义后面 AfterUnion:\tfalse # catch之前 BeforeCatch:\ttrue # else之前 BeforeElse:\ttrue # 缩进大括号 IndentBraces:\tfalse BreakBeforeBraces:\tCustom ","permalink":"https://zakudriver.github.io/posts/clang-format/","summary":"# .clang-format BasedOnStyle: LLVM Language:\tCpp IndentWidth : 2 # 开括号(开圆括号、开尖括号、开方括号)后的对齐: Align, DontAlign, AlwaysBreak(总是在开括号后换行) AlignAfterOpenBracket:\tAlign # 大括号换行，只有当BreakBeforeBraces设置为Custom时才有效 BraceWrapping: # class定义后面 AfterClass:\tfalse # 控制语句后面 AfterControlStatement:\tfalse # enum定义后面 AfterEnum:\tfalse # 函数定义后面 AfterFunction:\ttrue # 命名空间定义后面 AfterNamespace:\tfalse # ObjC定义后面 AfterObjCDeclaration:\tfalse # struct定义后面 AfterStruct:\tfalse # union定义后面 AfterUnion:\tfalse # catch之前 BeforeCatch:\ttrue # else之前 BeforeElse:\ttrue # 缩进大括号 IndentBraces:\tfalse BreakBeforeBraces:\tCustom ","title":"clang-format"},{"content":" 所有的快乐，其本质都是否定的，而痛苦的本质却是肯定的。\n ","permalink":"https://zakudriver.github.io/about/","summary":" 所有的快乐，其本质都是否定的，而痛苦的本质却是肯定的。\n ","title":"About"},{"content":"Power by Hugo 现在，该博客改由 Hugo 强力驱动啦！  Hugo 是一个 golang 编写的静态网页生成器。同类型工具还有使用 node 编写的 Hexo。\n Hugo的优点 - 快 基于 golang 编写的\n- 简单 不仅使用简单，甚至自己写主题也很简单。\n- 支持org格式! (优秀) hexo, jekyll 等同类工具大多只支持 markdown. 而 hugo 支持 org 这一仅在 emacs 上有的文档格式，感动~\n但不会直接用org来发布~ 目前支持程度远没有 markdown 格式好。因为 org 在 emacs 上原生支持太好，又不像 md 这样通用导致其他平台支持程度不是很高。好在可以使用 emacs 插件把 org 转成 md，虽然还是会丢失一些 org 的特性。\n Org -\u0026gt; Markdown Emacs 的 ox-hugo\n安装 (use-package ox-hugo :after ox) 使用    需要在org文档元数据上标明hugo博客的根目录 HUGO_BASE_DIR 和生成文档的目标目录 HUGO_SECTION\n#+HUGO_BASE_DIR: ~/Hugo-DirName #+HUGO_SECTION: posts      C-c C-e H h\n导出当前org文档\n     org-hugo-auto-export-mode\n保存org文档自动导出为md\n在hugo博客根目录添加.dir-locals.el文件:\n((\u0026#34;content-org/\u0026#34; . ((org-mode . ((eval . (org-hugo-auto-export-mode))))))) 最终Hugo目录树:\n\u0026lt;HUGO_BASE_DIR\u0026gt; ├── config.toml ├── content ├── \u0026lt;HUGO_SECTION\u0026gt; ├── content-org \u0026lt;-- Org files in there ├── static ├── themes └── .dir-locals.el   ","permalink":"https://zakudriver.github.io/posts/hello_world/","summary":"Power by Hugo 现在，该博客改由 Hugo 强力驱动啦！  Hugo 是一个 golang 编写的静态网页生成器。同类型工具还有使用 node 编写的 Hexo。\n Hugo的优点 - 快 基于 golang 编写的\n- 简单 不仅使用简单，甚至自己写主题也很简单。\n- 支持org格式! (优秀) hexo, jekyll 等同类工具大多只支持 markdown. 而 hugo 支持 org 这一仅在 emacs 上有的文档格式，感动~\n但不会直接用org来发布~ 目前支持程度远没有 markdown 格式好。因为 org 在 emacs 上原生支持太好，又不像 md 这样通用导致其他平台支持程度不是很高。好在可以使用 emacs 插件把 org 转成 md，虽然还是会丢失一些 org 的特性。\n Org -\u0026gt; Markdown Emacs 的 ox-hugo\n安装 (use-package ox-hugo :after ox) 使用    需要在org文档元数据上标明hugo博客的根目录 HUGO_BASE_DIR 和生成文档的目标目录 HUGO_SECTION","title":"Hello_World"},{"content":"# vi: ft=dosini [main] # Enables context sensitive auto-completion. If this is disabled the all # possible completions will be listed. smart_completion = True # Multi-line mode allows breaking up the sql statements into multiple lines. If # this is set to True, then the end of the statements must have a semi-colon. # If this is set to False then sql statements can\u0026#39;t be split into multiple # lines. End of line (return) is considered as the end of the statement. multi_line = True # Destructive warning mode will alert you before executing a sql statement # that may cause harm to the database such as \u0026#34;drop table\u0026#34;, \u0026#34;drop database\u0026#34; # or \u0026#34;shutdown\u0026#34;. destructive_warning = True # log_file location. log_file = ~/.mycli.log # Default log level. Possible values: \u0026#34;CRITICAL\u0026#34;, \u0026#34;ERROR\u0026#34;, \u0026#34;WARNING\u0026#34;, \u0026#34;INFO\u0026#34; # and \u0026#34;DEBUG\u0026#34;. \u0026#34;NONE\u0026#34; disables logging. log_level = INFO # Log every query and its results to a file. Enable this by uncommenting the # line below. # audit_log = ~/.mycli-audit.log # Timing of sql statments and table rendering. timing = True # Table format. Possible values: psql, plain, simple, grid, fancy_grid, pipe, # orgtbl, rst, mediawiki, html, latex, latex_booktabs, tsv. # Recommended: psql, fancy_grid and grid. table_format = psql # Syntax coloring style. Possible values (many support the \u0026#34;-dark\u0026#34; suffix): # manni, igor, xcode, vim, autumn, vs, rrt, native, perldoc, borland, tango, emacs, # friendly, monokai, paraiso, colorful, murphy, bw, pastie, paraiso, trac, default, # fruity. # Screenshots at http://mycli.net/syntax syntax_style = default # Keybindings: Possible values: emacs, vi. # Emacs mode: Ctrl-A is home, Ctrl-E is end. All emacs keybindings are available in the REPL. # When Vi mode is enabled you can use modal editing features offered by Vi in the REPL. key_bindings = emacs # Enabling this option will show the suggestions in a wider menu. Thus more items are suggested. wider_completion_menu = False # MySQL prompt # \\t - Product type (Percona, MySQL, Mariadb) # \\u - Username # \\h - Hostname of the server # \\d - Database name # \\n - Newline prompt = \u0026#39;\\t \\u@\\h:\\d\u0026gt; \u0026#39; prompt_continuation = \u0026#39;-\u0026gt; \u0026#39; # Skip intro info on startup and outro info on exit less_chatty = False # Use alias from --login-path instead of host name in prompt login_path_as_host = False # Custom colors for the completion menu, toolbar, etc. [colors] # Completion menus. Token.Menu.Completions.Completion.Current = \u0026#39;bg:#00aaaa #000000\u0026#39; Token.Menu.Completions.Completion = \u0026#39;bg:#008888 #ffffff\u0026#39; Token.Menu.Completions.MultiColumnMeta = \u0026#39;bg:#aaffff #000000\u0026#39; Token.Menu.Completions.ProgressButton = \u0026#39;bg:#003333\u0026#39; Token.Menu.Completions.ProgressBar = \u0026#39;bg:#00aaaa\u0026#39; # Selected text. Token.SelectedText = \u0026#39;#ffffff bg:#6666aa\u0026#39; # Search matches. (reverse-i-search) Token.SearchMatch = \u0026#39;#ffffff bg:#4444aa\u0026#39; Token.SearchMatch.Current = \u0026#39;#ffffff bg:#44aa44\u0026#39; # The bottom toolbar. Token.Toolbar = \u0026#39;bg:#222222 #aaaaaa\u0026#39; Token.Toolbar.Off = \u0026#39;bg:#222222 #888888\u0026#39; Token.Toolbar.On = \u0026#39;bg:#222222 #ffffff\u0026#39; # Search/arg/system toolbars. Token.Toolbar.Search = \u0026#39;noinherit bold\u0026#39; Token.Toolbar.Search.Text = \u0026#39;nobold\u0026#39; Token.Toolbar.System = \u0026#39;noinherit bold\u0026#39; Token.Toolbar.Arg = \u0026#39;noinherit bold\u0026#39; Token.Toolbar.Arg.Text = \u0026#39;nobold\u0026#39; # Favorite queries. [favorite_queries] ","permalink":"https://zakudriver.github.io/posts/myclirc/","summary":"# vi: ft=dosini [main] # Enables context sensitive auto-completion. If this is disabled the all # possible completions will be listed. smart_completion = True # Multi-line mode allows breaking up the sql statements into multiple lines. If # this is set to True, then the end of the statements must have a semi-colon. # If this is set to False then sql statements can\u0026#39;t be split into multiple # lines. End of line (return) is considered as the end of the statement.","title":"myclirc"},{"content":"angular的ControlValueAccessor是一个连接表单模型和视图DOM的抽象类接口\n.org-center { margin-left: auto; margin-right: auto; text-align: center; } 使自定义表单组件像原生input一样映射到form表单模型中, 拥有自定义表单组件的form也能使用响应式表单. (也就是使自定义表单组件拥有formControlName属性和ngModel接口.)\n 毕竟响应式表单才是angular的利器.\nControlValueAccessor export interface ControlValueAccessor { writeValue(obj: any): void; registerOnChange(fn: any): void; registerOnTouched(fn: any): void; setDisabledState?(isDisabled: boolean): void; } writeValue(obj: any): 该方法是接收模版中的ngModel.\nwriteValue(value: any): void { this._renderer.setProperty(this._elementRef.nativeElement, \u0026#39;value\u0026#39;, value); } registerOnChange(fn: any): void: 该方法是组件接收到 change 事件的回调, 可以用来通知外部达成双向绑定, 即ngModelChange.\nregisterOnChange(fn: (_: any) =\u0026gt; void): void { this._onChange = fn; } registerOnTouched(fn: any): 接收到 touched 事件的回调.\nregisterOnTouched(fn: any): void { this._onTouched = fn; } setDisabledState?(isDisabled: boolean): 该方法是组件输入状态 disable \u0026lt;=\u0026gt; enable 变化时的回调。该方法会根据参数值，启用或禁用指定的DOM元素.\n以下组件类实现了ControlValueAccessor接口. CheckboxControlValueAccessor 用于checkbox复选组件 选择器:\n input[type=checkbox][formControlName] input[type=checkbox][formControl] input[type=checkbox][ngModel]  NumberValueAccessor 用于number类型的输入组件 选择器:\n input[type=number][formControlName] input[type=number][formControl] input[type=number][ngModel]  DefaultValueAccessor 用于 text 和 textarea 类型的输入组件 选择器:\n input:not([type=checkbox])[formControlName] textarea[formControlName] input:not([type=checkbox])[formControl] textarea[formControl] input:not([type=checkbox])[ngModel] textarea[ngModel] [ngDefaultControl]  RadioControlValueAccessor 用于radio单选组件 选择器:\n input[type=radio][formControlName] input[type=radio][formControl] input[type=radio][ngModel]  扩展方法:\n fireUncheck(value: any): void:取消选中的回调.  RangeValueAccessor 用于范围输入组件 选择器:\n input[type=range][formControlName] input[type=range][formControl] input[type=range][ngModel]  SelectControlValueAccessor 用于select组件 选择器:\n select:not([multiple])[formControlName] select:not([multiple])[formControl] select:not([multiple])[ngModel]  扩展方法:\n compareWith: (o1: any, o2: any) =\u0026gt; boolean:比较函数. 例如option的ngValue是一个对象, 当选中项填入表单时,需要编写一个比较函数来处理当前选中的对象是哪一个option.  SelectMultipleControlValueAccessor 用于多选select组件 选择器:\n select[multiple][formControlName] select[multiple][formControl] select[multiple][ngModel]  扩展方法: compareWith: (o1: any, o2: any) =\u0026gt; boolean:比较函数. 例如option的ngValue是一个对象, 当选中项填入表单时, 需要编写一个比较函数来处理当前选中的对象是哪一个option.\nEG 自定义表单组件代码结构 import { Component, OnInit, HostListener, ViewEncapsulation, forwardRef, Input, OnDestroy, ChangeDetectorRef, ChangeDetectionStrategy } from \u0026#39;@angular/core\u0026#39;; import { ControlValueAccessor, NG_VALUE_ACCESSOR } from \u0026#39;@angular/forms\u0026#39;; import { Subject } from \u0026#39;rxjs\u0026#39;; @Component({ selector : \u0026#39;[app-radiobox]\u0026#39;, templateUrl : \u0026#39;./radiobox.component.html\u0026#39;, styleUrls : [\u0026#39;./radiobox.component.styl\u0026#39;], encapsulation : ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, host : { \u0026#39;[class.radio-wrapper]\u0026#39; : \u0026#39;true\u0026#39;, \u0026#39;[class.radio-wrapper-checked]\u0026#39;: \u0026#39;checked\u0026#39; }, providers: [ { provide : NG_VALUE_ACCESSOR, useExisting: forwardRef(() =\u0026gt; RadioboxComponent), multi : true } ] }) export class RadioboxComponent implements OnInit, OnDestroy, ControlValueAccessor { @Input() value: boolean; checked: boolean; select$ = new Subject\u0026lt;RadioboxComponent\u0026gt;(); onChange: (_: any) =\u0026gt; void = () =\u0026gt; null; onTouched: () =\u0026gt; void = () =\u0026gt; null; constructor(private _cdr: ChangeDetectorRef) {} @HostListener(\u0026#39;click\u0026#39;, [\u0026#39;$event\u0026#39;]) onClick(e: MouseEvent): void { e.stopPropagation(); e.preventDefault(); this.checked = !this.checked; this.onChange(this.checked); this.select$.next(this); } writeValue(value: boolean) { this.checked = value; } registerOnChange(fn: (_: boolean) =\u0026gt; {}): void { this.onChange = fn; } registerOnTouched(fn: () =\u0026gt; {}): void { this.onTouched = fn; } ngOnInit() {} ngOnDestroy() {} } 调用 import { Component, OnInit } from \u0026#39;@angular/core\u0026#39;; import { FormBuilder, FormGroup } from \u0026#39;@angular/forms\u0026#39;; @Component({ selector: \u0026#39;app-example\u0026#39;, template: ` \u0026lt;form [formGroup]=\u0026#34;testForm\u0026#34;\u0026gt; \u0026lt;label\u0026gt;试试\u0026lt;/label\u0026gt; \u0026lt;label app-radiobox formControlName=\u0026#34;check\u0026#34;\u0026gt;check me\u0026lt;/label\u0026gt; \u0026lt;/form\u0026gt; ` }) export class ExampleComponent implements OnInit { testForm: FormGroup = this._fb.group({ check: false }); constructor(private _fb: FormBuilder) {} ngOnInit() { this.testForm.valueChanges.subscribe(d =\u0026gt; { console.log(d); }); } } ","permalink":"https://zakudriver.github.io/posts/angular%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E8%A1%A8%E5%8D%95%E7%BB%84%E4%BB%B6/","summary":"angular的ControlValueAccessor是一个连接表单模型和视图DOM的抽象类接口\n.org-center { margin-left: auto; margin-right: auto; text-align: center; } 使自定义表单组件像原生input一样映射到form表单模型中, 拥有自定义表单组件的form也能使用响应式表单. (也就是使自定义表单组件拥有formControlName属性和ngModel接口.)\n 毕竟响应式表单才是angular的利器.\nControlValueAccessor export interface ControlValueAccessor { writeValue(obj: any): void; registerOnChange(fn: any): void; registerOnTouched(fn: any): void; setDisabledState?(isDisabled: boolean): void; } writeValue(obj: any): 该方法是接收模版中的ngModel.\nwriteValue(value: any): void { this._renderer.setProperty(this._elementRef.nativeElement, \u0026#39;value\u0026#39;, value); } registerOnChange(fn: any): void: 该方法是组件接收到 change 事件的回调, 可以用来通知外部达成双向绑定, 即ngModelChange.\nregisterOnChange(fn: (_: any) =\u0026gt; void): void { this._onChange = fn; } registerOnTouched(fn: any): 接收到 touched 事件的回调.\nregisterOnTouched(fn: any): void { this.","title":"angular自定义双向绑定表单组件"},{"content":"\u0026#34; .vimrc \u0026#34; Configuration file for vim set modelines=0 \u0026#34; Don\u0026#39;t write backup file if vim is being called by \u0026#34;crontab -e\u0026#34; \u0026#34; au BufWrite /private/tmp/crontab.* set nowritebackup nobackup \u0026#34; Don\u0026#39;t write backup file if vim is being called by \u0026#34;chpass\u0026#34; \u0026#34; au BufWrite /private/etc/pw.* set nowritebackup nobackup set nobackup set nowritebackup let skip_defaults_vim=1 \u0026#34; \u0026lt;leader\u0026gt; let g:mapleader=\u0026#34;,\u0026#34; \u0026#34; 去掉有关vi一致性模式，避免以前版本的bug和局限 set nocompatible \u0026#34; 设置退格键可用 set backspace=2 \u0026#34; utf-8 set encoding=UTF-8 \u0026#34; 主题 \u0026#34; set background=dark \u0026#34; colorscheme dracula \u0026#34; 函数方法名加粗 let g:enable_bold_font = 1 \u0026#34; 注释斜体 let g:enable_italic_font = 1 \u0026#34; 透明背景 let g:hybrid_transparent_background = 1 \u0026#34; airline_theme let g:airline_theme = \u0026#34;hybrid\u0026#34; \u0026#34; 行号 set nu! \u0026#34; 高亮显示寻找匹配 set hls \u0026#34; 允许用指定语法高亮配色方案替换默认方案 syntax on dracula \u0026#34; 开启语法高亮 syntax enable \u0026#34; 设置匹配模式 (当输入一个左括号时会匹配相应的右括号) set showmatch \u0026#34; 显示当前光标位置 set ruler \u0026#34; 使用系统剪切板 set clipboard=unnamed \u0026#34; 设置格式化时代码缩进为2个空格 set shiftwidth=2 \u0026#34; tab键缩进为4格子 set tabstop=2 \u0026#34; 把连续数量的空格视为一个制表符 set softtabstop=2 \u0026#34; 禁止折行 set nowrap \u0026#34; tab键转换为空格 set expandtab \u0026#34; 智能缩进 set smartindent \u0026#34; 开启实时搜索功能 set incsearch \u0026#34; 搜索时大小写不敏感 set ignorecase \u0026#34; vim 自身命令行模式智能补全 set wildmenu \u0026#34; 开启文件类型侦测 filetype on \u0026#34; 根据侦测到的不同类型加载对应的插件 filetype plugin on \u0026#34; 自适应不同语言的智能缩进 filetype indent on \u0026#34; 将制表符扩展为空格 set nofoldenable \u0026#34; 基于缩进或语法进行代码折叠 set foldmethod=syntax \u0026#34; 启动 vim 时关闭折叠代码 set nofoldenable \u0026#34; 禁止光标闪烁 set gcr=a:block-blinkon0 \u0026#34; 禁止显示滚动条 set guioptions-=l set guioptions-=L set guioptions-=r set guioptions-=R \u0026#34; 高亮显示当前行/列 set cursorline set cursorcolumn \u0026#34; 让配置变更立即生效 autocmd BufWritePost $MYVIMRC source $MYVIMRC \u0026#34; normal 模式 keymap nnoremap x \u0026#34;_x nnoremap X \u0026#34;_X nnoremap d \u0026#34;_d nnoremap dd \u0026#34;_dd nnoremap D \u0026#34;_D nnoremap s \u0026#34;_s nnoremap S \u0026#34;_S nnoremap c \u0026#34;_c nnoremap C \u0026#34;_C \u0026#34; insert 模式 inoremap $( ()\u0026lt;esc\u0026gt;i inoremap $\u0026lt; \u0026lt;\u0026gt;\u0026lt;esc\u0026gt;i inoremap ${ {}\u0026lt;esc\u0026gt;i inoremap $[ []\u0026lt;esc\u0026gt;i inoremap $\u0026#39; \u0026#39;\u0026#39;\u0026lt;esc\u0026gt;i inoremap $\u0026#34; \u0026#34;\u0026#34;\u0026lt;esc\u0026gt;i \u0026#34; visual 模式 vnoremap s \u0026#34;_s vnoremap S \u0026#34;_S vnoremap z) c()\u0026lt;esc\u0026gt;hp vnoremap z} c{}\u0026lt;esc\u0026gt;hp vnoremap z] c[]\u0026lt;esc\u0026gt;hp vnoremap z\u0026#39; c\u0026#39;\u0026#39;\u0026lt;esc\u0026gt;hp vnoremap z\u0026#34; c\u0026#34;\u0026#34;\u0026lt;esc\u0026gt;hp vnoremap z\u0026gt; c\u0026lt;\u0026gt;\u0026lt;esc\u0026gt;hp vnoremap z` c``\u0026lt;esc\u0026gt;hp \u0026#34; NERDTree let g:NERDTreeIndicatorMapCustom = { \\ \u0026#34;Modified\u0026#34; : \u0026#34;✹\u0026#34;, \\ \u0026#34;Staged\u0026#34; : \u0026#34;✚\u0026#34;, \\ \u0026#34;Untracked\u0026#34; : \u0026#34;✭\u0026#34;, \\ \u0026#34;Renamed\u0026#34; : \u0026#34;➜\u0026#34;, \\ \u0026#34;Unmerged\u0026#34; : \u0026#34;═\u0026#34;, \\ \u0026#34;Deleted\u0026#34; : \u0026#34;✖\u0026#34;, \\ \u0026#34;Dirty\u0026#34; : \u0026#34;✗\u0026#34;, \\ \u0026#34;Clean\u0026#34; : \u0026#34;✔︎\u0026#34;, \\ \u0026#34;Unknown\u0026#34; : \u0026#34;?\u0026#34; \\ } \u0026#34; 自动开启NERDTree \u0026#34; autocmd vimenter * NERDTree \u0026#34; UltiSnips let g:UltiSnipsExpandTrigger=\u0026#34;\u0026lt;Leader\u0026gt;\u0026lt;TAB\u0026gt;\u0026#34; let g:UltiSnipsJumpForwardTrigger=\u0026#34;\u0026lt;c-f\u0026gt;\u0026#34; let g:UltiSnipsJumpBackwardTrigger=\u0026#34;\u0026lt;c-b\u0026gt;\u0026#34; \u0026#34;au BufRead,BufNewFile *.go set filetype=go \u0026#34; ycm \u0026#34; let g:ycm_key_list_select_completion=[\u0026#39;\u0026lt;c-n\u0026gt;\u0026#39;] \u0026#34; let g:ycm_key_list_previous_completion=[\u0026#39;\u0026lt;c-p\u0026gt;\u0026#39;] \u0026#34; let g:ycm_key_invoke_completion = \u0026#39;\u0026lt;C-Space\u0026gt;\u0026#39; \u0026#34; \u0026#34; 关闭加载.ycm_extra_conf.py提示 \u0026#34; let g:ycm_confirm_extra_conf=0 \u0026#34; \u0026#34; 开启 YCM 基于标签引擎 \u0026#34; let g:ycm_collect_identifiers_from_tags_files=1 \u0026#34; \u0026#34; 从第2个键入字符就开始罗列匹配项 \u0026#34; let g:ycm_min_num_of_chars_for_completion=1 \u0026#34; \u0026#34; 禁止缓存匹配项,每次都重新生成匹配项 \u0026#34; let g:ycm_cache_omnifunc=0 \u0026#34; \u0026#34; 语法关键字补全 \u0026#34; let g:ycm_seed_identifiers_with_syntax=1 \u0026#34; \u0026#34; 设置在下面几种格式的文件上屏蔽ycm \u0026#34; let g:ycm_filetype_blacklist = { \u0026#34; \\ \u0026#39;typescript.tsx\u0026#39; : 1, \u0026#34; \\ \u0026#39;typescript\u0026#39; : 1, \u0026#34; \\} \u0026#34; \u0026#34; 注释和字符串中的文字也会被收入补全 \u0026#34; let g:ycm_collect_identifiers_from_comments_and_strings = 0 \u0026#34; \u0026#34; 输入第2个字符开始补全 \u0026#34; let g:ycm_min_num_of_chars_for_completion=2 \u0026#34; 注释 \u0026#34; Add spaces after comment delimiters by default let g:NERDSpaceDelims = 1 \u0026#34; Use compact syntax for prettified multi-line comments let g:NERDCompactSexyComs = 1 \u0026#34; Align line-wise comment delimiters flush left instead of following code indentation let g:NERDDefaultAlign = \u0026#39;left\u0026#39; \u0026#34; Set a language to use its alternate delimiters by default let g:NERDAltDelims_java = 1 \u0026#34; Add your own custom formats or override the defaults let g:NERDCustomDelimiters = { \u0026#39;c\u0026#39;: { \u0026#39;left\u0026#39;: \u0026#39;/**\u0026#39;,\u0026#39;right\u0026#39;: \u0026#39;*/\u0026#39; } } \u0026#34; Allow commenting and inverting empty lines (useful when commenting a region) let g:NERDCommentEmptyLines = 1 \u0026#34; Enable trimming of trailing whitespace when uncommenting let g:NERDTrimTrailingWhitespace = 1 \u0026#34; Enable NERDCommenterToggle to check all selected lines is commented or not let g:NERDToggleCheckAllLines = 1 \u0026#34; coc let g:coc_global_extensions = [ \\ \u0026#39;coc-json\u0026#39;, \\ \u0026#39;coc-html\u0026#39;, \\ \u0026#39;coc-css\u0026#39;, \\ ] set cmdheight=2 set updatetime=300 set shortmess+=c set signcolumn=yes au BufNewFile,BufRead *.ts setlocal filetype=typescript au BufNewFile,BufRead *.tsx setlocal filetype=typescript.tsx nmap \u0026lt;silent\u0026gt; gd \u0026lt;Plug\u0026gt;(coc-definition) nmap \u0026lt;silent\u0026gt; gy \u0026lt;Plug\u0026gt;(coc-type-definition) nmap \u0026lt;silent\u0026gt; gi \u0026lt;Plug\u0026gt;(coc-implementation) nmap \u0026lt;silent\u0026gt; gr \u0026lt;Plug\u0026gt;(coc-references) nmap \u0026lt;leader\u0026gt;rn \u0026lt;Plug\u0026gt;(coc-rename) nmap \u0026lt;silent\u0026gt; [c \u0026lt;Plug\u0026gt;(coc-diagnostic-prev) nmap \u0026lt;silent\u0026gt; ]c \u0026lt;Plug\u0026gt;(coc-diagnostic-next) nmap \u0026lt;leader\u0026gt;a \u0026lt;Plug\u0026gt;(coc-codeaction-selected) nmap \u0026lt;leader\u0026gt;ac \u0026lt;Plug\u0026gt;(coc-codeaction) nmap \u0026lt;leader\u0026gt;qf \u0026lt;Plug\u0026gt;(coc-fix-current) nmap \u0026lt;silent\u0026gt; \u0026lt;TAB\u0026gt; \u0026lt;Plug\u0026gt;(coc-range-select) xmap \u0026lt;silent\u0026gt; \u0026lt;TAB\u0026gt; \u0026lt;Plug\u0026gt;(coc-range-select) xmap \u0026lt;silent\u0026gt; \u0026lt;S-TAB\u0026gt; \u0026lt;Plug\u0026gt;(coc-range-select-backword) xmap \u0026lt;leader\u0026gt;a \u0026lt;Plug\u0026gt;(coc-codeaction-selected) \u0026#34; 显示文档 nnoremap \u0026lt;silent\u0026gt; K :call \u0026lt;SID\u0026gt;show_documentation()\u0026lt;CR\u0026gt; \u0026#34; 回车：补全框?确认补全:回车可以撤回 inoremap \u0026lt;expr\u0026gt; \u0026lt;cr\u0026gt; pumvisible() ? \u0026#34;\\\u0026lt;C-y\u0026gt;\u0026#34; : \u0026#34;\\\u0026lt;C-g\u0026gt;u\\\u0026lt;CR\u0026gt;\u0026#34; \u0026#34; \u0026lt;c-c\u0026gt;触发补全 inoremap \u0026lt;silent\u0026gt;\u0026lt;expr\u0026gt; \u0026lt;c-c\u0026gt; coc#refresh() inoremap \u0026lt;expr\u0026gt;\u0026lt;S-TAB\u0026gt; pumvisible() ? \u0026#34;\\\u0026lt;C-p\u0026gt;\u0026#34; : \u0026#34;\\\u0026lt;C-h\u0026gt;\u0026#34; inoremap \u0026lt;silent\u0026gt;\u0026lt;expr\u0026gt; \u0026lt;TAB\u0026gt; \\ pumvisible() ? \u0026#34;\\\u0026lt;C-n\u0026gt;\u0026#34; : \\ \u0026lt;SID\u0026gt;check_back_space() ? \u0026#34;\\\u0026lt;TAB\u0026gt;\u0026#34; : \\ coc#refresh() \u0026#34; Use `:Format` to format current buffer command! -nargs=0 Format :call CocAction(\u0026#39;format\u0026#39;) \u0026#34; Use `:Fold` to fold current buffer command! -nargs=? Fold :call CocAction(\u0026#39;fold\u0026#39;, \u0026lt;f-args\u0026gt;) \u0026#34; set statusline^=%{coc#status()}%{get(b:,\u0026#39;coc_current_function\u0026#39;,\u0026#39;\u0026#39;)} \u0026#34; autocmd CursorHold * silent call CocActionAsync(\u0026#39;highlight\u0026#39;) function! s:show_documentation() if (index([\u0026#39;vim\u0026#39;,\u0026#39;help\u0026#39;], \u0026amp;filetype) \u0026gt;= 0) execute \u0026#39;h \u0026#39;.expand(\u0026#39;\u0026lt;cword\u0026gt;\u0026#39;) else call CocAction(\u0026#39;doHover\u0026#39;) endif endfunction function! s:check_back_space() abort let col = col(\u0026#39;.\u0026#39;) - 1 return !col || getline(\u0026#39;.\u0026#39;)[col - 1] =~# \u0026#39;\\s\u0026#39; endfunction \u0026#34; -------------------- plug ------------------------ call plug#begin(\u0026#39;~/.vim/plugins\u0026#39;) Plug \u0026#39;dracula/vim\u0026#39;, { \u0026#39;as\u0026#39;: \u0026#39;dracula\u0026#39; } Plug \u0026#39;mhinz/vim-startify\u0026#39; Plug \u0026#39;SirVer/ultisnips\u0026#39; Plug \u0026#39;jiangmiao/auto-pairs\u0026#39; Plug \u0026#39;vim-airline/vim-airline\u0026#39; Plug \u0026#39;vim-airline/vim-airline-themes\u0026#39; Plug \u0026#39;scrooloose/nerdcommenter\u0026#39; \u0026#34; NERDTree Plug \u0026#39;scrooloose/nerdtree\u0026#39; \u0026#34; git Plug \u0026#39;Xuyuanp/nerdtree-git-plugin\u0026#39; \u0026#34; icon \u0026#34; Plug \u0026#39;ryanoasis/vim-devicons\u0026#39; \u0026#34; coc \u0026#34; Plug \u0026#39;neoclide/coc.nvim\u0026#39;, {\u0026#39;do\u0026#39;: \u0026#39;yarn install --frozen-lockfile\u0026#39; } \u0026#34; golang \u0026#34; Plug \u0026#39;fatih/vim-go\u0026#39; \u0026#34; typescript \u0026#34; Plug \u0026#39;leafgarland/typescript-vim\u0026#39;, {\u0026#39;for\u0026#39;: [\u0026#39;typescript\u0026#39;, \u0026#39;typescript.tsx\u0026#39;, \u0026#39;js\u0026#39;]} \u0026#34; prettier \u0026#34;Plug \u0026#39;prettier/vim-prettier\u0026#39;, { \u0026#34; \\ \u0026#39;do\u0026#39;: \u0026#39;yarn install\u0026#39;, \u0026#34; \\ \u0026#39;for\u0026#39;: [\u0026#39;javascript\u0026#39;, \u0026#39;typescript\u0026#39;, \u0026#39;css\u0026#39;, \u0026#39;less\u0026#39;, \u0026#39;scss\u0026#39;, \u0026#39;json\u0026#39;, \u0026#39;graphql\u0026#39;, \u0026#39;markdown\u0026#39;, \u0026#39;vue\u0026#39;, \u0026#39;yaml\u0026#39;, \u0026#39;html\u0026#39;] } \u0026#34;Plug \u0026#39;Valloric/YouCompleteMe\u0026#39; call plug#end() \u0026#34; 替换函数 \u0026#34; 参数说明： \u0026#34; confirm：是否替换前逐一确认 \u0026#34; wholeword：是否整词匹配 \u0026#34; replace：被替换字符串 function! Replace(confirm, wholeword, replace) wa let flag = \u0026#39;\u0026#39; if a:confirm let flag .= \u0026#39;gec\u0026#39; else let flag .= \u0026#39;ge\u0026#39; endif let search = \u0026#39;\u0026#39; if a:wholeword let search .= \u0026#39;\\\u0026lt;\u0026#39; . escape(expand(\u0026#39;\u0026lt;cword\u0026gt;\u0026#39;), \u0026#39;/\\.*$^~[\u0026#39;) . \u0026#39;\\\u0026gt;\u0026#39; else let search .= expand(\u0026#39;\u0026lt;cword\u0026gt;\u0026#39;) endif let replace = escape(a:replace, \u0026#39;/\\\u0026amp;~\u0026#39;) execute \u0026#39;argdo %s/\u0026#39; . search . \u0026#39;/\u0026#39; . replace . \u0026#39;/\u0026#39; . flag . \u0026#39;| update\u0026#39; endfunction \u0026#34; 不确认、非整词 nnoremap \u0026lt;Leader\u0026gt;R :call Replace(0, 0, input(\u0026#39;Replace \u0026#39;.expand(\u0026#39;\u0026lt;cword\u0026gt;\u0026#39;).\u0026#39; with: \u0026#39;))\u0026lt;CR\u0026gt; \u0026#34; 不确认、整词 nnoremap \u0026lt;Leader\u0026gt;rw :call Replace(0, 1, input(\u0026#39;Replace \u0026#39;.expand(\u0026#39;\u0026lt;cword\u0026gt;\u0026#39;).\u0026#39; with: \u0026#39;))\u0026lt;CR\u0026gt; \u0026#34; 确认、非整词 nnoremap \u0026lt;Leader\u0026gt;rc :call Replace(1, 0, input(\u0026#39;Replace \u0026#39;.expand(\u0026#39;\u0026lt;cword\u0026gt;\u0026#39;).\u0026#39; with: \u0026#39;))\u0026lt;CR\u0026gt; \u0026#34; 确认、整词 nnoremap \u0026lt;Leader\u0026gt;rcw :call Replace(1, 1, input(\u0026#39;Replace \u0026#39;.expand(\u0026#39;\u0026lt;cword\u0026gt;\u0026#39;).\u0026#39; with: \u0026#39;))\u0026lt;CR\u0026gt; nnoremap \u0026lt;Leader\u0026gt;rwc :call Replace(1, 1, input(\u0026#39;Replace \u0026#39;.expand(\u0026#39;\u0026lt;cword\u0026gt;\u0026#39;).\u0026#39; with: \u0026#39;))\u0026lt;CR\u0026gt; ","permalink":"https://zakudriver.github.io/posts/vimrc/","summary":"\u0026#34; .vimrc \u0026#34; Configuration file for vim set modelines=0 \u0026#34; Don\u0026#39;t write backup file if vim is being called by \u0026#34;crontab -e\u0026#34; \u0026#34; au BufWrite /private/tmp/crontab.* set nowritebackup nobackup \u0026#34; Don\u0026#39;t write backup file if vim is being called by \u0026#34;chpass\u0026#34; \u0026#34; au BufWrite /private/etc/pw.* set nowritebackup nobackup set nobackup set nowritebackup let skip_defaults_vim=1 \u0026#34; \u0026lt;leader\u0026gt; let g:mapleader=\u0026#34;,\u0026#34; \u0026#34; 去掉有关vi一致性模式，避免以前版本的bug和局限 set nocompatible \u0026#34; 设置退格键可用 set backspace=2 \u0026#34; utf-8 set encoding=UTF-8 \u0026#34; 主题 \u0026#34; set background=dark \u0026#34; colorscheme dracula \u0026#34; 函数方法名加粗 let g:enable_bold_font = 1 \u0026#34; 注释斜体 let g:enable_italic_font = 1 \u0026#34; 透明背景 let g:hybrid_transparent_background = 1 \u0026#34; airline_theme let g:airline_theme = \u0026#34;hybrid\u0026#34; \u0026#34; 行号 set nu!","title":"vimrc"},{"content":" golang 接口值: 一个包含 nil 指针的接口不是 nil 接口.\n一个不包含任何值的 nil 接口值和一个刚好包含 nil 指针的接口值是不同的.\n 接口值由两个部分组成:\n 一个具体的类型 那个类型的值  它们被称为接口的动态类型和动态值.\n   type value     x x    接口的零值是指动态类型为nil, 动态值也为nil.\n   type value     nil nil    这样的接口才能满足 接口值 == nil.\nvar a interface{} fmt.Println(a == nil) // true 一个不包含任何值的 nil 接口值: interface 类型变量的动态类型和动态值都为 nil. 比如 nil, 或者:\nvar a interface{} fmt.Println(a) // a为nil 一个刚好包含 nil 指针的接口值: 赋值给后，interface 类型变量的动态类型不为 nil，动态值为 nil.\nvar a interface{} var b *string a = b fmt.Println(a) // 此时a的动态类型为*string，动态值为nil 这两种对象比较: func main(){ var a interface{} // nil  var b *string // nil  a = b fmt.Println(a == nil) // false  fmt.Println(b == nil) // true  fmt.Println(b == a) // true }   a = nil 为 false: b 赋值给 a, a 的动态类型为 *string, 动态值为 nil, 所以 a = nil 为 false.\n// 空接口 type eface struct { _type *_type // 类型信息  data unsafe.Pointer // 指向数据的指针 } // 带有方法的接口 type iface struct { tab *itab // 存储type信息还有结构实现方法的集合  data unsafe.Pointer // 指向数据的指针 }   根据 interface 的底层实现, a = b 实则是 a.data = unsafe.Pointer(\u0026amp;b). a = nil 才是 a.data = nil.\n  b == nil 为 true: b 是一个空的指针(非接口)类型.\n  b == a 为 true: 值都为 nil, b 是一个空的指针(非接口)类型.\n  ","permalink":"https://zakudriver.github.io/posts/%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%AB-nil-%E6%8C%87%E9%92%88%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%B8%8D%E6%98%AF-nil-%E6%8E%A5%E5%8F%A3/","summary":"golang 接口值: 一个包含 nil 指针的接口不是 nil 接口.\n一个不包含任何值的 nil 接口值和一个刚好包含 nil 指针的接口值是不同的.\n 接口值由两个部分组成:\n 一个具体的类型 那个类型的值  它们被称为接口的动态类型和动态值.\n   type value     x x    接口的零值是指动态类型为nil, 动态值也为nil.\n   type value     nil nil    这样的接口才能满足 接口值 == nil.\nvar a interface{} fmt.Println(a == nil) // true 一个不包含任何值的 nil 接口值: interface 类型变量的动态类型和动态值都为 nil. 比如 nil, 或者:","title":"一个包含 nil 指针的接口不是 nil 接口"},{"content":"{ // editor \u0026#34;editor.fontSize\u0026#34;: 14, \u0026#34;editor.snippetSuggestions\u0026#34;: \u0026#34;top\u0026#34;, \u0026#34;editor.formatOnSave\u0026#34;: true, \u0026#34;explorer.confirmDragAndDrop\u0026#34;: true, \u0026#34;explorer.confirmDelete\u0026#34;: false, \u0026#34;editor.detectIndentation\u0026#34;: false, \u0026#34;files.autoSave\u0026#34;: \u0026#34;off\u0026#34;, // \u0026#34;editor.fontFamily\u0026#34;: \u0026#34;\u0026#39;FuraCode\u0026#39;, Menlo, Monaco, \u0026#39;Courier New\u0026#39;, monospace\u0026#34;, \u0026#34;editor.fontLigatures\u0026#34;: true, \u0026#34;workbench.iconTheme\u0026#34;: \u0026#34;material-icon-theme\u0026#34;, \u0026#34;workbench.colorTheme\u0026#34;: \u0026#34;Nebula\u0026#34;, // prettier \u0026#34;prettier.printWidth\u0026#34;: 120, \u0026#34;editor.tabSize\u0026#34;: 2, \u0026#34;prettier.singleQuote\u0026#34;: false, \u0026#34;prettier.semi\u0026#34;: true, // typescript \u0026#34;typescript.updateImportsOnFileMove.enabled\u0026#34;: \u0026#34;always\u0026#34;, // emmet \u0026#34;emmet.includeLanguages\u0026#34;: { \u0026#34;javascript\u0026#34;: \u0026#34;javascriptreact\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;typescriptreact\u0026#34; }, \u0026#34;emmet.triggerExpansionOnTab\u0026#34;: true, // 装饰器 \u0026#34;javascript.implicitProjectConfig.experimentalDecorators\u0026#34;: true, // stylus \u0026#34;stylusSupremacy.insertColons\u0026#34;: false, // 是否插入冒号 \u0026#34;stylusSupremacy.insertSemicolons\u0026#34;: false, // 是否插入分好 \u0026#34;stylusSupremacy.insertBraces\u0026#34;: false, // 是否插入大括号 \u0026#34;stylusSupremacy.insertNewLineAroundImports\u0026#34;: true, // import之后是否换行 \u0026#34;stylusSupremacy.insertNewLineAroundBlocks\u0026#34;: true, \u0026#34;stylusSupremacy.insertSpaceAfterComment\u0026#34;: true, \u0026#34;window.zoomLevel\u0026#34;: 0, // Formatter \u0026#34;[javascript]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;vscode.typescript-language-features\u0026#34; }, \u0026#34;[typescript]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34; }, \u0026#34;[json]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34; }, \u0026#34;[jsonc]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34; }, \u0026#34;[typescriptreact]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34; }, \u0026#34;[html]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34; }, \u0026#34;search.followSymlinks\u0026#34;: false, // vim \u0026#34;vim.useSystemClipboard\u0026#34;: true, \u0026#34;vim.hlsearch\u0026#34;: true, \u0026#34;vim.smartcase\u0026#34;: true, \u0026#34;vim.leader\u0026#34;: \u0026#34;,\u0026#34;, \u0026#34;vim.highlightedyank.enable\u0026#34;: true, \u0026#34;vim.highlightedyank.duration\u0026#34;: 1000, \u0026#34;vim.highlightedyank.color\u0026#34;: \u0026#34;rgba(250, 240, 170, 0.5)\u0026#34;, \u0026#34;vim.history\u0026#34;: 100, // \u0026#34;vim.cursorStylePerMode.insert\u0026#34;: \u0026#34;line\u0026#34;, // \u0026#34;vim.cursorStylePerMode.normal\u0026#34;: \u0026#34;underline\u0026#34;, // \u0026#34;vim.cursorStylePerMode.replace\u0026#34;: \u0026#34;underline\u0026#34;, // \u0026#34;vim.cursorStylePerMode.visual\u0026#34;: \u0026#34;blink\u0026#34;, // \u0026#34;vim.cursorStylePerMode.visualblock\u0026#34;: \u0026#34;blink\u0026#34;, // \u0026#34;vim.cursorStylePerMode.visualline\u0026#34;: \u0026#34;underline\u0026#34;, \u0026#34;vim.easymotion\u0026#34;: true, \u0026#34;vim.easymotionMarkerFontSize\u0026#34;: \u0026#34;16\u0026#34;, \u0026#34;vim.easymotionMarkerHeight\u0026#34;: 16, \u0026#34;vim.easymotionMarkerWidthPerChar\u0026#34;: 9, \u0026#34;vim.normalModeKeyBindings\u0026#34;: [], \u0026#34;vim.normalModeKeyBindingsNonRecursive\u0026#34;: [ { \u0026#34;before\u0026#34;: [\u0026#34;d\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;d\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;d\u0026#34;, \u0026#34;d\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;d\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;D\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;D\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;t\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;x\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;X\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;X\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;s\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;s\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;S\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;S\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;c\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;c\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;C\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;C\u0026#34;] } ], \u0026#34;vim.visualModeKeyBindings\u0026#34;: [ { \u0026#34;before\u0026#34;: [\u0026#34;s\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;s\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;S\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;S\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;z\u0026#34;, \u0026#34;)\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;c\u0026#34;, \u0026#34;(\u0026#34;, \u0026#34;)\u0026#34;, \u0026#34;\u0026lt;Esc\u0026gt;\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;p\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;z\u0026#34;, \u0026#34;}\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;c\u0026#34;, \u0026#34;{\u0026#34;, \u0026#34;}\u0026#34;, \u0026#34;\u0026lt;Esc\u0026gt;\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;p\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;z\u0026#34;, \u0026#34;]\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;c\u0026#34;, \u0026#34;[\u0026#34;, \u0026#34;]\u0026#34;, \u0026#34;\u0026lt;Esc\u0026gt;\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;p\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;z\u0026#34;, \u0026#34;\u0026#39;\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;c\u0026#34;, \u0026#34;\u0026#39;\u0026#34;, \u0026#34;\u0026#39;\u0026#34;, \u0026#34;\u0026lt;Esc\u0026gt;\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;p\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;z\u0026#34;, \u0026#34;\\\u0026#34;\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;c\u0026#34;, \u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;\u0026lt;Esc\u0026gt;\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;p\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;z\u0026#34;, \u0026#34;\u0026gt;\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;c\u0026#34;, \u0026#34;\u0026lt;\u0026#34;, \u0026#34;\u0026gt;\u0026#34;, \u0026#34;\u0026lt;Esc\u0026gt;\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;p\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;z\u0026#34;, \u0026#34;`\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;c\u0026#34;, \u0026#34;`\u0026#34;, \u0026#34;`\u0026#34;, \u0026#34;\u0026lt;Esc\u0026gt;\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;p\u0026#34;] } ], \u0026#34;vim.handleKeys\u0026#34;: { \u0026#34;\u0026lt;C-a\u0026gt;\u0026#34;: false, \u0026#34;\u0026lt;C-f\u0026gt;\u0026#34;: false } } ","permalink":"https://zakudriver.github.io/posts/vscode/","summary":"{ // editor \u0026#34;editor.fontSize\u0026#34;: 14, \u0026#34;editor.snippetSuggestions\u0026#34;: \u0026#34;top\u0026#34;, \u0026#34;editor.formatOnSave\u0026#34;: true, \u0026#34;explorer.confirmDragAndDrop\u0026#34;: true, \u0026#34;explorer.confirmDelete\u0026#34;: false, \u0026#34;editor.detectIndentation\u0026#34;: false, \u0026#34;files.autoSave\u0026#34;: \u0026#34;off\u0026#34;, // \u0026#34;editor.fontFamily\u0026#34;: \u0026#34;\u0026#39;FuraCode\u0026#39;, Menlo, Monaco, \u0026#39;Courier New\u0026#39;, monospace\u0026#34;, \u0026#34;editor.fontLigatures\u0026#34;: true, \u0026#34;workbench.iconTheme\u0026#34;: \u0026#34;material-icon-theme\u0026#34;, \u0026#34;workbench.colorTheme\u0026#34;: \u0026#34;Nebula\u0026#34;, // prettier \u0026#34;prettier.printWidth\u0026#34;: 120, \u0026#34;editor.tabSize\u0026#34;: 2, \u0026#34;prettier.singleQuote\u0026#34;: false, \u0026#34;prettier.semi\u0026#34;: true, // typescript \u0026#34;typescript.updateImportsOnFileMove.enabled\u0026#34;: \u0026#34;always\u0026#34;, // emmet \u0026#34;emmet.includeLanguages\u0026#34;: { \u0026#34;javascript\u0026#34;: \u0026#34;javascriptreact\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;typescriptreact\u0026#34; }, \u0026#34;emmet.triggerExpansionOnTab\u0026#34;: true, // 装饰器 \u0026#34;javascript.implicitProjectConfig.experimentalDecorators\u0026#34;: true, // stylus \u0026#34;stylusSupremacy.insertColons\u0026#34;: false, // 是否插入冒号 \u0026#34;stylusSupremacy.insertSemicolons\u0026#34;: false, // 是否插入分好 \u0026#34;stylusSupremacy.","title":"vscode"}]