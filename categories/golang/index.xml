<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>golang on rx-78-kum0</title>
    <link>https://rx-78-kum0.github.io/categories/golang/</link>
    <description>Recent content in golang on rx-78-kum0</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 23 Jun 2020 00:00:00 +0800</lastBuildDate>
    
	<atom:link href="https://rx-78-kum0.github.io/categories/golang/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>golang gc优化</title>
      <link>https://rx-78-kum0.github.io/post/golang/gc%E4%BC%98%E5%8C%96/</link>
      <pubDate>Tue, 23 Jun 2020 00:00:00 +0800</pubDate>
      
      <guid>https://rx-78-kum0.github.io/post/golang/gc%E4%BC%98%E5%8C%96/</guid>
      <description>小对象要合并 函数频繁创建的简单的对象，直接返回对象，效果比返回指针效果要好 类型转换要注意，官方用法消耗特别大。 package string_util import ( &amp;#34;unsafe&amp;#34; ) func str2bytes(s string) []byte { x := (*[2]uintptr)(unsafe.Pointer(&amp;amp;s)) h := [3]uintptr{x[0], x[1], x[1]} return *(*[]byte)(unsafe.Pointer(&amp;amp;h)) } func bytes2str(b []byte) string { return *(*string)(unsafe.Pointer(&amp;amp;b)) } 避免反复创建slice，map func(r*Reader)Read()([]byte,error) // 此函数没有形参，每次调用的时候返回一个[]byte。 func(r*Reader)Read(buf[]byte)(int,error) // 此函数个函数在每次迪调用的时候，会重用形参声明。  避免使用&amp;quot;+&amp;quot;拼接字符串 package string_utils import ( &amp;#34;strings&amp;#34; ) func strAppend(s string, ss ...string) string { var r strings.Builder r.WriteString(s) for _, v := range ss { r.WriteString(v) } return r.String() } </description>
    </item>
    
    <item>
      <title>golang time工具函数</title>
      <link>https://rx-78-kum0.github.io/post/golang/time/</link>
      <pubDate>Tue, 23 Jun 2020 00:00:00 +0800</pubDate>
      
      <guid>https://rx-78-kum0.github.io/post/golang/time/</guid>
      <description>package util-time import ( &amp;#34;strconv&amp;#34; &amp;#34;time&amp;#34; ) // 获取当前的时间 - 字符串 func GetCurrentDate() string { return time.Now().Format(&amp;#34;2006/01/02 15:04:05&amp;#34;) } // 获取当前的时间 - Unix时间戳 func GetCurrentUnix() int64 { return time.Now().Unix() } // 获取当前的时间 - 毫秒级时间戳 func GetCurrentMilliUnix() int64 { return time.Now().UnixNano() / 1000000 } // 获取当前的时间 - 纳秒级时间戳 func GetCurrentNanoUnix() int64 { return time.Now().UnixNano() } func GetCurrentTime() string { var cstSh, _ = time.LoadLocation(&amp;#34;Asia/Shanghai&amp;#34;) t := time.Now().In(cstSh).Format(&amp;#34;2006/01/02/ 15:04:05&amp;#34;) return t } func GetCurrentHour() int { var cstSh, _ = time.</description>
    </item>
    
    <item>
      <title>获取用户home目录路径</title>
      <link>https://rx-78-kum0.github.io/post/golang/%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7home%E7%9B%AE%E5%BD%95%E8%B7%AF%E5%BE%84/</link>
      <pubDate>Wed, 10 Jun 2020 00:00:00 +0800</pubDate>
      
      <guid>https://rx-78-kum0.github.io/post/golang/%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7home%E7%9B%AE%E5%BD%95%E8%B7%AF%E5%BE%84/</guid>
      <description>func Home() (string, error) { user, err := user.Current() if nil == err { return user.HomeDir, nil } // cross compile support  if runtime.GOOS == &amp;#34;windows&amp;#34; { return homeWindows() } // Unix-like system, so just assume Unix  return homeUnix() } func homeUnix() (string, error) { // First prefer the HOME environmental variable  if home := os.Getenv(&amp;#34;HOME&amp;#34;); home != &amp;#34;&amp;#34; { return home, nil } // If that fails, try the shell  var stdout bytes.</description>
    </item>
    
    <item>
      <title>interface类型</title>
      <link>https://rx-78-kum0.github.io/post/golang/interface%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Mon, 09 Mar 2020 00:00:00 +0800</pubDate>
      
      <guid>https://rx-78-kum0.github.io/post/golang/interface%E7%B1%BB%E5%9E%8B/</guid>
      <description>Go 语言与鸭子类型的关系  If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.
如果某个东西长得像鸭子, 像鸭子一样游泳, 像鸭子一样嘎嘎叫, 那它就可以被看成是一只鸭子.
在 Go 语言中, 如果类型的方法集完全包含接口的方法集，则可认为该类型实现了该接口.
 鸭子类型是一种动态语言的风格, 在这种风格中, 一个对象有效的语义, 不是由继承自特定的类或实现特定的接口, 而是由它&amp;quot;当前方法和属性的集合&amp;quot;决定. Go 作为一种静态语言, 通过接口实现了 鸭子类型, 实际上是 Go 的编译器在其中作了隐匿的转换工作.
值接收者和指针接收者的区别 package main import &amp;#34;fmt&amp;#34; type Person struct { age int } func (p Person) howOld() int { return p.age } func (p *Person) growUp() { p.</description>
    </item>
    
    <item>
      <title>一个包含 nil 指针的接口不是 nil 接口</title>
      <link>https://rx-78-kum0.github.io/post/golang/%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%AB-nil-%E6%8C%87%E9%92%88%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%B8%8D%E6%98%AF-nil-%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Mon, 25 Mar 2019 00:00:00 +0800</pubDate>
      
      <guid>https://rx-78-kum0.github.io/post/golang/%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%AB-nil-%E6%8C%87%E9%92%88%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%B8%8D%E6%98%AF-nil-%E6%8E%A5%E5%8F%A3/</guid>
      <description>golang 接口值: 一个包含 nil 指针的接口不是 nil 接口.
一个不包含任何值的 nil 接口值和一个刚好包含 nil 指针的接口值是不同的.
 接口值由两个部分组成:
 一个具体的类型 那个类型的值  它们被称为接口的动态类型和动态值.
   type value     x x    接口的零值是指动态类型为nil, 动态值也为nil.
   type value     nil nil    这样的接口才能满足 接口值 == nil.
var a interface{} fmt.Println(a == nil) // true 一个不包含任何值的 nil 接口值: interface 类型变量的动态类型和动态值都为 nil. 比如 nil, 或者:</description>
    </item>
    
  </channel>
</rss>