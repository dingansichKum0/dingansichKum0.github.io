{"categories":[{"title":"code","uri":"https://rx-78-kum0.github.io/categories/code/"},{"title":"configuration","uri":"https://rx-78-kum0.github.io/categories/configuration/"}],"posts":[{"content":"小对象要合并 函数频繁创建的简单的对象，直接返回对象，效果比返回指针效果要好 类型转换要注意，官方用法消耗特别大。 package string_util import ( \u0026#34;unsafe\u0026#34; ) func str2bytes(s string) []byte { x := (*[2]uintptr)(unsafe.Pointer(\u0026amp;s)) h := [3]uintptr{x[0], x[1], x[1]} return *(*[]byte)(unsafe.Pointer(\u0026amp;h)) } func bytes2str(b []byte) string { return *(*string)(unsafe.Pointer(\u0026amp;b)) } 避免反复创建slice，map func(r*Reader)Read()([]byte,error) // 此函数没有形参，每次调用的时候返回一个[]byte。 func(r*Reader)Read(buf[]byte)(int,error) // 此函数个函数在每次迪调用的时候，会重用形参声明。  避免使用\u0026quot;+\u0026quot;拼接字符串 package string_utils import ( \u0026#34;strings\u0026#34; ) func strAppend(s string, ss ...string) string { var r strings.Builder r.WriteString(s) for _, v := range ss { r.WriteString(v) } return r.String() } ","id":0,"section":"post","summary":"小对象要合并 函数频繁创建的简单的对象，直接返回对象，效果比返回指针效果要好 类型转换要注意，官方用法消耗特别大。 package string_util import ( \u0026#34;unsafe\u0026#34; ) func str2bytes(s string) []byte { x := (*[2]uintptr)(unsafe.Pointer(\u0026amp;s)) h","tags":["golang"],"title":"golang gc优化","uri":"https://rx-78-kum0.github.io/2020/06/gc%E4%BC%98%E5%8C%96/","year":"2020"},{"content":"package util-time import ( \u0026#34;strconv\u0026#34; \u0026#34;time\u0026#34; ) // 获取当前的时间 - 字符串 func GetCurrentDate() string { return time.Now().Format(\u0026#34;2006/01/02 15:04:05\u0026#34;) } // 获取当前的时间 - Unix时间戳 func GetCurrentUnix() int64 { return time.Now().Unix() } // 获取当前的时间 - 毫秒级时间戳 func GetCurrentMilliUnix() int64 { return time.Now().UnixNano() / 1000000 } // 获取当前的时间 - 纳秒级时间戳 func GetCurrentNanoUnix() int64 { return time.Now().UnixNano() } func GetCurrentTime() string { var cstSh, _ = time.LoadLocation(\u0026#34;Asia/Shanghai\u0026#34;) t := time.Now().In(cstSh).Format(\u0026#34;2006/01/02/ 15:04:05\u0026#34;) return t } func GetCurrentHour() int { var cstSh, _ = time.LoadLocation(\u0026#34;Asia/Shanghai\u0026#34;) t,_ := strconv.Atoi(time.Now().In(cstSh).Format(\u0026#34;2006010215\u0026#34;)) return t } func GetCurrentDay() int { var cstSh, _ = time.LoadLocation(\u0026#34;Asia/Shanghai\u0026#34;) t,_ := strconv.Atoi(time.Now().In(cstSh).Format(\u0026#34;20060102\u0026#34;)) return t } func GetLastDay() int { var cstSh, _ = time.LoadLocation(\u0026#34;Asia/Shanghai\u0026#34;) nTime := time.Now() t,_ := strconv.Atoi(nTime.AddDate(0,0,-1).In(cstSh).Format(\u0026#34;20060102\u0026#34;)) return t } func GetlastHour() int { nTime := time.Now() lastTime := nTime.Add(time.Hour * -1) t,_ := strconv.Atoi(lastTime.Format(\u0026#34;2006010215\u0026#34;)) return t } ","id":1,"section":"post","summary":"package util-time import ( \u0026#34;strconv\u0026#34; \u0026#34;time\u0026#34; ) // 获取当前的时间 - 字符串 func GetCurrentDate() string { return time.Now().Format(\u0026#34;2006/01/02 15:04:05\u0026#34;) } // 获取当前的时间 - Unix时间戳 func GetCurrentUnix() int64 { return time.Now().Unix() } // 获取当前的时间 - 毫秒级时间戳 func GetCurrentMilliUnix() int64 { return","tags":["golang"],"title":"golang time工具函数","uri":"https://rx-78-kum0.github.io/2020/06/time/","year":"2020"},{"content":"GDT(Global Descriptor Table)全局描述符表Ⅰ GDT是一个以 段描述符 为表项的数组类型的数据结构，在内存中线性存放。每个段描述符占 8 个字节。\nGDTR寄存器存放GDT表的基地址和表长界限(高32位存放GDT基址，低16为存放GDT限长)。指令LGDT和SGDT分别用于加载和保存GDTR寄存器的内容。在机器刚加电或处理器复位后，基地址被默认地设置为0，而长度值被设置成0xFFFF。在保护模式初始化过程中必须给GDTR加载一个新值。\n段选择子(Segement Selector) 由GDTR访问全局描述符表是通过“段选择子”(实模式下的段寄存器)来完成的。段选择子是一个16位的寄存器(同实模式下的段寄存器相同)。\n段选择子共16bit，由三部分组成: 描述符索引(index)、TI、请求特权级(RPL)  描述符索引(index): 在描述符表中定位一个段描述符。 TI: 描述符表指示器， TI＝0 时，表示描述符在 GDT 中； TI＝1 时，描述符在 LDT 中。 RPL: 请求特权级，表示给出当前选择子访问的内存段的特权级别。每一个段都有一个特定的级别。每当一个程序试图访问某一个段时，就将该程序所拥有的特权级与要访问的特权级进行比较，以决定能否访问该段。系统约定，CPU只能访问同一特权级或级别较低特权级的段。  因为每个描述符占 8 字节，因此描述符在表内的偏移地址是索引号乘以 8 处理器在执行任何改变段选择器的指令时(比如 pop、 mov、jmp far、 call far、 iret、 retf)，就将指令中提供的索引号乘以 8 作为偏移地址，同 GDTR 中提供的线性基地址相加，以访问 GDT。在表内找到的描述符，并加载到不可见的描述符高速缓存部分。此后每当有访问内存的指令时，就不再访问 GDT 中的描述符，直接用当前段寄存器描述符高速缓存器提供线性基地址。\n段描述符(Segment Descriptor) 每个段描述符占 8 个字节。由三部分组成: 线性基地址、段界限和段的访问属性。\n    G: 粒度位，用于解释段界限的含义。当 G 位是\u0026quot;0\u0026quot;时，段界限以字节为单位。此时，段的扩展范围是从 1 字节到 1 兆字节（ 1B～1MB），因为描述符中的界限值是 20 位的。相反，如果该位是\u0026quot;1\u0026rdquo;，那么，段界限是以 4KB 为单位的。这样，段的扩展范围是从 4KB到 4GB。\n  D/B: \u0026ldquo;默认的操作数大小\u0026rdquo;(Default Operation Size)或者\u0026quot;默认的堆栈指针大小\u0026rdquo;，又或者\u0026quot;上部边界\u0026quot;标志。设立该标志位，主要是为了能够在 32 位处理器上兼容运行 16 位保护模式的程序。D＝0 表示指令中的偏移地址或者操作数是 16 位的； D＝1，指示 32 位的偏移地址或者操作数。\n  L: 64 位代码段标志。保留此位给 64 位处理器使用。32位将此位置\u0026quot;0\u0026rdquo;。\n  AVL: 保留位。可以被系统软件使用。\n  P: 段存在位(Segment Present)。 P 位用于指示描述符所对应的段是否存在。一般来说，描述符所指示的段都位于内存中。但是，当内存空间紧张时，有可能只是建立了描述符，对应的内存空间并不存在，这时，就应当把描述符的 P 位清零，表示段并不存在。P 位是由处理器负责检查的。每当通过描述符访问内存中的段时，如果 P 位是\u0026quot;0\u0026rdquo;，处理器就会产生一个异常中断。\n  DPL: 描述符的特权级(Descriptor Privilege Level， DPL)。这两位用于指定段的特权级。共有 4 种处理器支持的特权级别，分别是 0、 1、 2、 3，其中 0 是最高特权级别， 3 是最低特权级别。刚进入保护模式时执行的代码具有最高特权级 0(可以看成是从处理器那里继承来的)，这些代码通常都是操作系统代码(内核段)，因此它的特权级别最高。每当操作系统加载一个用户程序时，它通常都会指定一个稍低的特权级(用户段)，比如 3 特权级。不同特权级别的程序是互相隔离的，其互访是严格限制的，而且有些处理器指令(特权指令)只能由 0 特权级的程序来执行，为的就是安全。这里再次点明了为何叫保护模式。\n  S: 用于指定描述符的类型(Descriptor Type)。当该位是\u0026quot;0\u0026quot;时，表示是一个系统段；为\u0026quot;1\u0026quot;时，表示是一个代码段或者数据段(堆栈段也是特殊的数据段)。\n  TYPE: 共 4 位，用于指示描述符的子类型，或者说是类别。\n  描述符类型   ","id":2,"section":"post","summary":"GDT(Global Descriptor Table)全局描述符表Ⅰ GDT是一个以 段描述符 为表项的数组类型的数据结构，在内存中线性存放。每个段描述符占 8 个字节。 GDTR寄存器存放","tags":["操作系统"],"title":"GDT\u0026LDT","uri":"https://rx-78-kum0.github.io/2020/06/gdtldt/","year":"2020"},{"content":"func Home() (string, error) { user, err := user.Current() if nil == err { return user.HomeDir, nil } // cross compile support  if runtime.GOOS == \u0026#34;windows\u0026#34; { return homeWindows() } // Unix-like system, so just assume Unix  return homeUnix() } func homeUnix() (string, error) { // First prefer the HOME environmental variable  if home := os.Getenv(\u0026#34;HOME\u0026#34;); home != \u0026#34;\u0026#34; { return home, nil } // If that fails, try the shell  var stdout bytes.Buffer cmd := exec.Command(\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;eval echo ~$USER\u0026#34;) cmd.Stdout = \u0026amp;stdout if err := cmd.Run(); err != nil { return \u0026#34;\u0026#34;, err } result := strings.TrimSpace(stdout.String()) if result == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;blank output when reading home directory\u0026#34;) } return result, nil } func homeWindows() (string, error) { drive := os.Getenv(\u0026#34;HOMEDRIVE\u0026#34;) path := os.Getenv(\u0026#34;HOMEPATH\u0026#34;) home := drive + path if drive == \u0026#34;\u0026#34; || path == \u0026#34;\u0026#34; { home = os.Getenv(\u0026#34;USERPROFILE\u0026#34;) } if home == \u0026#34;\u0026#34; { return \u0026#34;\u0026#34;, errors.New(\u0026#34;HOMEDRIVE, HOMEPATH, and USERPROFILE are blank\u0026#34;) } return home, nil } ","id":3,"section":"post","summary":"func Home() (string, error) { user, err := user.Current() if nil == err { return user.HomeDir, nil } // cross compile support if runtime.GOOS == \u0026#34;windows\u0026#34; { return homeWindows() } // Unix-like system, so just assume Unix return homeUnix() } func homeUnix() (string, error) { // First prefer the HOME environmental variable if home := os.Getenv(\u0026#34;HOME\u0026#34;); home != \u0026#34;\u0026#34; { return home, nil } // If that fails, try the","tags":["golang"],"title":"获取用户home目录路径","uri":"https://rx-78-kum0.github.io/2020/06/%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7home%E7%9B%AE%E5%BD%95%E8%B7%AF%E5%BE%84/","year":"2020"},{"content":"标签(Label) 指向一大块的首地址。使用方法: LABEL_NAME: XXX XXX\n局部Label 以(点)开头，比如.begin，.1，.2。在不同的段中可以使用相同的带点开头的LABEL，不能重复。最好只用在代码段中。\n变量 函数变量 指的是一个SUB_RUTIN的首地址。比如DispStr，使用的时候是call DispStr，然后在声明时候因为它本来就是一个地址，就是用上面标签的同样的声明方式。 DispStr:（注意后面有冒号）\n普通变量 使用equ生成的纯的变量(宏) 比如：TopOfStack equ $ - LABEL_STACK - 1\n使用db dd dw生成的变量(地址) 生成的各种变量分别指向的是不同的数据类型(冒号可加可不加) 比如： _dwDispPos: dd (80 * 6 + 0) * 2\n","id":4,"section":"post","summary":"标签(Label) 指向一大块的首地址。使用方法: LABEL_NAME: XXX XXX 局部Label 以(点)开头，比如.begin，.1，.2。在不同的段中可以使用相同的带","tags":["汇编"],"title":"变量和标签","uri":"https://rx-78-kum0.github.io/2020/06/%E5%8F%98%E9%87%8F%E5%92%8C%E6%A0%87%E7%AD%BE/","year":"2020"},{"content":"Mac   首先需安装cmake和llvm\nbrew install cmake llvm   emacs里执行M-x irony-install-server得到安装执行命令\ncmake -DCMAKE_INSTALL_PREFIX\\=/Users/kumotyou/.emacs.d/irony/ \\ /Users/kumotyou/.emacs.d/elpa/irony-20200130.849/server \\ \u0026amp;\u0026amp; cmake --build . --use-stderr --config Release --target install   添加环境变量\n-DCMAKE_PREFIX_PATH=/usr/local/opt/llvm -DCMAKE_INSTALL_RPATH_USE_LINK_PATH=ON -DLIBCLANG_INCLUDE_DIR=/usr/local/opt/llvm/include -DLIBCLANG_LIBRARY=/usr/local/opt/llvm/lib/libclang.dylib   最终编译命令\ncmake -DCMAKE_INSTALL_PREFIX\\=/Users/kumotyou/.emacs.d/irony/ \\ -DCMAKE_PREFIX_PATH=/usr/local/opt/llvm \\ -DCMAKE_INSTALL_RPATH_USE_LINK_PATH=ON \\ -DLIBCLANG_INCLUDE_DIR=/usr/local/opt/llvm/include \\ -DLIBCLANG_LIBRARY=/usr/local/opt/llvm/lib/libclang.dylib \\ /Users/kumotyou/.emacs.d/elpa/irony-20200130.849/server \\ \u0026amp;\u0026amp; cmake --build . --use-stderr --config Release --target install   Ubuntu   拉取ccls源码, 并进入ccls根目录\ngit clone https://github.com/MaskRay/ccls cd ccls   拉取第三方依赖. (主要是rapidjson)\ngit submodule update --init --recursive   下载llvm的二进制包并解压\nwget -c http://releases.llvm.org/9.0.0/clang+llvm-9.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz tar xf clang+llvm-9.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz   在根目录下执行cmake 执行结果保存到Release文件夹中\ncmake -H. -BRelease -DCMAKE_BUILD_TYPE=Release -DCMAKE_PREFIX_PATH=/path/to/clang+llvm-9.0.0-x86_64-linux-gnu-ubuntu-18.04 cmake --build Release   开始编译\ncd Release make -j4 #使用4线程编译   编译完成, 安装\nsudo make install   ","id":5,"section":"post","summary":"Mac 首先需安装cmake和llvm brew install cmake llvm emacs里执行M-x irony-install-server得到安装执行命令 cmake -DCMAKE_INSTALL_PREFIX\\=/Users/kumotyou/.emacs.d/irony/ \\ /Users/kumotyou/.emacs.d/elpa/irony-20200130.849/server \\ \u0026amp;\u0026amp; cmake --build . --use-stderr --config","tags":["emacs"],"title":"irony-server-install","uri":"https://rx-78-kum0.github.io/2020/05/irony-server-install/","year":"2020"},{"content":"############################################################### # Configuration file for Bochs ############################################################### # how much memory the emulated machine will have megs: 32 # filename of ROM images romimage: file=/usr/local/share/bochs/BIOS-bochs-latest vgaromimage: file=/usr/local/share/bochs/VGABIOS-lgpl-latest # what disk images will be used floppya: 1_44=a.img, status=inserted # choose the boot disk. boot: floppy # where do we send log messages? # log: bochsout.txt # disable the mouse mouse: enabled=0 # enable key mapping, using US layout as default. # keyboard_mapping: enabled=1, map=/usr/local/share/bochs/keymaps/x11-pc-us.map keyboard: keymap=/usr/local/share/bochs/keymaps/x11-pc-us.map ","id":6,"section":"post","summary":"############################################################### # Configuration file for Bochs ############################################################### # how much memory the emulated machine will have megs: 32 # filename of ROM images romimage: file=/usr/local/share/bochs/BIOS-bochs-latest vgaromimage: file=/usr/local/share/bochs/VGABIOS-lgpl-latest # what disk images will be used floppya: 1_44=a.img, status=inserted # choose the boot disk. boot: floppy # where do we send log messages? # log: bochsout.txt # disable the mouse mouse: enabled=0 # enable key mapping, using US layout as default. #","tags":["nasm"],"title":"bochsrc","uri":"https://rx-78-kum0.github.io/2020/05/bochsrc/","year":"2020"},{"content":"ld: dynamic main executables must link with libSystem.dylib for architecture x86_64 # -lSystem ld a.o -o a -lSystem ","id":7,"section":"post","summary":"ld: dynamic main executables must link with libSystem.dylib for architecture x86_64 # -lSystem ld a.o -o a -lSystem","tags":["汇编","mac"],"title":"mac编译nasm问题汇总","uri":"https://rx-78-kum0.github.io/2020/05/mac%E7%BC%96%E8%AF%91nasm%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/","year":"2020"},{"content":" 汇编语言和CPU息息相关，但是不能把汇编语言完全等同于CPU的机器指令。不同架构的CPU指令并不相同，如x86，powerpc，arm各有各的指令系统；甚至同一种架构的CPU有几套指令集，典型的如arm除了有32位的指令集外，还有一套16位的thumb指令集。但是作为开发语言的汇编，本质上是一套语法规则和助记符的集合，它可以包容不同的指令集。如果从CPU体系来划分，常见的汇编有两种：IBM PC汇编和ARM汇编。 IBM PC汇编也就是Intel的汇编，因为IBM 最早推出PC机，后来的体系很多都要和它兼容，所以也使用了相同的汇编语言。ARM压根没考虑过兼容，它的指令集和x86完全是两个体系，所以汇编语言也独立发展出一套。 CPU只是限定了机器码，作为开发语言的汇编，其实还和编译器息息相关。汇编语言出现的早，没有像C语言一样定义出标准，所以编译器的厂商各搞一套。到现在，最有名的也是两家：MASM和GNU ASM。前者是微软的，只支持x86，用在DOS/Windows平台中；后者是开源产品，主要用在Linux中，基本上支持大部分的CPU架构。这两者的区别在于伪指令的不同，伪指令是用来告诉编译器如何工作的，和编译器相关，和CPU无关。其实汇编的编译相当简单，这两套伪指令只是符号不相同，含义是大同小异，明白了一种，看另一种就很容易了。\n CPU体系分类  IBM PC汇编 ARM汇编  汇编格式分类 Intel格式 windows平台常见，后者最早由贝尔实验室推出，用于Unix中\nAT\u0026amp;T格式 GUN汇编器的缺省格式\n GNU的汇编器和调试器gdb对这两种格式都支持，可以随便切换。MASM只支持Intel格式。Intel格式和AT\u0026amp;T格式的区别只是符号系统的区别，这与x86和arm的区别可不一样，后者是CPU体系的区别。\n内嵌汇编 用于C语言和汇编语言混合编程的，所以和编译器也关系紧密。\n GNU的内嵌汇编 (不是很容易看懂，需要专门学习) MASM的内嵌汇编 (MASM的内嵌汇编和普通汇编的区别则不大)  ","id":8,"section":"post","summary":"汇编语言和CPU息息相关，但是不能把汇编语言完全等同于CPU的机器指令。不同架构的CPU指令并不相同，如x86，powerpc，arm各有各","tags":["汇编"],"title":"汇编语言种类","uri":"https://rx-78-kum0.github.io/2020/05/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A7%8D%E7%B1%BB/","year":"2020"},{"content":"docker-compose 配置 version: \u0026#39;3\u0026#39; services: # mysql blog_mysql: image: mysql restart: always ports: - \u0026#39;3306:3306\u0026#39; environment: - MYSQL_ROOT_PASSWORD=xxxx volumes: - \u0026#39;/data/mysql:/var/lib/mysql\u0026#39; docker 安装完mysql 后客户端无法访问 进入镜像中的mysql docker exec -it container_id /bin/bash 登录mysql mysql -u root -p 修改root账号, 可以通过任何客户端连接 ALTER USER \u0026#39;root\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED WITH mysql_native_password BY \u0026#39;xxxxx\u0026#39;; ","id":9,"section":"post","summary":"docker-compose 配置 version: \u0026#39;3\u0026#39; services: # mysql blog_mysql: image: mysql restart: always ports: - \u0026#39;3306:3306\u0026#39; environment: - MYSQL_ROOT_PASSWORD=xxxx volumes: - \u0026#39;/data/mysql:/var/lib/mysql\u0026#39; docker 安装完mysql 后客户端无法访问 进入镜像中的mysql docker exec -it container_id /bin/bash 登录mysql mysql -u root -p 修改ro","tags":["mysql","docker"],"title":"docker部署mysql问题汇总","uri":"https://rx-78-kum0.github.io/2020/05/docker%E9%83%A8%E7%BD%B2mysql%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/","year":"2020"},{"content":".flex { flex-shrink: 0; } ","id":10,"section":"post","summary":".flex { flex-shrink: 0; }","tags":["css"],"title":"flex宽度失效","uri":"https://rx-78-kum0.github.io/2020/04/flex%E5%AE%BD%E5%BA%A6%E5%A4%B1%E6%95%88/","year":"2020"},{"content":"context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height);  img 规定要使用的图像, 画布或视频. sx 可选. 开始剪切的 x 坐标位置. sy 可选. 开始剪切的 y 坐标位置. swidth 可选. 被剪切图像的宽度. sheight 可选. 被剪切图像的高度. x 在画布上放置图像的 x 坐标位置. y 在画布上放置图像的 y 坐标位置. width 可选. 要使用的图像的宽度.(伸展或缩小图像) height 可选. 要使用的图像的高度.(伸展或缩小图像)  ","id":11,"section":"post","summary":"context.drawImage(img,sx,sy,swidth,sheight,x,y,width,height); img 规定要使用的图像, 画布或视频. sx 可选. 开始剪切的 x 坐标位置. sy 可选. 开始剪切的 y 坐标位置. swidth 可选. 被剪切图像的宽度. sheight 可选. 被剪切图像的","tags":["web"],"title":"canvas-drawImage","uri":"https://rx-78-kum0.github.io/2020/03/canvas-drawimage/","year":"2020"},{"content":"#!/usr/bin/env bash  # Print nyan cat # https://github.com/steckel/Git-Nyan-Graph/blob/master/nyan.sh # If you want big animated version: `telnet miku.acm.uiuc.edu` e=\u0026#39;\\033\u0026#39; RESET=\u0026#34;$e[0m\u0026#34; BOLD=\u0026#34;$e[1m\u0026#34; CYAN=\u0026#34;$e[0;96m\u0026#34; RED=\u0026#34;$e[0;91m\u0026#34; YELLOW=\u0026#34;$e[0;93m\u0026#34; GREEN=\u0026#34;$e[0;92m\u0026#34; echo if [ $[$RANDOM%2] -eq \u0026#34;0\u0026#34; ]; then echo -en $RED\u0026#39;`·.,¸,.·*·.\u0026#39; echo -e $RESET$BOLD\u0026#39;╭━━━━╮\u0026#39;$RESET echo -en $YELLOW\u0026#39;`·.,¸,.·*·.\u0026#39; echo -e $RESET$BOLD\u0026#39;|::: /\\_/\\\\\u0026#39;$RESET echo -en $GREEN\u0026#39;`·.,¸,.·*·.\u0026#39; echo -e $RESET$BOLD\u0026#39;|:::( ◕ᴥ◕)\u0026#39;$RESET echo -en $CYAN\u0026#39;`·.,¸,.·*·.\u0026#39; echo -e $RESET$BOLD\u0026#39;u-u━━-u--u\u0026#39;$RESET else echo -en $RED\u0026#39;-_-_-_-_-_-_-_\u0026#39; echo -e $RESET$BOLD\u0026#39;,------,\u0026#39;$RESET echo -en $YELLOW\u0026#39;_-_-_-_-_-_-_-\u0026#39; echo -e $RESET$BOLD\u0026#39;| /\\_/\\\\\u0026#39;$RESET echo -en $GREEN\u0026#39;-_-_-_-_-_-_-\u0026#39; echo -e $RESET$BOLD\u0026#39;~|__( ^ .^)\u0026#39;$RESET echo -en $CYAN\u0026#39;-_-_-_-_-_-_-\u0026#39; echo -e $RESET$BOLD\u0026#39;\u0026#34;\u0026#34; \u0026#34;\u0026#34;\u0026#39;$RESET fi echo   ","id":12,"section":"post","summary":"#!/usr/bin/env bash  # Print nyan cat # https://github.com/steckel/Git-Nyan-Graph/blob/master/nyan.sh # If you want big animated version: `telnet miku.acm.uiuc.edu` e=\u0026#39;\\033\u0026#39; RESET=\u0026#34;$e[0m\u0026#34; BOLD=\u0026#34;$e[1m\u0026#34; CYAN=\u0026#34;$e[0;96m\u0026#34; RED=\u0026#34;$e[0;91m\u0026#34; YELLOW=\u0026#34;$e[0;93m\u0026#34; GREEN=\u0026#34;$e[0;92m\u0026#34; echo if [ $[$RANDOM%2] -eq \u0026#34;0\u0026#34; ]; then echo -en $RED\u0026#39;`·.,¸,.·*·.\u0026#39; echo -e $RESET$BOLD\u0026#39;╭━━━━╮\u0026#39;$RESET echo -en $YELLOW\u0026#39;`·.,¸,.·*·.\u0026#39; echo -e $RESET$BOLD\u0026#39;|::: /\\_/\\\\\u0026#39;$RESET echo -en $GREEN\u0026#39;`·.,¸,.·*·.\u0026#39; echo -e $RESET$BOLD\u0026#39;|:::( ◕ᴥ◕)\u0026#39;$RESET echo -en $CYAN\u0026#39;`·.,¸,.·*·.\u0026#39; echo -e $RESET$BOLD\u0026#39;u-u━━-u--u\u0026#39;$RESET else echo -en $RED\u0026#39;-_-_-_-_-_-_-_\u0026#39; echo -e $RESET$BOLD\u0026#39;,------,\u0026#39;$RESET echo -en $YELLOW\u0026#39;_-_-_-_-_-_-_-\u0026#39; echo -e $RESET$BOLD\u0026#39;| /\\_/\\\\\u0026#39;$RESET echo -en $GREEN\u0026#39;-_-_-_-_-_-_-\u0026#39; echo -e $RESET$BOLD\u0026#39;~|__( ^ .","tags":["shell"],"title":"nyan","uri":"https://rx-78-kum0.github.io/2020/03/nyan/","year":"2020"},{"content":"// js 表情emoji转码 // 发送请求时将uft16转为utf-8 function utf16toEntities(str) { var patt = /[\\ud800-\\udbff][\\udc00-\\udfff]/g; // 检测utf16字符正则  return str.replace(patt, function(char) { var H, L, code; if (char.length === 2) { H = char.charCodeAt(0); // 取出高位  L = char.charCodeAt(1); // 取出低位  code = (H - 0xd800) * 0x400 + 0x10000 + L - 0xdc00; // 转换算法  return \u0026#39;\u0026amp;#\u0026#39; + code + \u0026#39;;\u0026#39;; } else { return char; } }); } // 收到后端的数据时展示emoji function entitiesToUtf16(str) { return str.replace(/\u0026amp;#(\\d+);/g, function(match, dec) { let H = Math.floor((dec - 0x10000) / 0x400) + 0xd800; let L = (Math.floor(dec - 0x10000) % 0x400) + 0xdc00; return String.fromCharCode(H, L); }); } ","id":13,"section":"post","summary":"// js 表情emoji转码 // 发送请求时将uft16转为utf-8 function utf16toEntities(str) { var patt = /[\\ud800-\\udbff][\\udc00-\\udfff]/g; // 检测utf16字符正则 return str.replace(patt, function(char) { var H, L, code; if (char.length === 2) { H = char.charCodeAt(0); // 取出高位","tags":["web"],"title":"浏览器显示emoji","uri":"https://rx-78-kum0.github.io/2020/03/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BAemoji/","year":"2020"},{"content":"Go 语言与鸭子类型的关系  If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck.\n如果某个东西长得像鸭子, 像鸭子一样游泳, 像鸭子一样嘎嘎叫, 那它就可以被看成是一只鸭子.\n在 Go 语言中, 如果类型的方法集完全包含接口的方法集，则可认为该类型实现了该接口.\n 鸭子类型是一种动态语言的风格, 在这种风格中, 一个对象有效的语义, 不是由继承自特定的类或实现特定的接口, 而是由它\u0026quot;当前方法和属性的集合\u0026quot;决定. Go 作为一种静态语言, 通过接口实现了 鸭子类型, 实际上是 Go 的编译器在其中作了隐匿的转换工作.\n值接收者和指针接收者的区别 package main import \u0026#34;fmt\u0026#34; type Person struct { age int } func (p Person) howOld() int { return p.age } func (p *Person) growUp() { p.age += 1 } func main() { // qcrao 是值类型  qcrao := Person{age: 18} // 值类型 调用接收者也是值类型的方法  fmt.Println(qcrao.howOld()) // 值类型 调用接收者是指针类型的方法  qcrao.growUp() fmt.Println(qcrao.howOld()) // ----------------------  // stefno 是指针类型  stefno := \u0026amp;Person{age: 100} // 指针类型 调用接收者是值类型的方法  fmt.Println(stefno.howOld()) // 指针类型 调用接收者也是指针类型的方法  stefno.growUp() fmt.Println(stefno.howOld()) }    - 值接收者 指针接收者     值类型调用者 方法会使用调用者的一个副本，类似于\u0026quot;传值\u0026rdquo; 使用值的引用来调用方法, 上例中 qcrao.growUp() 实际上是 (\u0026amp;qcrao).growUp()   指针类型调用者 指针被解引用为值, 上例中, stefno.howOld() 实际上是 (*stefno).howOld() 实际上也是\u0026quot;传值\u0026rdquo;, 方法里的操作会影响到调用者, 类似于指针传参, 拷贝了一份指针    区别 如果方法的接收者是值类型, 无论调用者是对象还是对象指针, 修改的都是对象的副本, 不影响调用者; 如果方法的接收者是指针类型, 则调用者修改的是指针指向的对象本身.\n使用值接收者还是指针接收者, 不是由该方法是否修改了调用者 (也就是接收者) 来决定, 而是应该基于该类型的本质.\n 如果类型具备\u0026quot;原始的本质\u0026rdquo;, 也就是说它的成员都是由 Go 语言里内置的原始类型, 如字符串, 整型值等, 那就定义值接收者类型的方法. 像内置的引用类型, 如 slice, map, interface, channel, 这些类型比较特殊, 声明他们的时候, 实际上是创建了一个 header, 对于他们也是直接定义值接收者类型的方法. 这样, 调用函数时, 是直接 copy 了这些类型的 header, 而 header 本身就是为复制设计的. 如果类型具备非原始的本质, 不能被安全地复制, 这种类型总是应该被共享, 那就定义指针接收者的方法. 比如 go 源码里的文件结构体 (struct File) 就不应该被复制, 应该只有一份实体.  iface 和 eface 的区别 iface 和 eface 都是 Go 中描述接口的底层结构体, 区别在于 iface 描述的接口包含方法, 而 eface 则是不包含任何方法的空接口: interface{}.\niface import \u0026#34;unsafe\u0026#34; type iface struct { tab *itab // 接口类型以及实际类型  data unsafe.Pointer // 接口具体的值, 一般而言是一个指向堆内存的指针 } type itab struct { inter *interfacetype _type *_type hash uint32 // copy of _type.hash. Used for type switches.  _ [4]byte fun [1]uintptr // variable sized. 存储的是第一个方法的函数指针，如果有更多的方法，在它之后的内存空间里继续存储. } type interfacetype struct { typ _type pkgpath name mhdr []imethod } type _type struct { // 类型大小  size uintptr ptrdata uintptr // 类型的 hash 值  hash uint32 // 类型的 flag，和反射相关  tflag tflag // 内存对齐相关  align uint8 fieldalign uint8 // 类型的编号，有bool, slice, struct 等等等等  kind uint8 equal func(unsafe.Pointer, unsafe.Pointer) bool // gc 相关  gcdata *byte str nameOff ptrToThis typeOff }   eface type eface struct { _type *_type data unsafe.Pointer } _type _type 是描述 Go 语言中各种数据类型的结构体\ntype _type struct { // 类型大小  size uintptr ptrdata uintptr // 类型的 hash 值  hash uint32 // 类型的 flag，和反射相关  tflag tflag // 内存对齐相关  align uint8 fieldalign uint8 // 类型的编号，有bool, slice, struct 等等等等  kind uint8 equal func(unsafe.Pointer, unsafe.Pointer) bool // gc 相关  gcdata *byte str nameOff ptrToThis typeOff } Go 语言各种数据类型都是在 _type 字段的基础上, 增加一些额外的字段来进行管理的:\ntype arraytype struct { typ _type elem *_type slice *_type len uintptr } type chantype struct { typ _type elem *_type dir uintptr } type slicetype struct { typ _type elem *_type } type functype struct { typ _type inCount uint16 outCount uint16 } type ptrtype struct { typ _type elem *_type } type structfield struct { name name typ *_type offsetAnon uintptr } 这些数据类型的结构体定义, 是反射实现的基础.\n接口的动态类型和动态值 import \u0026#34;unsafe\u0026#34; type iface struct { tab *itab // 接口类型以及实际类型  data unsafe.Pointer // 接口具体的值, 一般而言是一个指向堆内存的指针 } iface 类型包含两个字段:\n tab: 是接口表指针，指向类型信息 data: 是数据指针，则指向具体的数据  接口类型和 nil 作比较 接口值的零值是指动态类型和动态值都为 nil, 这个接口才能被认为 接口值 == nil.\n  package main import \u0026#34;fmt\u0026#34; func main() { var a interface{} fmt.Println(c == nil) // true  var b *string fmt.Println(b == nil) // true  a = b fmt.Println(a == nil) // false } b 赋值给 a 后, a 的动态类型为 *string , 动态值为 nil , 所以 a == nil 为 false .\n  package main import \u0026#34;fmt\u0026#34; type MyError string func (i MyError) Error() string { return i } func main() { err := HandleError() fmt.Println(err == nil) // false } func HandleError() error { var err *MyError = nil return err } 调用 HandleError 返回 error 接口类型, 动态类型为 *MyError , 动态值为 nil .\n  打印接口的动态值和类型 package main import ( \u0026#34;unsafe\u0026#34; \u0026#34;fmt\u0026#34; ) type iface struct { itab, data uintptr } func main() { var a interface{} = nil var b interface{} = (*int)(nil) x := 5 var c interface{} = (*int)(\u0026amp;x) ia := *(*iface)(unsafe.Pointer(\u0026amp;a)) ib := *(*iface)(unsafe.Pointer(\u0026amp;b)) ic := *(*iface)(unsafe.Pointer(\u0026amp;c)) fmt.Println(ia) // {0 0}  fmt.Println(ib) // {17426912 0}  fmt.Println(ic) // {17426912 842350714568}  fmt.Println(*(*int)(unsafe.Pointer(ic.data))) // 5 }  a 的动态类型和动态值的地址均为 0, 也就是 nil; b 的动态类型和 c 的动态类型一致, 都是 *int; c 的动态值为 5.  编译器自动检测类型是否实现接口 var _ io.Writer = (*myWriter)(nil) 编译器会由此检查 *myWriter 类型是否实现了 io.Writer 接口.\npackage main import \u0026#34;io\u0026#34; type myWriter string func (w *myWriter) Write(p []byte) (n int, err error) { return } func main() { // 检查 *myWriter 类型是否实现了 io.Writer 接口  var _ io.Writer = (*myWriter)(nil) // 检查 myWriter 类型是否实现了 io.Writer 接口  var _ io.Writer = myWriter{} } src/main.go:15:6: cannot use myWriter literal (type myWriter) as type io.Writer in assignment: myWriter does not implement io.Writer (missing Write method) myWriter 没用实现 io.Writer\n接口类型的赋值 (构造) 和断言 赋值 针对不同类型有以下函数:\n convT2E16, convT2I16 convT2E32, convT2I32 convT2E64, convT2I64 convT2Estring, convT2Istring convT2Eslice, convT2Islice convT2Enoptr, convT2Inoptr\n func convT2I(tab *itab, elem unsafe.Pointer) (i iface) { t := tab._type if raceenabled { raceReadObjectPC(t, elem, getcallerpc(), funcPC(convT2I)) } if msanenabled { msanread(elem, t.size) } x := mallocgc(t.size, t, true) typedmemmove(t, x, elem) i.tab = tab i.data = x return } 把 tab 赋给了 iface 的 tab 字段; data 部分则是在堆上申请了一块内存, 然后将 elem 指向的数据拷贝过去.\n断言 func assertI2I(inter *interfacetype, i iface) (r iface) { tab := i.tab if tab == nil { // explicit conversions require non-nil interface value.  panic(\u0026amp;TypeAssertionError{nil, nil, \u0026amp;inter.typ, \u0026#34;\u0026#34;}) } if tab.inter == inter { r.tab = tab r.data = i.data return } r.tab = getitab(inter, tab._type, false) r.data = i.data return } func assertI2I2(inter *interfacetype, i iface) (r iface, b bool) { tab := i.tab if tab == nil { return } if tab.inter != inter { tab = getitab(inter, tab._type, true) if tab == nil { return } } r.tab = tab r.data = i.data b = true return } func assertE2I(inter *interfacetype, e eface) (r iface) { t := e._type if t == nil { // explicit conversions require non-nil interface value.  panic(\u0026amp;TypeAssertionError{nil, nil, \u0026amp;inter.typ, \u0026#34;\u0026#34;}) } r.tab = getitab(inter, t, false) r.data = e.data return } func assertE2I2(inter *interfacetype, e eface) (r iface, b bool) { t := e._type if t == nil { return } tab := getitab(inter, t, true) if tab == nil { return } r.tab = tab r.data = e.data b = true return } 判断需断言的变量 (iface) 是否满足接口类型 (interfacetype).\nassertI2I 对应 接口断言返回一个参数:\npackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) func main(args) { var a interface{} = errors.New(\u0026#34;error\u0026#34;) err := a.(error) fmt.Println(err.Error()) } assertI2I2 则对应返回两个参数的情况:\npackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; ) func main(args) { var a interface{} = errors.New(\u0026#34;error\u0026#34;) if err, ok := a.(error); ok { fmt.Println(err.Error()) } } 都在编译阶段编译器判断.\n打印接口类型的hash值 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;unsafe\u0026#34; ) type iface struct { tab *itab data unsafe.Pointer } type itab struct { inter uintptr _type uintptr hash uint32 _ [4]byte fun [1]uintptr } func main() { p := Person(Student{age: 18}) iface := (*iface)(unsafe.Pointer(\u0026amp;p)) fmt.Printf(\u0026#34;iface.tab.hash = %#x\\n\u0026#34;, iface.tab.hash) // iface.tab.hash = 0xd4209fda } 类型转换和断言的区别 类型转换 Go 语言中不允许隐式类型转换, 也就是说 = 两边, 不允许出现类型不相同的变量. 类型转换前后的两个类型必须相互兼容.\n \u0026lt;结果类型\u0026gt; := \u0026lt;目标类型\u0026gt; ( \u0026lt;表达式\u0026gt; )\n package main import \u0026#34;fmt\u0026#34; func main() { var i int = 9 var f float64 f = float64(i) fmt.Printf(\u0026#34;%T, %v\\n\u0026#34;, f, f) f = 10.8 a := int(f) fmt.Printf(\u0026#34;%T, %v\\n\u0026#34;, a, a) // s := []int(i) } 断言 空接口 interface{} 没有定义任何函数, 因此 Go 中所有类型都实现了空接口. 当一个函数的形参是 interface{}, 那么在函数中, 需要对形参进行断言, 从而得到它的真实类型.\n \u0026lt;目标类型的值\u0026gt;，\u0026lt;布尔参数\u0026gt; := \u0026lt;表达式\u0026gt;.( 目标类型 ) // 安全类型断言 \u0026lt;目标类型的值\u0026gt; := \u0026lt;表达式\u0026gt;.( 目标类型 )　//非安全类型断言\n package main import \u0026#34;fmt\u0026#34; type Student struct { Name string Age int } func main() { var i interface{} = new(Student) s := i.(*Student) fmt.Println(s) } switch 形式断言\npackage main import \u0026#34;fmt\u0026#34; type Student struct { Name string Age int } func main() { var i interface{} judge(i) } func judge(v interface{}) { fmt.Printf(\u0026#34;%p %v\\n\u0026#34;, \u0026amp;v, v) switch v := v.(type) { case nil: fmt.Printf(\u0026#34;%p %v\\n\u0026#34;, \u0026amp;v, v) fmt.Printf(\u0026#34;nil type[%T] %v\\n\u0026#34;, v, v) case Student: fmt.Printf(\u0026#34;%p %v\\n\u0026#34;, \u0026amp;v, v) fmt.Printf(\u0026#34;Student type[%T] %v\\n\u0026#34;, v, v) case *Student: fmt.Printf(\u0026#34;%p %v\\n\u0026#34;, \u0026amp;v, v) fmt.Printf(\u0026#34;*Student type[%T] %v\\n\u0026#34;, v, v) default: fmt.Printf(\u0026#34;%p %v\\n\u0026#34;, \u0026amp;v, v) fmt.Printf(\u0026#34;unknow\\n\u0026#34;) } } fmt.Println 函数 fmt.Println 函数的参数是 interface{}. 对于内置类型, 函数内部会用穷举法, 得出它的真实类型, 然后转换为字符串打印. 而对于自定义类型, 首先确定该类型是否实现了 String() 方法. 如果实现了, 则直接打印输出 String() 方法的结果; 否则, 会通过反射来遍历对象的成员进行打印.\n因为 Student 结构体没有实现 String() 方法, 所以 fmt.Println 会利用反射挨个打印成员变量:\npackage main import \u0026#34;fmt\u0026#34; type Student struct { Name string Age int } func main() { s := Student{ Name: \u0026#34;zzz\u0026#34;, Age: 18, } fmt.Println(s) // {zzz 18} } 增加一个 String() 方法的实现:\nimport \u0026#34;fmt\u0026#34; func (s Student) String() string { return fmt.Sprintf(\u0026#34;[Name: %s], [Age: %d]\u0026#34;, s.Name, s.Age) // [Name: zzz], [Age: 18] } 修改 String() 方法:\nimport \u0026#34;fmt\u0026#34; func (s *Student) String() string { return fmt.Sprintf(\u0026#34;[Name: %s], [Age: %d]\u0026#34;, s.Name, s.Age) // {zzz 18} } 打印结果并没用调用 String() ,因为:\n 类型 T 只有接受者是 T 的方法; 而类型 *T 拥有接受者是 T 和 *T 的方法. 语法上 T 能直接调 *T 的方法仅仅是 Go 的语法糖.\n 要调用 String() 需要:\nfmt.Println(\u0026amp;s) 接口转换的原理 类型有 m 个方法, 某接口有 n 个方法, 则很容易知道这种判定的时间复杂度为 O(mn); Go 会对方法集的函数按照函数名的字典序进行排序, 所以实际的时间复杂度为 O(m+n).\npackage main import \u0026#34;fmt\u0026#34; type coder interface { code() run() } type runner interface { run() } type Gopher struct { language string } func (g Gopher) code() { return } func (g Gopher) run() { return } func main() { var c coder = Gopher{} var r runner r = c fmt.Println(c, r) } Gopher 类型同时满足 coder 接口和 runner 接口.\nconvI2I 函数将一个 interface 转换成 另一个 interface .\nfunc convI2I(inter *interfacetype, i iface) (r iface) { tab := i.tab if tab == nil { return } if tab.inter == inter { r.tab = tab r.data = i.data return } r.tab = getitab(inter, tab._type, false) r.data = i.data return } inter 表示要转成的接口类型, i 表示一个实体类型. 如果要转换的接口类型和实体类型的接口类型相同就直接返回; 否则就用调用 getitab 函数去匹配满转方法集的接口.\nimport \u0026#34;unsafe\u0026#34; func getitab(inter *interfacetype, typ *_type, canfail bool) *itab { if len(inter.mhdr) == 0 { throw(\u0026#34;internal error - misuse of itab\u0026#34;) } // easy case  if typ.tflag\u0026amp;tflagUncommon == 0 { if canfail { return nil } name := inter.typ.nameOff(inter.mhdr[0].name) panic(\u0026amp;TypeAssertionError{nil, typ, \u0026amp;inter.typ, name.name()}) } var m *itab // First, look in the existing table to see if we can find the itab we need.  // This is by far the most common case, so do it without locks.  // Use atomic to ensure we see any previous writes done by the thread  // that updates the itabTable field (with atomic.Storep in itabAdd).  t := (*itabTableType)(atomic.Loadp(unsafe.Pointer(\u0026amp;itabTable))) if m = t.find(inter, typ); m != nil { goto finish } // Not found. Grab the lock and try again.  lock(\u0026amp;itabLock) if m = itabTable.find(inter, typ); m != nil { unlock(\u0026amp;itabLock) goto finish } // Entry doesn\u0026#39;t exist yet. Make a new entry \u0026amp; add it.  m = (*itab)(persistentalloc(unsafe.Sizeof(itab{})+uintptr(len(inter.mhdr)-1)*sys.PtrSize, 0, \u0026amp;memstats.other_sys)) m.inter = inter m._type = typ // The hash is used in type switches. However, compiler statically generates itab\u0026#39;s  // for all interface/type pairs used in switches (which are added to itabTable  // in itabsinit). The dynamically-generated itab\u0026#39;s never participate in type switches,  // and thus the hash is irrelevant.  // Note: m.hash is _not_ the hash used for the runtime itabTable hash table.  m.hash = 0 m.init() itabAdd(m) unlock(\u0026amp;itabLock) finish: if m.fun[0] != 0 { return m } if canfail { return nil } // this can only happen if the conversion  // was already done once using the , ok form  // and we have a cached negative result.  // The cached result doesn\u0026#39;t record which  // interface function was missing, so initialize  // the itab again to get the missing function name.  panic(\u0026amp;TypeAssertionError{concrete: typ, asserted: \u0026amp;inter.typ, missingMethod: m.init()}) } getitab 函数会根据 interfacetype 和 _type 去全局的 itab 哈希表中查找, 如果能找到, 则直接返回; 否则, 会根据给定的 interfacetype 和 _type 新生成一个 itab, 并插入到 itab 哈希表, 这样下一次就可以直接拿到 itab.\n这里查找了两次, 并且第二次上锁了, 这是因为如果第一次没找到, 在第二次仍然没有找到相应的 itab 的情况下, 需要新生成一个, 并且写入哈希表, 因此需要加锁. 这样, 其他协程在查找相同的 itab 并且也没有找到时, 第二次查找时, 会被挂住, 之后, 就会查到第一个协程写入哈希表的 itab.\nitabAdd 函数会把 itab 写入到全局itabTable\nimport \u0026#34;unsafe\u0026#34; func itabAdd(m *itab) { // Bugs can lead to calling this while mallocing is set,  // typically because this is called while panicing.  // Crash reliably, rather than only when we need to grow  // the hash table.  if getg().m.mallocing != 0 { throw(\u0026#34;malloc deadlock\u0026#34;) } t := itabTable if t.count \u0026gt;= 3*(t.size/4) { // 75% load factor  // Grow hash table.  // t2 = new(itabTableType) + some additional entries  // We lie and tell malloc we want pointer-free memory because  // all the pointed-to values are not in the heap.  t2 := (*itabTableType)(mallocgc((2+2*t.size)*sys.PtrSize, nil, true)) t2.size = t.size * 2 // Copy over entries.  // Note: while copying, other threads may look for an itab and  // fail to find it. That\u0026#39;s ok, they will then try to get the itab lock  // and as a consequence wait until this copying is complete.  iterate_itabs(t2.add) if t2.count != t.count { throw(\u0026#34;mismatched count during itab table copy\u0026#34;) } // Publish new hash table. Use an atomic write: see comment in getitab.  atomicstorep(unsafe.Pointer(\u0026amp;itabTable), unsafe.Pointer(t2)) // Adopt the new table as our own.  t = itabTable // Note: the old table can be GC\u0026#39;ed here.  } t.add(m) } func iterate_itabs(fn func(*itab)) { // Note: only runs during stop the world or with itabLock held,  // so no other locks/atomics needed.  t := itabTable for i := uintptr(0); i \u0026lt; t.size; i++ { m := *(**itab)(add(unsafe.Pointer(\u0026amp;t.entries), i*sys.PtrSize)) if m != nil { fn(m) } } } 如何用 interface 实现多态 多态是一种运行期的行为, 它有以下几个特点:\n 一种类型具有多种类型的能力 允许不同的对象对同一消息做出灵活的反应 以一种通用的方式对待个使用的对象 非动态语言必须通过继承和接口的方式来实现  package main import \u0026#34;fmt\u0026#34; func main() { s := Student{age: 18} whatJob(\u0026amp;s) growUp(\u0026amp;s) fmt.Println(s) p := Programmer{age: 100} whatJob(p) growUp(p) fmt.Println(p) } func whatJob(p Person) { p.job() } func growUp(p Person) { p.growUp() } type Person interface { job() growUp() } type Student struct { age int } func (p Student) job() { fmt.Println(\u0026#34;I am a student.\u0026#34;) return } func (p *Student) growUp() { p.age += 1 return } type Programmer struct { age int } func (p Programmer) job() { fmt.Println(\u0026#34;I am a programmer.\u0026#34;) return } func (p Programmer) growUp() { p.age += 10 return } Go 接口与 C++ 接口有何异同 接口定义了一种规范, 描述了类的行为和功能, 而不做具体实现.\nC++ 的接口是使用抽象类来实现的, 如果类中至少有一个函数被声明为纯虚函数, 则这个类就是抽象类. 纯虚函数是通过在声明中使用 \u0026ldquo;= 0\u0026rdquo; 来指定的. 例如:\nclass Shape { public: // 纯虚函数  virtual double getArea() = 0; private: string name; // 名称 };  设计抽象类的目的, 是为了给其他类提供一个可以继承的适当的基类. 抽象类不能被用于实例化对象, 它只能作为接口使用. 派生类需要明确地声明它继承自基类, 并且需要实现基类中所有的纯虚函数.\nC++ 定义接口的方式称为“侵入式”, 而 Go 采用的是 “非侵入式”, 不需要显式声明, 只需要实现接口定义的函数, 编译器自动会识别.\nC++ 和 Go 在定义接口方式上的不同, 也导致了底层实现上的不同. C++ 通过虚函数表来实现基类调用派生类的函数; 而 Go 通过 itab 中的 fun 字段来实现接口变量调用实体类型的函数. C++ 中的虚函数表是在编译期生成的; 而 Go 的 itab 中的 fun 字段是在运行期间动态生成的. 原因在于, Go 中实体类型可能会无意中实现 N 多接口, 很多接口并不是本来需要的, 所以不能为类型实现的所有接口都生成一个 itab, 这也是“非侵入式”带来的影响; 这在 C++ 中是不存在的, 因为派生需要显示声明它继承自哪个基类.\n ","id":14,"section":"post","summary":"Go 语言与鸭子类型的关系 If it looks like a duck, swims like a duck, and quacks like a duck, then it probably is a duck. 如果某个东西长得像鸭子, 像鸭子一样游泳, 像鸭子一样嘎嘎叫, 那它就可以被看成是","tags":["golang"],"title":"interface类型","uri":"https://rx-78-kum0.github.io/2020/03/interface%E7%B1%BB%E5%9E%8B/","year":"2020"},{"content":"// 文字超出省略号 .text-overflow { overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } // 文字超出两行省略号, block元素 .text-overflow-2 { word-break: break-all; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; line-clamp: 2; -webkit-box-orient: vertical; } ","id":15,"section":"post","summary":"// 文字超出省略号 .text-overflow { overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } // 文字超出两行省略号, block元素 .text-overflow-2 { word-break: break-all; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; line-clamp: 2; -webkit-box-orient: vertical; }","tags":["css"],"title":"文字超出显示省略号","uri":"https://rx-78-kum0.github.io/2020/03/%E6%96%87%E5%AD%97%E8%B6%85%E5%87%BA%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7/","year":"2020"},{"content":"线程: 执行指令序列 保留了并发的优点, 避免了进程切换的代价. 实质: 映射表不变, PC指针变.\n价值, 用处 浏览器\n 一个线程用来从服务器接收数据 一个线程用来显示文本 一个线程用来处理图片(解压缩) 一个线程用来显示图片  接收数据线程等待时可以切换到另一个线程(如显示文本), 更加高效利用CPU, 程序交互更加人性化.\n线程切换 多线程执行互不干扰, 所以一个线程执行序列对应一个(或套)栈. 线程切换就是切换TCB.\nTCB (Thread Control Block) 保存线程的信息(执行序列的栈). 与PCB相似, 只是比PCB储存的信息少而已.\n用户级线程 用户态切来切去. CPL为3. TCB在用户程序中.\nvoid ThreadCeate(A) { TCB *tcb = malloc(); // 申请内存创建TCB  *stack = malloc(); // 创建栈  *stack = A; // 保存栈  tcb.esp = stack } // 线程切换 void Yield() { TCB2.esp = esp; esp = TCB1.esp; // esp: CPU寄存器  // jmp xxx; // 不需要再jmp xxx, 因为调用Yield时已经把Yield后面执行的内容压栈. } 缺点 一个进程里的某个用户级线程触发系统IO(如网卡, 磁盘等)后系统会切换到其他进程执行. 这个进程其他线程就无法执行.\n核心级线程 多\u0026quot;套\u0026rdquo;(用户栈 + 内核栈)TCB在内核中. 中断进入内核\n优点 多核心CPU支持, 核心级线程可以并行执行.\n","id":16,"section":"post","summary":"线程: 执行指令序列 保留了并发的优点, 避免了进程切换的代价. 实质: 映射表不变, PC指针变. 价值, 用处 浏览器 一个线程用来从服务器接收数据 一个线程","tags":["操作系统"],"title":"多线程","uri":"https://rx-78-kum0.github.io/2020/03/%E5%A4%9A%E7%BA%BF%E7%A8%8B/","year":"2020"},{"content":"进程: 进行中的程序 进行中的程序与磁盘中的静态程序不一样. 进程是描述一个运行中的程序. 进程 = 资源(映射表) + 多个执行指令序列(线程) 进程只能在内核. 要分配资源, 访问文件.\n 有开始, 结束 走走停停(切换) 需要记录  为了充分使用CPU 一次IO操作对应数百万(很多很多)次CPU计算操作. 为了充分合理使用CPU, 需要多个进程交替执行. \u0026ndash; [并发]\n多进程是操作系统的核心 操作系统的核心就是记录, 管理, 合理推进多个进程. 使用计算机就是启用多个进程.\n多进程的组织 PCB + 状态 + 队列\nPCB(Proess Control Block) 记录进程信息的数据结构. 便于切回时继续执行.\n状态  就绪态 阻塞态 运行态  就绪态 \u0026mdash;\u0026mdash;\u0026ndash;\u0026raquo; 运行态 \\ / \\ / 阻塞态\n队列  就绪队列 PCB1 \u0026ndash; PCB3 \u0026ndash; PCB5 磁盘等待队列 PCB2 \u0026ndash; PCB4 \u0026ndash; PCB6  多进程的交替 队列 + 调度 + 切换\nvoid schedule() { pNew = getNext(ReadyQueue); // 调度  switch_to(pCur, pNew); // pCur, pNew PCB } 把当前进程保存起来, 切入另一个的进程.\nvoid swtich_to(pCur, pNew) { pCur.ax = CPU.ax; pCur.bx = CPU.bx; // ...  pCur.cs = CPU.cs; pCur.retpc = CPU.pc; CPU.ax = pNew.ax; CPU.bx = pNew.bx; // ...  CPU.cs = pNew.cs; CPU.pc = pNew.retpc; } 多进程的内存管理 通过映射表实现内存地址空间的分离.\n进程1 内存地址[100] \u0026mdash;\u0026gt; 进程1的映射表 \u0026mdash;-\u0026gt; 物理内存 780 进程2 内存地址[100] \u0026mdash;\u0026gt; 进程2的映射表 \u0026mdash;-\u0026gt; 物理内存 1260\n多进程的合作 生产者与消费者 进程同步不能随意切换进程, 必须同步进程合理切换.\n","id":17,"section":"post","summary":"进程: 进行中的程序 进行中的程序与磁盘中的静态程序不一样. 进程是描述一个运行中的程序. 进程 = 资源(映射表) + 多个执行指令序列(线程) 进程只能在","tags":["操作系统"],"title":"多进程","uri":"https://rx-78-kum0.github.io/2020/02/%E5%A4%9A%E8%BF%9B%E7%A8%8B/","year":"2020"},{"content":"// 硬编码一个二进制 trie type BinaryTrie = [ [ [ [ [[[[0, 1], [2, 3]], [[4, 5], [6, 7]]], [[[8, 9], [10, 11]], [[12, 13], [14, 15]]]], [[[[16, 17], [18, 19]], [[20, 21], [22, 23]]], [[[24, 25], [26, 27]], [[28, 29], [30, 31]]]] ], [ [[[[32, 33], [34, 35]], [[36, 37], [38, 39]]], [[[40, 41], [42, 43]], [[44, 45], [46, 47]]]], [[[[48, 49], [50, 51]], [[52, 53], [54, 55]]], [[[56, 57], [58, 59]], [[60, 61], [62, 63]]]] ] ], [ [ [[[[64, 65], [66, 67]], [[68, 69], [70, 71]]], [[[72, 73], [74, 75]], [[76, 77], [78, 79]]]], [[[[80, 81], [82, 83]], [[84, 85], [86, 87]]], [[[88, 89], [90, 91]], [[92, 93], [94, 95]]]] ], [ [[[[96, 97], [98, 99]], [[100, 101], [102, 103]]], [[[104, 105], [106, 107]], [[108, 109], [110, 111]]]], [[[[112, 113], [114, 115]], [[116, 117], [118, 119]]], [[[120, 121], [122, 123]], [[124, 125], [126, 127]]]] ] ] ], [ [ [ [[[[128, 129], [130, 131]], [[132, 133], [134, 135]]], [[[136, 137], [138, 139]], [[140, 141], [142, 143]]]], [[[[144, 145], [146, 147]], [[148, 149], [150, 151]]], [[[152, 153], [154, 155]], [[156, 157], [158, 159]]]] ], [ [[[[160, 161], [162, 163]], [[164, 165], [166, 167]]], [[[168, 169], [170, 171]], [[172, 173], [174, 175]]]], [[[[176, 177], [178, 179]], [[180, 181], [182, 183]]], [[[184, 185], [186, 187]], [[188, 189], [190, 191]]]] ] ], [ [ [[[[192, 193], [194, 195]], [[196, 197], [198, 199]]], [[[200, 201], [202, 203]], [[204, 205], [206, 207]]]], [[[[208, 209], [210, 211]], [[212, 213], [214, 215]]], [[[216, 217], [218, 219]], [[220, 221], [222, 223]]]] ], [ [[[[224, 225], [226, 227]], [[228, 229], [230, 231]]], [[[232, 233], [234, 235]], [[236, 237], [238, 239]]]], [[[[240, 241], [242, 243]], [[244, 245], [246, 247]]], [[[248, 249], [250, 251]], [[252, 253], [254, 255]]]] ] ] ] ]; // 数组操作 type Copy\u0026lt;T, S extends any\u0026gt; = { [P in keyof T]: S[P] }; type Unshift\u0026lt;T, A\u0026gt; = ((a: A, ...b: T extends any[] ? T : never) =\u0026gt; void) extends (...a: infer R) =\u0026gt; void ? R : never; type Push\u0026lt;T, A\u0026gt; = Copy\u0026lt;Unshift\u0026lt;T, any\u0026gt;, T \u0026amp; Record\u0026lt;string, A\u0026gt;\u0026gt;; // 搜索二进制 trie type SearchInTrie\u0026lt;Num, Node, Digits\u0026gt; = { 1: Node extends [infer A, infer B] ? Num extends A ? Push\u0026lt;Digits, 0\u0026gt; : Num extends B ? Push\u0026lt;Digits, 1\u0026gt; : never : never; 0: Node extends [infer A, infer B] ? SearchInTrie\u0026lt;Num, A, Push\u0026lt;Digits, 0\u0026gt;\u0026gt; | SearchInTrie\u0026lt;Num, B, Push\u0026lt;Digits, 1\u0026gt;\u0026gt; : never; }[Node extends [number, number] ? 1 : 0]; // 定义数字类型 type Digit = 0 | 1; type Bits = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7; type Uint8 = Record\u0026lt;Bits, Digit\u0026gt;; // 也可以定义成8个Digit的数组，这样写比较简短  type AsDigit\u0026lt;T\u0026gt; = T extends Digit ? T : never; type AsUint8\u0026lt;T\u0026gt; = T extends Uint8 ? T : never; // 数字转二进制表示 type ToUint8\u0026lt;A extends number\u0026gt; = SearchInTrie\u0026lt;A, BinaryTrie, []\u0026gt;; // 二进制表示转数字 type ToNumber\u0026lt;A extends Uint8\u0026gt; = BinaryTrie[A[0]][A[1]][A[2]][A[3]][A[4]][A[5]][A[6]][A[7]]; // 两个1 bit数相加，C 表示进位 type BitAdd\u0026lt;A extends Digit, B extends Digit, C extends Digit\u0026gt; = [ [[[0, 0], [1, 0]], [[1, 0], [0, 1]]], [[[1, 0], [0, 1]], [[0, 1], [1, 1]]] ][A][B][C]; // 8位数相加 type Uint8Add\u0026lt;A extends Uint8, B extends Uint8\u0026gt; = BitAdd\u0026lt;A[7], B[7], 0\u0026gt; extends [infer S7, infer C] ? BitAdd\u0026lt;A[6], B[6], AsDigit\u0026lt;C\u0026gt;\u0026gt; extends [infer S6, infer C] ? BitAdd\u0026lt;A[5], B[5], AsDigit\u0026lt;C\u0026gt;\u0026gt; extends [infer S5, infer C] ? BitAdd\u0026lt;A[4], B[4], AsDigit\u0026lt;C\u0026gt;\u0026gt; extends [infer S4, infer C] ? BitAdd\u0026lt;A[3], B[3], AsDigit\u0026lt;C\u0026gt;\u0026gt; extends [infer S3, infer C] ? BitAdd\u0026lt;A[2], B[2], AsDigit\u0026lt;C\u0026gt;\u0026gt; extends [infer S2, infer C] ? BitAdd\u0026lt;A[1], B[1], AsDigit\u0026lt;C\u0026gt;\u0026gt; extends [infer S1, infer C] ? BitAdd\u0026lt;A[0], B[0], AsDigit\u0026lt;C\u0026gt;\u0026gt; extends [infer S0, infer C] // ? C extends 1 ? \u0026#34;overflow\u0026#34; :  ? AsUint8\u0026lt;[S0, S1, S2, S3, S4, S5, S6, S7]\u0026gt; : never : never : never : never : never : never : never : never; // 位取反 type Reverse = [1, 0]; type Uint8Reverse\u0026lt;A extends Uint8\u0026gt; = [ Reverse[A[0]], Reverse[A[1]], Reverse[A[2]], Reverse[A[3]], Reverse[A[4]], Reverse[A[5]], Reverse[A[6]], Reverse[A[7]] ]; // 两个特殊数字方便使用 type ZERO = [0, 0, 0, 0, 0, 0, 0, 0]; type ONE = [0, 0, 0, 0, 0, 0, 0, 1]; // 补码 type Uint8Negate\u0026lt;A extends Uint8\u0026gt; = Uint8Add\u0026lt;Uint8Reverse\u0026lt;A\u0026gt;, ONE\u0026gt;; // 8位数相减 type Uint8Sub\u0026lt;A extends Uint8, B extends Uint8\u0026gt; = Uint8Add\u0026lt;A, Uint8Negate\u0026lt;B\u0026gt;\u0026gt;; // 左移 type LShift\u0026lt;A extends Uint8, B extends number, P extends Digit\u0026gt; = B extends 1 ? [A[1], A[2], A[3], A[4], A[5], A[6], A[7], P] : B extends 2 ? [A[2], A[3], A[4], A[5], A[6], A[7], P, P] : B extends 3 ? [A[3], A[4], A[5], A[6], A[7], P, P, P] : B extends 4 ? [A[4], A[5], A[6], A[7], P, P, P, P] : B extends 5 ? [A[5], A[6], A[7], P, P, P, P, P] : B extends 6 ? [A[6], A[7], P, P, P, P, P, P] : B extends 7 ? [A[7], P, P, P, P, P, P, P] : B extends 0 ? A : [P, P, P, P, P, P, P, P]; // 8位数乘1位数 type BitMul\u0026lt;A extends Uint8, B extends Digit, C extends Bits\u0026gt; = B extends 1 ? LShift\u0026lt;A, C, 0\u0026gt; : ZERO; // 8位数相乘 type Uint8Mul\u0026lt;A extends Uint8, B extends Uint8\u0026gt; = Uint8Add\u0026lt;ZERO, BitMul\u0026lt;A, B[7], 0\u0026gt;\u0026gt; extends infer S ? Uint8Add\u0026lt;AsUint8\u0026lt;S\u0026gt;, BitMul\u0026lt;A, B[6], 1\u0026gt;\u0026gt; extends infer S ? Uint8Add\u0026lt;AsUint8\u0026lt;S\u0026gt;, BitMul\u0026lt;A, B[5], 2\u0026gt;\u0026gt; extends infer S ? Uint8Add\u0026lt;AsUint8\u0026lt;S\u0026gt;, BitMul\u0026lt;A, B[4], 3\u0026gt;\u0026gt; extends infer S ? Uint8Add\u0026lt;AsUint8\u0026lt;S\u0026gt;, BitMul\u0026lt;A, B[3], 4\u0026gt;\u0026gt; extends infer S ? Uint8Add\u0026lt;AsUint8\u0026lt;S\u0026gt;, BitMul\u0026lt;A, B[2], 5\u0026gt;\u0026gt; extends infer S ? Uint8Add\u0026lt;AsUint8\u0026lt;S\u0026gt;, BitMul\u0026lt;A, B[1], 6\u0026gt;\u0026gt; extends infer S ? Uint8Add\u0026lt;AsUint8\u0026lt;S\u0026gt;, BitMul\u0026lt;A, B[0], 7\u0026gt;\u0026gt; : never : never : never : never : never : never : never; // 比较结果 type EQ = 0; type GT = 1; type LT = 2; // 1位数比较 type BitCMP\u0026lt;A extends Digit, B extends Digit\u0026gt; = [[EQ, LT], [GT, EQ]][A][B]; // 8位数比较 type Uint8CMP\u0026lt;A extends Uint8, B extends Uint8\u0026gt; = BitCMP\u0026lt;A[0], B[0]\u0026gt; extends GT | LT ? BitCMP\u0026lt;A[0], B[0]\u0026gt; : BitCMP\u0026lt;A[1], B[1]\u0026gt; extends GT | LT ? BitCMP\u0026lt;A[1], B[1]\u0026gt; : BitCMP\u0026lt;A[2], B[2]\u0026gt; extends GT | LT ? BitCMP\u0026lt;A[2], B[2]\u0026gt; : BitCMP\u0026lt;A[3], B[3]\u0026gt; extends GT | LT ? BitCMP\u0026lt;A[3], B[3]\u0026gt; : BitCMP\u0026lt;A[4], B[4]\u0026gt; extends GT | LT ? BitCMP\u0026lt;A[4], B[4]\u0026gt; : BitCMP\u0026lt;A[5], B[5]\u0026gt; extends GT | LT ? BitCMP\u0026lt;A[5], B[5]\u0026gt; : BitCMP\u0026lt;A[6], B[6]\u0026gt; extends GT | LT ? BitCMP\u0026lt;A[6], B[6]\u0026gt; : BitCMP\u0026lt;A[7], B[7]\u0026gt;; // 简单求余 type Remainder\u0026lt;A extends Uint8, B extends Uint8\u0026gt; = Uint8CMP\u0026lt;A, B\u0026gt; extends LT ? [0, A] : [1, Uint8Sub\u0026lt;A, B\u0026gt;]; // 8位数相除 type Uint8Div\u0026lt;A extends Uint8, B extends Uint8\u0026gt; = Remainder\u0026lt;LShift\u0026lt;ZERO, 1, A[0]\u0026gt;, B\u0026gt; extends [infer Q0, infer R] ? Remainder\u0026lt;LShift\u0026lt;AsUint8\u0026lt;R\u0026gt;, 1, A[1]\u0026gt;, B\u0026gt; extends [infer Q1, infer R] ? Remainder\u0026lt;LShift\u0026lt;AsUint8\u0026lt;R\u0026gt;, 1, A[2]\u0026gt;, B\u0026gt; extends [infer Q2, infer R] ? Remainder\u0026lt;LShift\u0026lt;AsUint8\u0026lt;R\u0026gt;, 1, A[3]\u0026gt;, B\u0026gt; extends [infer Q3, infer R] ? Remainder\u0026lt;LShift\u0026lt;AsUint8\u0026lt;R\u0026gt;, 1, A[4]\u0026gt;, B\u0026gt; extends [infer Q4, infer R] ? Remainder\u0026lt;LShift\u0026lt;AsUint8\u0026lt;R\u0026gt;, 1, A[5]\u0026gt;, B\u0026gt; extends [infer Q5, infer R] ? Remainder\u0026lt;LShift\u0026lt;AsUint8\u0026lt;R\u0026gt;, 1, A[6]\u0026gt;, B\u0026gt; extends [infer Q6, infer R] ? Remainder\u0026lt;LShift\u0026lt;AsUint8\u0026lt;R\u0026gt;, 1, A[7]\u0026gt;, B\u0026gt; extends [infer Q7, infer R] ? [AsUint8\u0026lt;[Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7]\u0026gt;, AsUint8\u0026lt;R\u0026gt;] : never : never : never : never : never : never : never : never; // 加 type Add\u0026lt;A extends number, B extends number\u0026gt; = ToNumber\u0026lt;Uint8Add\u0026lt;ToUint8\u0026lt;A\u0026gt;, ToUint8\u0026lt;B\u0026gt;\u0026gt;\u0026gt;; // 减 type Sub\u0026lt;A extends number, B extends number\u0026gt; = ToNumber\u0026lt;Uint8Sub\u0026lt;ToUint8\u0026lt;A\u0026gt;, ToUint8\u0026lt;B\u0026gt;\u0026gt;\u0026gt;; // 乘 type Mul\u0026lt;A extends number, B extends number\u0026gt; = ToNumber\u0026lt;Uint8Mul\u0026lt;ToUint8\u0026lt;A\u0026gt;, ToUint8\u0026lt;B\u0026gt;\u0026gt;\u0026gt;; // 除 type Div\u0026lt;A extends number, B extends number\u0026gt; = B extends 0 ? never : ToNumber\u0026lt;Uint8Div\u0026lt;ToUint8\u0026lt;A\u0026gt;, ToUint8\u0026lt;B\u0026gt;\u0026gt;[0]\u0026gt;; // 取余 type Mod\u0026lt;A extends number, B extends number\u0026gt; = B extends 0 ? never : ToNumber\u0026lt;Uint8Div\u0026lt;ToUint8\u0026lt;A\u0026gt;, ToUint8\u0026lt;B\u0026gt;\u0026gt;[1]\u0026gt;; // 测试 type case1_ShouldBe99 = Add\u0026lt;33, 66\u0026gt;; // 33 + 66 = 99 type case2_ShouldBe0 = Add\u0026lt;255, 1\u0026gt;; // 255 + 1 = 0 (overflow)  const a: case1_ShouldBe99 = 99; type case3_ShouldBe99 = Sub\u0026lt;123, 24\u0026gt;; // 123 - 24 = 99 type case4_ShouldBe255 = Sub\u0026lt;0, 1\u0026gt;; // 0 - 1 = 255 (overflow)  type case5_ShouldBe153 = Mul\u0026lt;17, 9\u0026gt;; // 17 x 9 = 153 type case6_ShouldBe253 = Mul\u0026lt;255, 3\u0026gt;; // 255 x 3 = 253 (overflow)  type case7_ShouldBe33 = Div\u0026lt;100, 3\u0026gt;; // 100 / 3 = 33 type case8_ShouldBeNever = Div\u0026lt;1, 0\u0026gt;; // 1 / 0 = error (divide by 0)  type case9_ShouldBe1 = Mod\u0026lt;100, 3\u0026gt;; // 100 % 3 = 1 type case10_ShouldBeNever = Mod\u0026lt;1, 0\u0026gt;; // 1 % 0 = error (divide by 0) ","id":18,"section":"post","summary":"// 硬编码一个二进制 trie type BinaryTrie = [ [ [ [ [[[[0, 1], [2, 3]], [[4, 5], [6, 7]]], [[[8, 9], [10, 11]], [[12, 13], [14, 15]]]], [[[[16, 17], [18, 19]], [[20, 21], [22, 23]]], [[[24, 25], [26, 27]], [[28, 29], [30, 31]]]] ], [ [[[[32, 33], [34, 35]], [[36, 37], [38, 39]]], [[[40, 41], [42, 43]], [[44, 45], [46, 47]]]], [[[[48, 49], [50,","tags":["typescript"],"title":"Typescript元编程","uri":"https://rx-78-kum0.github.io/2020/02/typescript%E5%85%83%E7%BC%96%E7%A8%8B/","year":"2020"},{"content":"# .clang-format BasedOnStyle: LLVM Language:\tCpp IndentWidth : 2 # 开括号(开圆括号、开尖括号、开方括号)后的对齐: Align, DontAlign, AlwaysBreak(总是在开括号后换行) AlignAfterOpenBracket:\tAlign # 大括号换行，只有当BreakBeforeBraces设置为Custom时才有效 BraceWrapping: # class定义后面 AfterClass:\tfalse # 控制语句后面 AfterControlStatement:\tfalse # enum定义后面 AfterEnum:\tfalse # 函数定义后面 AfterFunction:\ttrue # 命名空间定义后面 AfterNamespace:\tfalse # ObjC定义后面 AfterObjCDeclaration:\tfalse # struct定义后面 AfterStruct:\tfalse # union定义后面 AfterUnion:\tfalse # catch之前 BeforeCatch:\ttrue # else之前 BeforeElse:\ttrue # 缩进大括号 IndentBraces:\tfalse BreakBeforeBraces:\tCustom ","id":19,"section":"post","summary":"# .clang-format BasedOnStyle: LLVM Language: Cpp IndentWidth : 2 # 开括号(开圆括号、开尖括号、开方括号)后的对齐: Align, DontAlign, AlwaysBreak(总是在开括号后换行) AlignAfterOpenBracket: Align # 大括号换行，只有当","tags":["tools"],"title":"clang-format","uri":"https://rx-78-kum0.github.io/2020/02/clang-format/","year":"2020"},{"content":"# vi: ft=dosini [main] # Enables context sensitive auto-completion. If this is disabled the all # possible completions will be listed. smart_completion = True # Multi-line mode allows breaking up the sql statements into multiple lines. If # this is set to True, then the end of the statements must have a semi-colon. # If this is set to False then sql statements can\u0026#39;t be split into multiple # lines. End of line (return) is considered as the end of the statement. multi_line = True # Destructive warning mode will alert you before executing a sql statement # that may cause harm to the database such as \u0026#34;drop table\u0026#34;, \u0026#34;drop database\u0026#34; # or \u0026#34;shutdown\u0026#34;. destructive_warning = True # log_file location. log_file = ~/.mycli.log # Default log level. Possible values: \u0026#34;CRITICAL\u0026#34;, \u0026#34;ERROR\u0026#34;, \u0026#34;WARNING\u0026#34;, \u0026#34;INFO\u0026#34; # and \u0026#34;DEBUG\u0026#34;. \u0026#34;NONE\u0026#34; disables logging. log_level = INFO # Log every query and its results to a file. Enable this by uncommenting the # line below. # audit_log = ~/.mycli-audit.log # Timing of sql statments and table rendering. timing = True # Table format. Possible values: psql, plain, simple, grid, fancy_grid, pipe, # orgtbl, rst, mediawiki, html, latex, latex_booktabs, tsv. # Recommended: psql, fancy_grid and grid. table_format = psql # Syntax coloring style. Possible values (many support the \u0026#34;-dark\u0026#34; suffix): # manni, igor, xcode, vim, autumn, vs, rrt, native, perldoc, borland, tango, emacs, # friendly, monokai, paraiso, colorful, murphy, bw, pastie, paraiso, trac, default, # fruity. # Screenshots at http://mycli.net/syntax syntax_style = default # Keybindings: Possible values: emacs, vi. # Emacs mode: Ctrl-A is home, Ctrl-E is end. All emacs keybindings are available in the REPL. # When Vi mode is enabled you can use modal editing features offered by Vi in the REPL. key_bindings = emacs # Enabling this option will show the suggestions in a wider menu. Thus more items are suggested. wider_completion_menu = False # MySQL prompt # \\t - Product type (Percona, MySQL, Mariadb) # \\u - Username # \\h - Hostname of the server # \\d - Database name # \\n - Newline prompt = \u0026#39;\\t \\u@\\h:\\d\u0026gt; \u0026#39; prompt_continuation = \u0026#39;-\u0026gt; \u0026#39; # Skip intro info on startup and outro info on exit less_chatty = False # Use alias from --login-path instead of host name in prompt login_path_as_host = False # Custom colors for the completion menu, toolbar, etc. [colors] # Completion menus. Token.Menu.Completions.Completion.Current = \u0026#39;bg:#00aaaa #000000\u0026#39; Token.Menu.Completions.Completion = \u0026#39;bg:#008888 #ffffff\u0026#39; Token.Menu.Completions.MultiColumnMeta = \u0026#39;bg:#aaffff #000000\u0026#39; Token.Menu.Completions.ProgressButton = \u0026#39;bg:#003333\u0026#39; Token.Menu.Completions.ProgressBar = \u0026#39;bg:#00aaaa\u0026#39; # Selected text. Token.SelectedText = \u0026#39;#ffffff bg:#6666aa\u0026#39; # Search matches. (reverse-i-search) Token.SearchMatch = \u0026#39;#ffffff bg:#4444aa\u0026#39; Token.SearchMatch.Current = \u0026#39;#ffffff bg:#44aa44\u0026#39; # The bottom toolbar. Token.Toolbar = \u0026#39;bg:#222222 #aaaaaa\u0026#39; Token.Toolbar.Off = \u0026#39;bg:#222222 #888888\u0026#39; Token.Toolbar.On = \u0026#39;bg:#222222 #ffffff\u0026#39; # Search/arg/system toolbars. Token.Toolbar.Search = \u0026#39;noinherit bold\u0026#39; Token.Toolbar.Search.Text = \u0026#39;nobold\u0026#39; Token.Toolbar.System = \u0026#39;noinherit bold\u0026#39; Token.Toolbar.Arg = \u0026#39;noinherit bold\u0026#39; Token.Toolbar.Arg.Text = \u0026#39;nobold\u0026#39; # Favorite queries. [favorite_queries] ","id":20,"section":"post","summary":"# vi: ft=dosini [main] # Enables context sensitive auto-completion. If this is disabled the all # possible completions will be listed. smart_completion = True # Multi-line mode allows breaking up the sql statements into multiple lines. If # this is set to True, then the end of the statements must have a semi-colon. # If this is set to False then sql statements can\u0026#39;t be split into multiple # lines.","tags":["mysql","tools"],"title":"myclirc","uri":"https://rx-78-kum0.github.io/2019/12/myclirc/","year":"2019"},{"content":"angular的ControlValueAccessor是一个连接表单模型和视图DOM的抽象类接口\n使自定义表单组件像原生input一样映射到form表单模型中, 拥有自定义表单组件的form也能使用响应式表单. (也就是使自定义表单组件拥有formControlName属性和ngModel接口.)\n毕竟响应式表单才是angular的利器.\nControlValueAccessor export interface ControlValueAccessor { writeValue(obj: any): void; registerOnChange(fn: any): void; registerOnTouched(fn: any): void; setDisabledState?(isDisabled: boolean): void; } writeValue(obj: any): 该方法是接收模版中的ngModel.\nwriteValue(value: any): void { this._renderer.setProperty(this._elementRef.nativeElement, \u0026#39;value\u0026#39;, value); } registerOnChange(fn: any): void: 该方法是组件接收到 change 事件的回调, 可以用来通知外部达成双向绑定, 即ngModelChange.\nregisterOnChange(fn: (_: any) =\u0026gt; void): void { this._onChange = fn; } registerOnTouched(fn: any): 接收到 touched 事件的回调.\nregisterOnTouched(fn: any): void { this._onTouched = fn; } setDisabledState?(isDisabled: boolean): 该方法是组件输入状态 disable \u0026lt;=\u0026gt; enable 变化时的回调。该方法会根据参数值，启用或禁用指定的DOM元素.\n以下组件类实现了ControlValueAccessor接口. CheckboxControlValueAccessor 用于checkbox复选组件选择器:\n input[type=checkbox][formControlName] input[type=checkbox][formControl] input[type=checkbox][ngModel]  NumberValueAccessor 用于number类型的输入组件选择器:\n input[type=number][formControlName] input[type=number][formControl] input[type=number][ngModel]  DefaultValueAccessor 用于 text 和 textarea 类型的输入组件选择器:\n input:not([type=checkbox])[formControlName] textarea[formControlName] input:not([type=checkbox])[formControl] textarea[formControl] input:not([type=checkbox])[ngModel] textarea[ngModel] [ngDefaultControl]  RadioControlValueAccessor 用于radio单选组件选择器:\n input[type=radio][formControlName] input[type=radio][formControl] input[type=radio][ngModel]  扩展方法:\n fireUncheck(value: any): void:取消选中的回调.  RangeValueAccessor 用于范围输入组件选择器:\n input[type=range][formControlName] input[type=range][formControl] input[type=range][ngModel]  SelectControlValueAccessor 用于select组件选择器:\n select:not([multiple])[formControlName] select:not([multiple])[formControl] select:not([multiple])[ngModel]  扩展方法:\n compareWith: (o1: any, o2: any) =\u0026gt; boolean:比较函数. 例如option的ngValue是一个对象, 当选中项填入表单时,需要编写一个比较函数来处理当前选中的对象是哪一个option.  SelectMultipleControlValueAccessor 用于多选select组件选择器:\n select[multiple][formControlName] select[multiple][formControl] select[multiple][ngModel]  扩展方法: compareWith: (o1: any, o2: any) =\u0026gt; boolean:比较函数. 例如option的ngValue是一个对象, 当选中项填入表单时, 需要编写一个比较函数来处理当前选中的对象是哪一个option.\nEG 自定义表单组件代码结构 import { Component, OnInit, HostListener, ViewEncapsulation, forwardRef, Input, OnDestroy, ChangeDetectorRef, ChangeDetectionStrategy } from \u0026#39;@angular/core\u0026#39;; import { ControlValueAccessor, NG_VALUE_ACCESSOR } from \u0026#39;@angular/forms\u0026#39;; import { Subject } from \u0026#39;rxjs\u0026#39;; @Component({ selector : \u0026#39;[app-radiobox]\u0026#39;, templateUrl : \u0026#39;./radiobox.component.html\u0026#39;, styleUrls : [\u0026#39;./radiobox.component.styl\u0026#39;], encapsulation : ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, host : { \u0026#39;[class.radio-wrapper]\u0026#39; : \u0026#39;true\u0026#39;, \u0026#39;[class.radio-wrapper-checked]\u0026#39;: \u0026#39;checked\u0026#39; }, providers: [ { provide : NG_VALUE_ACCESSOR, useExisting: forwardRef(() =\u0026gt; RadioboxComponent), multi : true } ] }) export class RadioboxComponent implements OnInit, OnDestroy, ControlValueAccessor { @Input() value: boolean; checked: boolean; select$ = new Subject\u0026lt;RadioboxComponent\u0026gt;(); onChange: (_: any) =\u0026gt; void = () =\u0026gt; null; onTouched: () =\u0026gt; void = () =\u0026gt; null; constructor(private _cdr: ChangeDetectorRef) {} @HostListener(\u0026#39;click\u0026#39;, [\u0026#39;$event\u0026#39;]) onClick(e: MouseEvent): void { e.stopPropagation(); e.preventDefault(); this.checked = !this.checked; this.onChange(this.checked); this.select$.next(this); } writeValue(value: boolean) { this.checked = value; } registerOnChange(fn: (_: boolean) =\u0026gt; {}): void { this.onChange = fn; } registerOnTouched(fn: () =\u0026gt; {}): void { this.onTouched = fn; } ngOnInit() {} ngOnDestroy() {} } 调用 import { Component, OnInit } from \u0026#39;@angular/core\u0026#39;; import { FormBuilder, FormGroup } from \u0026#39;@angular/forms\u0026#39;; @Component({ selector: \u0026#39;app-example\u0026#39;, template: ` \u0026lt;form [formGroup]=\u0026#34;testForm\u0026#34;\u0026gt; \u0026lt;label\u0026gt;试试\u0026lt;/label\u0026gt; \u0026lt;label app-radiobox formControlName=\u0026#34;check\u0026#34;\u0026gt;check me\u0026lt;/label\u0026gt; \u0026lt;/form\u0026gt; ` }) export class ExampleComponent implements OnInit { testForm: FormGroup = this._fb.group({ check: false }); constructor(private _fb: FormBuilder) {} ngOnInit() { this.testForm.valueChanges.subscribe(d =\u0026gt; { console.log(d); }); } } ","id":21,"section":"post","summary":"angular的ControlValueAccessor是一个连接表单模型和视图DOM的抽象类接口 使自定义表单组件像原生input一样映射到","tags":["angular"],"title":"Angular自定义双向绑定表单组件","uri":"https://rx-78-kum0.github.io/2019/07/angular%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E8%A1%A8%E5%8D%95%E7%BB%84%E4%BB%B6/","year":"2019"},{"content":"\u0026#34; .vimrc \u0026#34; Configuration file for vim set modelines=0 \u0026#34; Don\u0026#39;t write backup file if vim is being called by \u0026#34;crontab -e\u0026#34; \u0026#34; au BufWrite /private/tmp/crontab.* set nowritebackup nobackup \u0026#34; Don\u0026#39;t write backup file if vim is being called by \u0026#34;chpass\u0026#34; \u0026#34; au BufWrite /private/etc/pw.* set nowritebackup nobackup set nobackup set nowritebackup let skip_defaults_vim=1 \u0026#34; \u0026lt;leader\u0026gt; let g:mapleader=\u0026#34;,\u0026#34; \u0026#34; 去掉有关vi一致性模式，避免以前版本的bug和局限 set nocompatible \u0026#34; 设置退格键可用 set backspace=2 \u0026#34; utf-8 set encoding=UTF-8 \u0026#34; 主题 \u0026#34; set background=dark \u0026#34; colorscheme dracula \u0026#34; 函数方法名加粗 let g:enable_bold_font = 1 \u0026#34; 注释斜体 let g:enable_italic_font = 1 \u0026#34; 透明背景 let g:hybrid_transparent_background = 1 \u0026#34; airline_theme let g:airline_theme = \u0026#34;hybrid\u0026#34; \u0026#34; 行号 set nu! \u0026#34; 高亮显示寻找匹配 set hls \u0026#34; 允许用指定语法高亮配色方案替换默认方案 syntax on dracula \u0026#34; 开启语法高亮 syntax enable \u0026#34; 设置匹配模式 (当输入一个左括号时会匹配相应的右括号) set showmatch \u0026#34; 显示当前光标位置 set ruler \u0026#34; 使用系统剪切板 set clipboard=unnamed \u0026#34; 设置格式化时代码缩进为2个空格 set shiftwidth=2 \u0026#34; tab键缩进为4格子 set tabstop=2 \u0026#34; 把连续数量的空格视为一个制表符 set softtabstop=2 \u0026#34; 禁止折行 set nowrap \u0026#34; tab键转换为空格 set expandtab \u0026#34; 智能缩进 set smartindent \u0026#34; 开启实时搜索功能 set incsearch \u0026#34; 搜索时大小写不敏感 set ignorecase \u0026#34; vim 自身命令行模式智能补全 set wildmenu \u0026#34; 开启文件类型侦测 filetype on \u0026#34; 根据侦测到的不同类型加载对应的插件 filetype plugin on \u0026#34; 自适应不同语言的智能缩进 filetype indent on \u0026#34; 将制表符扩展为空格 set nofoldenable \u0026#34; 基于缩进或语法进行代码折叠 set foldmethod=syntax \u0026#34; 启动 vim 时关闭折叠代码 set nofoldenable \u0026#34; 禁止光标闪烁 set gcr=a:block-blinkon0 \u0026#34; 禁止显示滚动条 set guioptions-=l set guioptions-=L set guioptions-=r set guioptions-=R \u0026#34; 高亮显示当前行/列 set cursorline set cursorcolumn \u0026#34; 让配置变更立即生效 autocmd BufWritePost $MYVIMRC source $MYVIMRC \u0026#34; normal 模式 keymap nnoremap x \u0026#34;_x nnoremap X \u0026#34;_X nnoremap d \u0026#34;_d nnoremap dd \u0026#34;_dd nnoremap D \u0026#34;_D nnoremap s \u0026#34;_s nnoremap S \u0026#34;_S nnoremap c \u0026#34;_c nnoremap C \u0026#34;_C \u0026#34; insert 模式 inoremap $( ()\u0026lt;esc\u0026gt;i inoremap $\u0026lt; \u0026lt;\u0026gt;\u0026lt;esc\u0026gt;i inoremap ${ {}\u0026lt;esc\u0026gt;i inoremap $[ []\u0026lt;esc\u0026gt;i inoremap $\u0026#39; \u0026#39;\u0026#39;\u0026lt;esc\u0026gt;i inoremap $\u0026#34; \u0026#34;\u0026#34;\u0026lt;esc\u0026gt;i \u0026#34; visual 模式 vnoremap s \u0026#34;_s vnoremap S \u0026#34;_S vnoremap z) c()\u0026lt;esc\u0026gt;hp vnoremap z} c{}\u0026lt;esc\u0026gt;hp vnoremap z] c[]\u0026lt;esc\u0026gt;hp vnoremap z\u0026#39; c\u0026#39;\u0026#39;\u0026lt;esc\u0026gt;hp vnoremap z\u0026#34; c\u0026#34;\u0026#34;\u0026lt;esc\u0026gt;hp vnoremap z\u0026gt; c\u0026lt;\u0026gt;\u0026lt;esc\u0026gt;hp vnoremap z` c``\u0026lt;esc\u0026gt;hp \u0026#34; NERDTree let g:NERDTreeIndicatorMapCustom = { \\ \u0026#34;Modified\u0026#34; : \u0026#34;✹\u0026#34;, \\ \u0026#34;Staged\u0026#34; : \u0026#34;✚\u0026#34;, \\ \u0026#34;Untracked\u0026#34; : \u0026#34;✭\u0026#34;, \\ \u0026#34;Renamed\u0026#34; : \u0026#34;➜\u0026#34;, \\ \u0026#34;Unmerged\u0026#34; : \u0026#34;═\u0026#34;, \\ \u0026#34;Deleted\u0026#34; : \u0026#34;✖\u0026#34;, \\ \u0026#34;Dirty\u0026#34; : \u0026#34;✗\u0026#34;, \\ \u0026#34;Clean\u0026#34; : \u0026#34;✔︎\u0026#34;, \\ \u0026#34;Unknown\u0026#34; : \u0026#34;?\u0026#34; \\ } \u0026#34; 自动开启NERDTree \u0026#34; autocmd vimenter * NERDTree \u0026#34; UltiSnips let g:UltiSnipsExpandTrigger=\u0026#34;\u0026lt;Leader\u0026gt;\u0026lt;TAB\u0026gt;\u0026#34; let g:UltiSnipsJumpForwardTrigger=\u0026#34;\u0026lt;c-f\u0026gt;\u0026#34; let g:UltiSnipsJumpBackwardTrigger=\u0026#34;\u0026lt;c-b\u0026gt;\u0026#34; \u0026#34;au BufRead,BufNewFile *.go set filetype=go \u0026#34; ycm \u0026#34; let g:ycm_key_list_select_completion=[\u0026#39;\u0026lt;c-n\u0026gt;\u0026#39;] \u0026#34; let g:ycm_key_list_previous_completion=[\u0026#39;\u0026lt;c-p\u0026gt;\u0026#39;] \u0026#34; let g:ycm_key_invoke_completion = \u0026#39;\u0026lt;C-Space\u0026gt;\u0026#39; \u0026#34; \u0026#34; 关闭加载.ycm_extra_conf.py提示 \u0026#34; let g:ycm_confirm_extra_conf=0 \u0026#34; \u0026#34; 开启 YCM 基于标签引擎 \u0026#34; let g:ycm_collect_identifiers_from_tags_files=1 \u0026#34; \u0026#34; 从第2个键入字符就开始罗列匹配项 \u0026#34; let g:ycm_min_num_of_chars_for_completion=1 \u0026#34; \u0026#34; 禁止缓存匹配项,每次都重新生成匹配项 \u0026#34; let g:ycm_cache_omnifunc=0 \u0026#34; \u0026#34; 语法关键字补全 \u0026#34; let g:ycm_seed_identifiers_with_syntax=1 \u0026#34; \u0026#34; 设置在下面几种格式的文件上屏蔽ycm \u0026#34; let g:ycm_filetype_blacklist = { \u0026#34; \\ \u0026#39;typescript.tsx\u0026#39; : 1, \u0026#34; \\ \u0026#39;typescript\u0026#39; : 1, \u0026#34; \\} \u0026#34; \u0026#34; 注释和字符串中的文字也会被收入补全 \u0026#34; let g:ycm_collect_identifiers_from_comments_and_strings = 0 \u0026#34; \u0026#34; 输入第2个字符开始补全 \u0026#34; let g:ycm_min_num_of_chars_for_completion=2 \u0026#34; 注释 \u0026#34; Add spaces after comment delimiters by default let g:NERDSpaceDelims = 1 \u0026#34; Use compact syntax for prettified multi-line comments let g:NERDCompactSexyComs = 1 \u0026#34; Align line-wise comment delimiters flush left instead of following code indentation let g:NERDDefaultAlign = \u0026#39;left\u0026#39; \u0026#34; Set a language to use its alternate delimiters by default let g:NERDAltDelims_java = 1 \u0026#34; Add your own custom formats or override the defaults let g:NERDCustomDelimiters = { \u0026#39;c\u0026#39;: { \u0026#39;left\u0026#39;: \u0026#39;/**\u0026#39;,\u0026#39;right\u0026#39;: \u0026#39;*/\u0026#39; } } \u0026#34; Allow commenting and inverting empty lines (useful when commenting a region) let g:NERDCommentEmptyLines = 1 \u0026#34; Enable trimming of trailing whitespace when uncommenting let g:NERDTrimTrailingWhitespace = 1 \u0026#34; Enable NERDCommenterToggle to check all selected lines is commented or not let g:NERDToggleCheckAllLines = 1 \u0026#34; coc let g:coc_global_extensions = [ \\ \u0026#39;coc-json\u0026#39;, \\ \u0026#39;coc-html\u0026#39;, \\ \u0026#39;coc-css\u0026#39;, \\ ] set cmdheight=2 set updatetime=300 set shortmess+=c set signcolumn=yes au BufNewFile,BufRead *.ts setlocal filetype=typescript au BufNewFile,BufRead *.tsx setlocal filetype=typescript.tsx nmap \u0026lt;silent\u0026gt; gd \u0026lt;Plug\u0026gt;(coc-definition) nmap \u0026lt;silent\u0026gt; gy \u0026lt;Plug\u0026gt;(coc-type-definition) nmap \u0026lt;silent\u0026gt; gi \u0026lt;Plug\u0026gt;(coc-implementation) nmap \u0026lt;silent\u0026gt; gr \u0026lt;Plug\u0026gt;(coc-references) nmap \u0026lt;leader\u0026gt;rn \u0026lt;Plug\u0026gt;(coc-rename) nmap \u0026lt;silent\u0026gt; [c \u0026lt;Plug\u0026gt;(coc-diagnostic-prev) nmap \u0026lt;silent\u0026gt; ]c \u0026lt;Plug\u0026gt;(coc-diagnostic-next) nmap \u0026lt;leader\u0026gt;a \u0026lt;Plug\u0026gt;(coc-codeaction-selected) nmap \u0026lt;leader\u0026gt;ac \u0026lt;Plug\u0026gt;(coc-codeaction) nmap \u0026lt;leader\u0026gt;qf \u0026lt;Plug\u0026gt;(coc-fix-current) nmap \u0026lt;silent\u0026gt; \u0026lt;TAB\u0026gt; \u0026lt;Plug\u0026gt;(coc-range-select) xmap \u0026lt;silent\u0026gt; \u0026lt;TAB\u0026gt; \u0026lt;Plug\u0026gt;(coc-range-select) xmap \u0026lt;silent\u0026gt; \u0026lt;S-TAB\u0026gt; \u0026lt;Plug\u0026gt;(coc-range-select-backword) xmap \u0026lt;leader\u0026gt;a \u0026lt;Plug\u0026gt;(coc-codeaction-selected) \u0026#34; 显示文档 nnoremap \u0026lt;silent\u0026gt; K :call \u0026lt;SID\u0026gt;show_documentation()\u0026lt;CR\u0026gt; \u0026#34; 回车：补全框?确认补全:回车可以撤回 inoremap \u0026lt;expr\u0026gt; \u0026lt;cr\u0026gt; pumvisible() ? \u0026#34;\\\u0026lt;C-y\u0026gt;\u0026#34; : \u0026#34;\\\u0026lt;C-g\u0026gt;u\\\u0026lt;CR\u0026gt;\u0026#34; \u0026#34; \u0026lt;c-c\u0026gt;触发补全 inoremap \u0026lt;silent\u0026gt;\u0026lt;expr\u0026gt; \u0026lt;c-c\u0026gt; coc#refresh() inoremap \u0026lt;expr\u0026gt;\u0026lt;S-TAB\u0026gt; pumvisible() ? \u0026#34;\\\u0026lt;C-p\u0026gt;\u0026#34; : \u0026#34;\\\u0026lt;C-h\u0026gt;\u0026#34; inoremap \u0026lt;silent\u0026gt;\u0026lt;expr\u0026gt; \u0026lt;TAB\u0026gt; \\ pumvisible() ? \u0026#34;\\\u0026lt;C-n\u0026gt;\u0026#34; : \\ \u0026lt;SID\u0026gt;check_back_space() ? \u0026#34;\\\u0026lt;TAB\u0026gt;\u0026#34; : \\ coc#refresh() \u0026#34; Use `:Format` to format current buffer command! -nargs=0 Format :call CocAction(\u0026#39;format\u0026#39;) \u0026#34; Use `:Fold` to fold current buffer command! -nargs=? Fold :call CocAction(\u0026#39;fold\u0026#39;, \u0026lt;f-args\u0026gt;) \u0026#34; set statusline^=%{coc#status()}%{get(b:,\u0026#39;coc_current_function\u0026#39;,\u0026#39;\u0026#39;)} \u0026#34; autocmd CursorHold * silent call CocActionAsync(\u0026#39;highlight\u0026#39;) function! s:show_documentation() if (index([\u0026#39;vim\u0026#39;,\u0026#39;help\u0026#39;], \u0026amp;filetype) \u0026gt;= 0) execute \u0026#39;h \u0026#39;.expand(\u0026#39;\u0026lt;cword\u0026gt;\u0026#39;) else call CocAction(\u0026#39;doHover\u0026#39;) endif endfunction function! s:check_back_space() abort let col = col(\u0026#39;.\u0026#39;) - 1 return !col || getline(\u0026#39;.\u0026#39;)[col - 1] =~# \u0026#39;\\s\u0026#39; endfunction \u0026#34; -------------------- plug ------------------------ call plug#begin(\u0026#39;~/.vim/plugins\u0026#39;) Plug \u0026#39;dracula/vim\u0026#39;, { \u0026#39;as\u0026#39;: \u0026#39;dracula\u0026#39; } Plug \u0026#39;mhinz/vim-startify\u0026#39; Plug \u0026#39;SirVer/ultisnips\u0026#39; Plug \u0026#39;jiangmiao/auto-pairs\u0026#39; Plug \u0026#39;vim-airline/vim-airline\u0026#39; Plug \u0026#39;vim-airline/vim-airline-themes\u0026#39; Plug \u0026#39;scrooloose/nerdcommenter\u0026#39; \u0026#34; NERDTree Plug \u0026#39;scrooloose/nerdtree\u0026#39; \u0026#34; git Plug \u0026#39;Xuyuanp/nerdtree-git-plugin\u0026#39; \u0026#34; icon \u0026#34; Plug \u0026#39;ryanoasis/vim-devicons\u0026#39; \u0026#34; coc \u0026#34; Plug \u0026#39;neoclide/coc.nvim\u0026#39;, {\u0026#39;do\u0026#39;: \u0026#39;yarn install --frozen-lockfile\u0026#39; } \u0026#34; golang \u0026#34; Plug \u0026#39;fatih/vim-go\u0026#39; \u0026#34; typescript \u0026#34; Plug \u0026#39;leafgarland/typescript-vim\u0026#39;, {\u0026#39;for\u0026#39;: [\u0026#39;typescript\u0026#39;, \u0026#39;typescript.tsx\u0026#39;, \u0026#39;js\u0026#39;]} \u0026#34; prettier \u0026#34;Plug \u0026#39;prettier/vim-prettier\u0026#39;, { \u0026#34; \\ \u0026#39;do\u0026#39;: \u0026#39;yarn install\u0026#39;, \u0026#34; \\ \u0026#39;for\u0026#39;: [\u0026#39;javascript\u0026#39;, \u0026#39;typescript\u0026#39;, \u0026#39;css\u0026#39;, \u0026#39;less\u0026#39;, \u0026#39;scss\u0026#39;, \u0026#39;json\u0026#39;, \u0026#39;graphql\u0026#39;, \u0026#39;markdown\u0026#39;, \u0026#39;vue\u0026#39;, \u0026#39;yaml\u0026#39;, \u0026#39;html\u0026#39;] } \u0026#34;Plug \u0026#39;Valloric/YouCompleteMe\u0026#39; call plug#end() \u0026#34; 替换函数 \u0026#34; 参数说明： \u0026#34; confirm：是否替换前逐一确认 \u0026#34; wholeword：是否整词匹配 \u0026#34; replace：被替换字符串 function! Replace(confirm, wholeword, replace) wa let flag = \u0026#39;\u0026#39; if a:confirm let flag .= \u0026#39;gec\u0026#39; else let flag .= \u0026#39;ge\u0026#39; endif let search = \u0026#39;\u0026#39; if a:wholeword let search .= \u0026#39;\\\u0026lt;\u0026#39; . escape(expand(\u0026#39;\u0026lt;cword\u0026gt;\u0026#39;), \u0026#39;/\\.*$^~[\u0026#39;) . \u0026#39;\\\u0026gt;\u0026#39; else let search .= expand(\u0026#39;\u0026lt;cword\u0026gt;\u0026#39;) endif let replace = escape(a:replace, \u0026#39;/\\\u0026amp;~\u0026#39;) execute \u0026#39;argdo %s/\u0026#39; . search . \u0026#39;/\u0026#39; . replace . \u0026#39;/\u0026#39; . flag . \u0026#39;| update\u0026#39; endfunction \u0026#34; 不确认、非整词 nnoremap \u0026lt;Leader\u0026gt;R :call Replace(0, 0, input(\u0026#39;Replace \u0026#39;.expand(\u0026#39;\u0026lt;cword\u0026gt;\u0026#39;).\u0026#39; with: \u0026#39;))\u0026lt;CR\u0026gt; \u0026#34; 不确认、整词 nnoremap \u0026lt;Leader\u0026gt;rw :call Replace(0, 1, input(\u0026#39;Replace \u0026#39;.expand(\u0026#39;\u0026lt;cword\u0026gt;\u0026#39;).\u0026#39; with: \u0026#39;))\u0026lt;CR\u0026gt; \u0026#34; 确认、非整词 nnoremap \u0026lt;Leader\u0026gt;rc :call Replace(1, 0, input(\u0026#39;Replace \u0026#39;.expand(\u0026#39;\u0026lt;cword\u0026gt;\u0026#39;).\u0026#39; with: \u0026#39;))\u0026lt;CR\u0026gt; \u0026#34; 确认、整词 nnoremap \u0026lt;Leader\u0026gt;rcw :call Replace(1, 1, input(\u0026#39;Replace \u0026#39;.expand(\u0026#39;\u0026lt;cword\u0026gt;\u0026#39;).\u0026#39; with: \u0026#39;))\u0026lt;CR\u0026gt; nnoremap \u0026lt;Leader\u0026gt;rwc :call Replace(1, 1, input(\u0026#39;Replace \u0026#39;.expand(\u0026#39;\u0026lt;cword\u0026gt;\u0026#39;).\u0026#39; with: \u0026#39;))\u0026lt;CR\u0026gt; ","id":22,"section":"post","summary":"\u0026#34; .vimrc \u0026#34; Configuration file for vim set modelines=0 \u0026#34; Don\u0026#39;t write backup file if vim is being called by \u0026#34;crontab -e\u0026#34; \u0026#34; au BufWrite /private/tmp/crontab.* set nowritebackup nobackup \u0026#34; Don\u0026#39;t write backup file if vim is being called by \u0026#34;chpass\u0026#34; \u0026#34; au BufWrite /private/etc/pw.* set nowritebackup nobackup set nobackup set nowritebackup let skip_defaults_vim=1 \u0026#34; \u0026lt;leader\u0026gt; let g:mapleader=\u0026#34;,\u0026#34; \u0026#34; 去掉有关vi一致性模式","tags":["vim"],"title":"vimrc","uri":"https://rx-78-kum0.github.io/2019/06/vimrc/","year":"2019"},{"content":" golang 接口值: 一个包含 nil 指针的接口不是 nil 接口.\n一个不包含任何值的 nil 接口值和一个刚好包含 nil 指针的接口值是不同的.\n 接口值由两个部分组成:\n 一个具体的类型 那个类型的值  它们被称为接口的动态类型和动态值.\n   type value     x x    接口的零值是指动态类型为nil, 动态值也为nil.\n   type value     nil nil    这样的接口才能满足 接口值 == nil.\nvar a interface{} fmt.Println(a == nil) // true 一个不包含任何值的 nil 接口值: interface 类型变量的动态类型和动态值都为 nil. 比如 nil, 或者:\nvar a interface{} fmt.Println(a) // a为nil 一个刚好包含 nil 指针的接口值: 赋值给后，interface 类型变量的动态类型不为 nil，动态值为 nil.\nvar a interface{} var b *string a = b fmt.Println(a) // 此时a的动态类型为*string，动态值为nil 这两种对象比较: func main(){ var a interface{} // nil  var b *string // nil  a = b fmt.Println(a == nil) // false  fmt.Println(b == nil) // true  fmt.Println(b == a) // true }   a = nil 为 false: b 赋值给 a, a 的动态类型为 *string, 动态值为 nil, 所以 a = nil 为 false.\n// 空接口 type eface struct { _type *_type // 类型信息  data unsafe.Pointer // 指向数据的指针 } // 带有方法的接口 type iface struct { tab *itab // 存储type信息还有结构实现方法的集合  data unsafe.Pointer // 指向数据的指针 }   根据 interface 的底层实现, a = b 实则是 a.data = unsafe.Pointer(\u0026amp;b). a = nil 才是 a.data = nil.\n  b == nil 为 true: b 是一个空的指针(非接口)类型.\n  b == a 为 true: 值都为 nil, b 是一个空的指针(非接口)类型.\n  ","id":23,"section":"post","summary":"golang 接口值: 一个包含 nil 指针的接口不是 nil 接口. 一个不包含任何值的 nil 接口值和一个刚好包含 nil 指针的接口值是不同的. 接口值由两个部分组成: 一个具体的类","tags":["golang"],"title":"一个包含 nil 指针的接口不是 nil 接口","uri":"https://rx-78-kum0.github.io/2019/03/%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%AB-nil-%E6%8C%87%E9%92%88%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%B8%8D%E6%98%AF-nil-%E6%8E%A5%E5%8F%A3/","year":"2019"},{"content":"{ // editor \u0026#34;editor.fontSize\u0026#34;: 14, \u0026#34;editor.snippetSuggestions\u0026#34;: \u0026#34;top\u0026#34;, \u0026#34;editor.formatOnSave\u0026#34;: true, \u0026#34;explorer.confirmDragAndDrop\u0026#34;: true, \u0026#34;explorer.confirmDelete\u0026#34;: false, \u0026#34;editor.detectIndentation\u0026#34;: false, \u0026#34;files.autoSave\u0026#34;: \u0026#34;off\u0026#34;, // \u0026#34;editor.fontFamily\u0026#34;: \u0026#34;\u0026#39;FuraCode\u0026#39;, Menlo, Monaco, \u0026#39;Courier New\u0026#39;, monospace\u0026#34;, \u0026#34;editor.fontLigatures\u0026#34;: true, \u0026#34;workbench.iconTheme\u0026#34;: \u0026#34;material-icon-theme\u0026#34;, \u0026#34;workbench.colorTheme\u0026#34;: \u0026#34;Nebula\u0026#34;, // prettier \u0026#34;prettier.printWidth\u0026#34;: 120, \u0026#34;editor.tabSize\u0026#34;: 2, \u0026#34;prettier.singleQuote\u0026#34;: true, \u0026#34;prettier.semi\u0026#34;: true, // typescript \u0026#34;typescript.updateImportsOnFileMove.enabled\u0026#34;: \u0026#34;always\u0026#34;, // emmet \u0026#34;emmet.includeLanguages\u0026#34;: { \u0026#34;javascript\u0026#34;: \u0026#34;javascriptreact\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;typescriptreact\u0026#34; }, \u0026#34;emmet.triggerExpansionOnTab\u0026#34;: true, // 装饰器 \u0026#34;javascript.implicitProjectConfig.experimentalDecorators\u0026#34;: true, // stylus \u0026#34;stylusSupremacy.insertColons\u0026#34;: false, // 是否插入冒号 \u0026#34;stylusSupremacy.insertSemicolons\u0026#34;: false, // 是否插入分好 \u0026#34;stylusSupremacy.insertBraces\u0026#34;: false, // 是否插入大括号 \u0026#34;stylusSupremacy.insertNewLineAroundImports\u0026#34;: true, // import之后是否换行 \u0026#34;stylusSupremacy.insertNewLineAroundBlocks\u0026#34;: true, \u0026#34;stylusSupremacy.insertSpaceAfterComment\u0026#34;: true, \u0026#34;window.zoomLevel\u0026#34;: 0, // Formatter \u0026#34;[javascript]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;vscode.typescript-language-features\u0026#34; }, \u0026#34;[typescript]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34; }, \u0026#34;[json]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34; }, \u0026#34;[jsonc]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34; }, \u0026#34;[typescriptreact]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34; }, \u0026#34;[html]\u0026#34;: { \u0026#34;editor.defaultFormatter\u0026#34;: \u0026#34;esbenp.prettier-vscode\u0026#34; }, \u0026#34;search.followSymlinks\u0026#34;: false, // vim \u0026#34;vim.useSystemClipboard\u0026#34;: true, \u0026#34;vim.hlsearch\u0026#34;: true, \u0026#34;vim.smartcase\u0026#34;: true, \u0026#34;vim.leader\u0026#34;: \u0026#34;,\u0026#34;, \u0026#34;vim.highlightedyank.enable\u0026#34;: true, \u0026#34;vim.highlightedyank.duration\u0026#34;: 1000, \u0026#34;vim.highlightedyank.color\u0026#34;: \u0026#34;rgba(250, 240, 170, 0.5)\u0026#34;, \u0026#34;vim.history\u0026#34;: 100, // \u0026#34;vim.cursorStylePerMode.insert\u0026#34;: \u0026#34;line\u0026#34;, // \u0026#34;vim.cursorStylePerMode.normal\u0026#34;: \u0026#34;underline\u0026#34;, // \u0026#34;vim.cursorStylePerMode.replace\u0026#34;: \u0026#34;underline\u0026#34;, // \u0026#34;vim.cursorStylePerMode.visual\u0026#34;: \u0026#34;blink\u0026#34;, // \u0026#34;vim.cursorStylePerMode.visualblock\u0026#34;: \u0026#34;blink\u0026#34;, // \u0026#34;vim.cursorStylePerMode.visualline\u0026#34;: \u0026#34;underline\u0026#34;, \u0026#34;vim.easymotion\u0026#34;: true, \u0026#34;vim.easymotionMarkerFontSize\u0026#34;: \u0026#34;16\u0026#34;, \u0026#34;vim.easymotionMarkerHeight\u0026#34;: 16, \u0026#34;vim.easymotionMarkerWidthPerChar\u0026#34;: 9, \u0026#34;vim.normalModeKeyBindings\u0026#34;: [], \u0026#34;vim.normalModeKeyBindingsNonRecursive\u0026#34;: [ { \u0026#34;before\u0026#34;: [\u0026#34;d\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;d\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;d\u0026#34;, \u0026#34;d\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;d\u0026#34;, \u0026#34;d\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;D\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;D\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;t\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;x\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;X\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;X\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;s\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;s\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;S\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;S\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;c\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;c\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;C\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;C\u0026#34;] } ], \u0026#34;vim.visualModeKeyBindings\u0026#34;: [ { \u0026#34;before\u0026#34;: [\u0026#34;s\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;s\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;S\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;_\u0026#34;, \u0026#34;S\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;z\u0026#34;, \u0026#34;)\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;c\u0026#34;, \u0026#34;(\u0026#34;, \u0026#34;)\u0026#34;, \u0026#34;\u0026lt;Esc\u0026gt;\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;p\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;z\u0026#34;, \u0026#34;}\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;c\u0026#34;, \u0026#34;{\u0026#34;, \u0026#34;}\u0026#34;, \u0026#34;\u0026lt;Esc\u0026gt;\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;p\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;z\u0026#34;, \u0026#34;]\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;c\u0026#34;, \u0026#34;[\u0026#34;, \u0026#34;]\u0026#34;, \u0026#34;\u0026lt;Esc\u0026gt;\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;p\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;z\u0026#34;, \u0026#34;\u0026#39;\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;c\u0026#34;, \u0026#34;\u0026#39;\u0026#34;, \u0026#34;\u0026#39;\u0026#34;, \u0026#34;\u0026lt;Esc\u0026gt;\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;p\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;z\u0026#34;, \u0026#34;\\\u0026#34;\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;c\u0026#34;, \u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;\u0026lt;Esc\u0026gt;\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;p\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;z\u0026#34;, \u0026#34;\u0026gt;\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;c\u0026#34;, \u0026#34;\u0026lt;\u0026#34;, \u0026#34;\u0026gt;\u0026#34;, \u0026#34;\u0026lt;Esc\u0026gt;\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;p\u0026#34;] }, { \u0026#34;before\u0026#34;: [\u0026#34;z\u0026#34;, \u0026#34;`\u0026#34;], \u0026#34;after\u0026#34;: [\u0026#34;c\u0026#34;, \u0026#34;`\u0026#34;, \u0026#34;`\u0026#34;, \u0026#34;\u0026lt;Esc\u0026gt;\u0026#34;, \u0026#34;h\u0026#34;, \u0026#34;p\u0026#34;] } ], \u0026#34;vim.handleKeys\u0026#34;: { \u0026#34;\u0026lt;C-a\u0026gt;\u0026#34;: false, \u0026#34;\u0026lt;C-f\u0026gt;\u0026#34;: false } } ","id":24,"section":"post","summary":"{ // editor \u0026#34;editor.fontSize\u0026#34;: 14, \u0026#34;editor.snippetSuggestions\u0026#34;: \u0026#34;top\u0026#34;, \u0026#34;editor.formatOnSave\u0026#34;: true, \u0026#34;explorer.confirmDragAndDrop\u0026#34;: true, \u0026#34;explorer.confirmDelete\u0026#34;: false, \u0026#34;editor.detectIndentation\u0026#34;: false, \u0026#34;files.autoSave\u0026#34;: \u0026#34;off\u0026#34;, // \u0026#34;editor.fontFamily\u0026#34;: \u0026#34;\u0026#39;FuraCode\u0026#39;, Menlo, Monaco, \u0026#39;Courier New\u0026#39;, monospace\u0026#34;, \u0026#34;editor.fontLigatures\u0026#34;: true, \u0026#34;workbench.iconTheme\u0026#34;: \u0026#34;material-icon-theme\u0026#34;, \u0026#34;workbench.colorTheme\u0026#34;: \u0026#34;Nebula\u0026#34;, // prettier \u0026#34;prettier.printWidth\u0026#34;: 120, \u0026#34;editor.tabSize\u0026#34;: 2, \u0026#34;prettier.singleQuote\u0026#34;: true, \u0026#34;prettier.semi\u0026#34;: true, // typescript \u0026#34;typescript.updateImportsOnFileMove.enabled\u0026#34;: \u0026#34;always\u0026#34;, // emmet \u0026#34;emmet.includeLanguages\u0026#34;: { \u0026#34;javascript\u0026#34;: \u0026#34;javascriptreact\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;typescriptreact\u0026#34; }, \u0026#34;emmet.triggerExpansionOnTab\u0026#34;: true, // 装饰器 \u0026#34;javascript.implicitProjectConfig.experimentalDecorators\u0026#34;: true, // stylus \u0026#34;stylusSupremacy.insertColons\u0026#34;: false, // 是否插","tags":["vscode"],"title":"vscode配置","uri":"https://rx-78-kum0.github.io/2019/03/vscode/","year":"2019"}],"tags":[{"title":"angular","uri":"https://rx-78-kum0.github.io/tags/angular/"},{"title":"css","uri":"https://rx-78-kum0.github.io/tags/css/"},{"title":"docker","uri":"https://rx-78-kum0.github.io/tags/docker/"},{"title":"emacs","uri":"https://rx-78-kum0.github.io/tags/emacs/"},{"title":"golang","uri":"https://rx-78-kum0.github.io/tags/golang/"},{"title":"mac","uri":"https://rx-78-kum0.github.io/tags/mac/"},{"title":"mysql","uri":"https://rx-78-kum0.github.io/tags/mysql/"},{"title":"nasm","uri":"https://rx-78-kum0.github.io/tags/nasm/"},{"title":"shell","uri":"https://rx-78-kum0.github.io/tags/shell/"},{"title":"tools","uri":"https://rx-78-kum0.github.io/tags/tools/"},{"title":"typescript","uri":"https://rx-78-kum0.github.io/tags/typescript/"},{"title":"vim","uri":"https://rx-78-kum0.github.io/tags/vim/"},{"title":"vscode","uri":"https://rx-78-kum0.github.io/tags/vscode/"},{"title":"web","uri":"https://rx-78-kum0.github.io/tags/web/"},{"title":"操作系统","uri":"https://rx-78-kum0.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"title":"汇编","uri":"https://rx-78-kum0.github.io/tags/%E6%B1%87%E7%BC%96/"}]}